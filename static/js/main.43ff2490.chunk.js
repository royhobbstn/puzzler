(this.webpackJsonppuzzler=this.webpackJsonppuzzler||[]).push([[0],{172:function(e,t,n){e.exports=n(633)},630:function(e,t,n){},633:function(e,t,n){"use strict";n.r(t);var a=n(0),i=n.n(a),s=n(46),r=n.n(s),l=n(14),o=n(8),d="data-structure",c="Heap",u={1:{problemID:1,problemName:"Implement **prepend** in a *LinkedList* class.",problemText:"Write a **prepend** method in a *LinkedList* class that accepts an arbitrary `value` parameter, creates a new Node, and inserts it at the front of the list.  The method should return the original list.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"empty list, head value",inherit:[1],code:"ll.prepend(5);",evaluate:"ll.head.value;",expected:5},{id:3,name:"empty list, tail value",inherit:[1],code:"ll.prepend(6);",evaluate:"ll.tail.value;",expected:6},{id:4,name:"insert two nodes",inherit:[1,2],code:"ll.prepend(7);",evaluate:"ll.tail.value === 5 && ll.head.value === 7;",expected:!0},{id:5,name:"returns itself",inherit:[1,2],code:"",evaluate:"ll.prepend(10) === ll;",expected:!0}],setupCode:"",category:"Linked List",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  prepend(value) {"},{stage:2,text:"    const newNode = new LinkedListNode(value, this.head);"},{stage:2,text:"    this.head = newNode;"},{stage:2,text:""},{stage:3,text:"    if (!this.tail) {"},{stage:3,text:"      this.tail = newNode;"},{stage:3,text:"    }"},{stage:2,text:""},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:"}"},{stage:0,text:""}]}},2:{problemID:2,problemName:"Implement **append** in a *LinkedList* class.",problemText:"Write an **append** method in a *LinkedList* class that accepts an arbitrary `value` parameter, creates a new Node, and inserts it at the end of the list.  The method should return the original list.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"append one node, check head",inherit:[1],code:"ll.append(5);",evaluate:"ll.head.value;",expected:5},{id:3,name:"append one node, check tail",inherit:[1,2],code:"",evaluate:"ll.tail.value;",expected:5},{id:4,name:"append two nodes, check head",inherit:[1,2],code:"ll.append(7);",evaluate:"ll.head.value;",expected:5},{id:5,name:"append two nodes, check tail",inherit:[1,2,4],code:"",evaluate:"ll.tail.value;",expected:7},{id:6,name:"returns itself",inherit:[1,2],code:"",evaluate:"ll.append(10) === ll;",expected:!0}],setupCode:"",category:"Linked List",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  append(value) {"},{stage:2,text:"    const newNode = new LinkedListNode(value);"},{stage:2,text:""},{stage:3,text:"    if (!this.head) {"},{stage:4,text:"      this.head = newNode;"},{stage:4,text:"      this.tail = newNode;"},{stage:4,text:"      return this;"},{stage:3,text:"    }"},{stage:3,text:""},{stage:5,text:"    this.tail.next = newNode;"},{stage:5,text:"    this.tail = newNode;"},{stage:5,text:""},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:"}"},{stage:0,text:""}]}},3:{problemID:3,problemName:"Implement **delete** in a *LinkedList* class.",problemText:"Write a **delete** method in a *LinkedList* class that accepts an arbitrary `value` parameter and removes all nodes that match that value.  The method should return the last node deleted (or `null` if no match found).",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"delete head return value",inherit:[1],code:"ll.append(5);ll.append(4);ll.append(7);ll.append(8);",evaluate:"ll.delete(5).value;",expected:5},{id:3,name:"delete tail return value",inherit:[1,2],code:"",evaluate:"ll.delete(8).value;",expected:8},{id:4,name:"delete head resets head",inherit:[1,2],code:"",evaluate:"ll.delete(5);ll.head.value;",expected:4},{id:5,name:"delete tail resets tail",inherit:[1,2],code:"",evaluate:"ll.delete(8);ll.tail.value;",expected:7},{id:6,name:"delete second item, head points to correct next",inherit:[1,2],code:"",evaluate:"ll.delete(4);ll.head.next.value;",expected:7}],setupCode:"\n  LinkedList.prototype.append = function (value) {\n    const newNode = new LinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    this.tail = newNode;\n    return this;\n  };",category:"Linked List",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,210,270],solutionLines:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  delete(value) {"},{stage:2,text:"    if (!this.head) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:2,text:""},{stage:3,text:"    let deletedNode = null;"},{stage:3,text:""},{stage:4,text:"    while (this.head && this.head.value === value) {"},{stage:4,text:"      deletedNode = this.head;"},{stage:4,text:"      this.head = this.head.next;"},{stage:4,text:"    }"},{stage:4,text:""},{stage:5,text:"    let currentNode = this.head;"},{stage:5,text:""},{stage:5,text:"    if (currentNode !== null) {"},{stage:6,text:"      while (currentNode.next) {"},{stage:6,text:"        if (currentNode.next.value === value) {"},{stage:7,text:"          deletedNode = currentNode.next;"},{stage:7,text:"          currentNode.next = currentNode.next.next;"},{stage:7,text:"        } else {"},{stage:7,text:"          currentNode = currentNode.next;"},{stage:6,text:"        }"},{stage:6,text:"      }"},{stage:5,text:"    }"},{stage:5,text:""},{stage:8,text:"    if (this.tail.value === value) {"},{stage:8,text:"      this.tail = currentNode;"},{stage:8,text:"    }"},{stage:3,text:""},{stage:2,text:"    return deletedNode;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},4:{problemID:4,problemName:"Implement **find** in a *LinkedList* class.",problemText:"Write a **find** method in a *LinkedList* class that accepts an arbitrary `value` parameter and returns the first node that matches that value, or `null` if no matching value was found.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"find head value",inherit:[1],code:"ll.append(5);ll.append(4);ll.append(7);ll.append(8);",evaluate:"ll.find(5).value;",expected:5},{id:3,name:"find tail value",inherit:[1,2],code:"",evaluate:"ll.find(8).value;",expected:8},{id:4,name:"find a middle value",inherit:[1,2],code:"",evaluate:"ll.find(7).value;",expected:7},{id:5,name:"return null for non-existent value",inherit:[1,2],code:"",evaluate:"ll.find(17);",expected:null},{id:6,name:"return null when empty list",inherit:[1],code:"",evaluate:"ll.find(27);",expected:null}],setupCode:"\n  LinkedList.prototype.append = function (value) {\n    const newNode = new LinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    this.tail = newNode;\n    return this;\n  };",category:"Linked List",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  find(value) {"},{stage:2,text:"    if (!this.head) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:3,text:""},{stage:3,text:"    let currentNode = this.head;"},{stage:3,text:""},{stage:4,text:"    while (currentNode) {"},{stage:5,text:"      if (currentNode.value === value) {"},{stage:5,text:"        return currentNode;"},{stage:5,text:"      }"},{stage:5,text:"      currentNode = currentNode.next;"},{stage:4,text:"    }"},{stage:4,text:""},{stage:3,text:"    return null;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},5:{problemID:5,problemName:"Implement **deleteTail** in a *LinkedList* class.",problemText:"Write a **deleteTail** method in a *LinkedList* class that will remove the last node (the tail) of a list (if it exists, else null) and return it.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"delete tail and find return value",inherit:[1],code:"ll.append(5);ll.append(4);ll.append(7);ll.append(8);",evaluate:"ll.deleteTail().value;",expected:8},{id:3,name:"properly resets so following tail element can be deleted",inherit:[1,2],code:"",evaluate:"ll.deleteTail();ll.deleteTail().value;",expected:7},{id:4,name:"deleting tail of an empty list returns null",inherit:[1],code:"",evaluate:"ll.deleteTail();",expected:null}],setupCode:"\n  LinkedList.prototype.append = function (value) {\n    const newNode = new LinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    this.tail = newNode;\n    return this;\n  };",category:"Linked List",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,240],solutionLines:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  deleteTail() {"},{stage:2,text:"    const deletedTail = this.tail;"},{stage:3,text:""},{stage:3,text:"    if (this.head === this.tail) {"},{stage:4,text:"      this.head = null;"},{stage:4,text:"      this.tail = null;"},{stage:4,text:"      return deletedTail;"},{stage:3,text:"    }"},{stage:3,text:""},{stage:5,text:"    let currentNode = this.head;"},{stage:5,text:"    while (currentNode.next) {"},{stage:6,text:"      if (!currentNode.next.next) {"},{stage:7,text:"        currentNode.next = null;"},{stage:6,text:"      } else {"},{stage:7,text:"        currentNode = currentNode.next;"},{stage:6,text:"      }"},{stage:5,text:"    }"},{stage:6,text:""},{stage:6,text:"    this.tail = currentNode;"},{stage:6,text:""},{stage:2,text:"    return deletedTail;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},6:{problemID:6,problemName:"Implement **deleteHead** in a *LinkedList* class.",problemText:"Write a **deleteHead** method in a *LinkedList* class that will remove the first node (the head) of a list (if it exists, else null) and return it.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"delete head and find return value",inherit:[1],code:"ll.append(5);ll.append(4);ll.append(7);ll.append(8);",evaluate:"ll.deleteHead().value;",expected:5},{id:3,name:"delete head, properly set next head, delete and find return value",inherit:[1,2],code:"",evaluate:"ll.deleteHead();ll.deleteHead().value;",expected:4},{id:4,name:"delete head from empty list returns null",inherit:[1],code:"",evaluate:"ll.deleteHead();",expected:null}],setupCode:"\n  LinkedList.prototype.append = function (value) {\n    const newNode = new LinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    this.tail = newNode;\n    return this;\n  };",category:"Linked List",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,210],solutionLines:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  deleteHead() {"},{stage:2,text:"    if (!this.head) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:3,text:""},{stage:3,text:"    const deletedHead = this.head;"},{stage:3,text:""},{stage:4,text:"    if (this.head.next) {"},{stage:5,text:"      this.head = this.head.next;"},{stage:4,text:"    } else {"},{stage:6,text:"      this.head = null;"},{stage:6,text:"      this.tail = null;"},{stage:4,text:"    }"},{stage:3,text:""},{stage:3,text:"    return deletedHead;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},7:{problemID:7,problemName:"Implement **fromArray** in a *LinkedList* class.",problemText:"Given a *LinkedList* class with an **append** method, create a **fromArray** method that will take in an array of `values` as a parameter and return a *LinkedList*.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"converts array to linked list (and back)",inherit:[1],code:"ll.fromArray([1,2,3,4,5]);",evaluate:"ll.toArray()",expected:JSON.stringify([1,2,3,4,5])},{id:3,name:"double check values by stepping through (head)",inherit:[1,2],code:"",evaluate:"ll.head.value",expected:1},{id:4,name:"double check values by stepping through (tail)",inherit:[1,2],code:"",evaluate:"ll.tail.value",expected:5},{id:5,name:"empty fromArray results in empty list",inherit:[1],code:"ll.fromArray([]);",evaluate:"ll.head == null;",expected:!0},{id:6,name:"empty fromArray results in empty list",inherit:[1,5],code:"",evaluate:"ll.toArray();",expected:JSON.stringify([])},{id:7,name:"double check values by stepping through (head next)",inherit:[1,2],code:"",evaluate:"ll.head.next.value",expected:2}],setupCode:"\n  LinkedList.prototype.append = function (value) {\n    const newNode = new LinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    this.tail = newNode;\n    return this;\n  };\n  LinkedList.prototype.toArray = function () {\n    const values = [];\n    let currentNode = this.head;\n    while (currentNode) {\n      values.push(currentNode.value);\n      currentNode = currentNode.next;\n    }\n    return values;\n  };\n  ",category:"Linked List",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  // IMPLEMENTED: append(value: any) LinkedList"},{stage:0,text:""},{stage:1,text:"  fromArray(values) {"},{stage:3,text:"    values.forEach(value => this.append(value));"},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},8:{problemID:8,problemName:"Implement **toArray** in a *LinkedList* class.",problemText:"Provide a class method **toArray** that converts the value property of each LinkedListNode into a new array item, and returns that array.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"converts empty linked list to empty array",inherit:[1],code:"",evaluate:"ll.toArray();",expected:JSON.stringify([])},{id:3,name:"linked list of 4 items into array",inherit:[1],code:"ll.append(2).append(3).append(4).append(5);",evaluate:"ll.toArray();",expected:JSON.stringify([2,3,4,5])}],setupCode:"\n  LinkedList.prototype.append = function (value) {\n    const newNode = new LinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    this.tail = newNode;\n    return this;\n  };",category:"Linked List",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,150],solutionLines:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  toArray() {"},{stage:2,text:"    const values = [];"},{stage:2,text:""},{stage:3,text:"    let currentNode = this.head;"},{stage:3,text:"    while (currentNode) {"},{stage:4,text:"      values.push(currentNode.value);"},{stage:4,text:"      currentNode = currentNode.next;"},{stage:3,text:"    }"},{stage:3,text:""},{stage:2,text:"    return values;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},9:{problemID:9,problemName:"Reverse a *Linked List*.",problemText:"Write a method to reverse a Linked List in-place (not using a copy) which then returns itself.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"reverse a list",inherit:[1],code:"ll.append(1).append(2).append(3).append(4);",evaluate:"ll.reverse().toArray();",expected:JSON.stringify([4,3,2,1])},{id:3,name:"reverse an empty list",inherit:[1],code:"",evaluate:"ll.reverse().toArray();",expected:JSON.stringify([])}],setupCode:"\n  LinkedList.prototype.append = function (value) {\n    const newNode = new LinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    this.tail = newNode;\n    return this;\n  };\n  LinkedList.prototype.toArray = function () {\n    const values = [];\n    let currentNode = this.head;\n    while (currentNode) {\n      values.push(currentNode.value);\n      currentNode = currentNode.next;\n    }\n    return values;\n  };\n  ",category:"Linked List",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,240],solutionLines:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  reverse() {"},{stage:2,text:"    let currNode = this.head;"},{stage:3,text:"    let prevNode = null;"},{stage:3,text:"    let nextNode = null;"},{stage:3,text:""},{stage:4,text:"    while (currNode) {"},{stage:5,text:"      nextNode = currNode.next;"},{stage:5,text:"      currNode.next = prevNode;"},{stage:6,text:"      prevNode = currNode;"},{stage:6,text:"      currNode = nextNode;"},{stage:4,text:"    }"},{stage:4,text:""},{stage:7,text:"    this.tail = this.head;"},{stage:7,text:"    this.head = prevNode;"},{stage:3,text:""},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},10:{problemID:10,problemName:"Implement **prepend** in a *DoublyLinkedList* class.",problemText:"Write a **prepend** method in a *DoublyLinkedList* class that accepts an arbitrary `value` parameter, creates a *DoublyLinkedListNode*, and inserts it at the front of the list.  The method should return the original list.",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"prepend element onto empty list",inherit:[1],code:"dll.prepend(5);",evaluate:"dll.head.value;",expected:5},{id:3,name:"prepend element onto empty list, tail correct",inherit:[1,2],code:"",evaluate:"dll.tail.value;",expected:5},{id:4,name:"prepend 2nd element onto list, head correct",inherit:[1],code:"dll.prepend(7);",evaluate:"dll.head.value;",expected:7},{id:5,name:"prepend 2nd element onto list, tail correct",inherit:[1,2,4],code:"",evaluate:"dll.tail.value;",expected:5},{id:6,name:"prepend 2nd element onto list, head next correct",inherit:[1,2,4],code:"",evaluate:"dll.head.next.value;",expected:5}],setupCode:"",category:"Doubly Linked List",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  prepend(value) {"},{stage:2,text:"    const newNode = new DoublyLinkedListNode(value, this.head);"},{stage:2,text:""},{stage:3,text:"    if (this.head) {"},{stage:4,text:"      this.head.previous = newNode;"},{stage:3,text:"    }"},{stage:4,text:"    this.head = newNode;"},{stage:3,text:""},{stage:5,text:"    if (!this.tail) {"},{stage:5,text:"      this.tail = newNode;"},{stage:5,text:"    }"},{stage:4,text:""},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},11:{problemID:11,problemName:"Implement **append** in a *DoublyLinkedList* class.",problemText:"Write an **append** method in a *DoublyLinkedList* class that accepts an arbitrary `value` parameter, creates a *DoublyLinkedListNode*, and adds it to the end of the list.  The method should return the original list.",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"append onto empty list, head set correctly",inherit:[1],code:"dll.append(3);",evaluate:"dll.head.value;",expected:3},{id:3,name:"append onto empty list, tail set correctly",inherit:[1,2],code:"",evaluate:"dll.tail.value;",expected:3},{id:4,name:"append 2nd item onto list, check head",inherit:[1,2],code:"dll.append(8);",evaluate:"dll.head.value;",expected:3},{id:5,name:"append 2nd item onto list, check tail",inherit:[1,2,4],code:"",evaluate:"dll.tail.value;",expected:8},{id:6,name:"append 2nd item onto list, check head next",inherit:[1,2,4],code:"",evaluate:"dll.head.next.value;",expected:8}],setupCode:"",category:"Doubly Linked List",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  append(value) {"},{stage:2,text:"    const newNode = new DoublyLinkedListNode(value);"},{stage:2,text:""},{stage:3,text:"    if (!this.head) {"},{stage:4,text:"      this.head = newNode;"},{stage:4,text:"      this.tail = newNode;"},{stage:4,text:"      return this;"},{stage:3,text:"    }"},{stage:3,text:""},{stage:5,text:"    this.tail.next = newNode;"},{stage:5,text:"    newNode.previous = this.tail;"},{stage:5,text:"    this.tail = newNode;"},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},12:{problemID:12,problemName:"Implement **delete** in a *DoublyLinkedList* class.",problemText:"Write a **delete** method in a *DoublyLinkedList* class that accepts an arbitrary `value` parameter and deletes all `DoublyLinkedListNode` nodes that have a matching value.  The method should return the last node deleted (or `null` if no match found).",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"return null on empty list",inherit:[1],code:"",evaluate:"dll.delete(5);",expected:null},{id:3,name:"add and cleanly remove node from list (check head)",inherit:[1],code:"dll.append(5);dll.delete(5);",evaluate:"dll.head",expected:null},{id:4,name:"add and cleanly remove node from list (check tail)",inherit:[1,3],code:"",evaluate:"dll.tail",expected:null},{id:5,name:"add 3 nodes and delete the first",inherit:[1],code:"dll.append(1).append(2).append(3);",evaluate:"dll.delete(1);dll.head.value;",expected:2},{id:6,name:"add 3 nodes and delete the first (check tail)",inherit:[1,5],code:"",evaluate:"dll.delete(1);dll.tail.value;",expected:3},{id:7,name:"add 3 nodes and delete the second (check head connector)",inherit:[1,5],code:"",evaluate:"dll.delete(2);dll.head.next.value;",expected:3},{id:8,name:"add 3 nodes and delete the last (check tail)",inherit:[1,5],code:"",evaluate:"dll.delete(3);dll.tail.value;",expected:2},{id:9,name:"add 3 nodes and delete them all (check head)",inherit:[1,5],code:"",evaluate:"dll.delete(3);dll.delete(2);dll.delete(1);dll.head;",expected:null},{id:10,name:"add 3 nodes and delete them all (check tail)",inherit:[1,5],code:"",evaluate:"dll.delete(3);dll.delete(2);dll.delete(1);dll.tail;",expected:null}],setupCode:"\n  DoublyLinkedList.prototype.append = function(value) {\n    const newNode = new DoublyLinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    newNode.previous = this.tail;\n    this.tail = newNode;\n    return this;\n  }\n  ",category:"Doubly Linked List",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,210,240,270,300,330,360,420],solutionLines:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  delete(value) {"},{stage:2,text:"    if (!this.head) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:2,text:""},{stage:3,text:"    let deletedNode = null;"},{stage:3,text:"    let currentNode = this.head;"},{stage:3,text:""},{stage:4,text:"    while (currentNode) {"},{stage:5,text:"      if (currentNode.value === value) {"},{stage:6,text:"        deletedNode = currentNode;"},{stage:6,text:""},{stage:6,text:"        if (deletedNode === this.head) {"},{stage:7,text:"          this.head = deletedNode.next;"},{stage:7,text:""},{stage:8,text:"          if (this.head) {"},{stage:8,text:"            this.head.previous = null;"},{stage:8,text:"          }"},{stage:8,text:""},{stage:9,text:"          if (deletedNode === this.tail) {"},{stage:9,text:"            this.tail = null;"},{stage:9,text:"          }"},{stage:6,text:"        } else if (deletedNode === this.tail) {"},{stage:10,text:"          this.tail = deletedNode.previous;"},{stage:10,text:"          this.tail.next = null;"},{stage:6,text:"        } else {"},{stage:11,text:"          const previousNode = deletedNode.previous;"},{stage:11,text:"          const nextNode = deletedNode.next;"},{stage:11,text:""},{stage:12,text:"          previousNode.next = nextNode;"},{stage:12,text:"          nextNode.previous = previousNode;"},{stage:6,text:"        }"},{stage:5,text:"      }"},{stage:5,text:""},{stage:13,text:"      currentNode = currentNode.next;"},{stage:4,text:"    }"},{stage:7,text:""},{stage:7,text:"    return deletedNode;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},13:{problemID:13,problemName:"Implement **find** in a *DoublyLinkedList* class.",problemText:"Write a **find** method in a *DoublyLinkedList* class that accepts an arbitrary `value` parameter and finds (returns) the first `DoublyLinkedListNode` that has a matching value (or null if no match found).",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"find on an empty list",inherit:[1],code:"",evaluate:"dll.find(5);",expected:null},{id:3,name:"add one item, find that item",inherit:[1],code:"dll.append(4);",evaluate:"dll.find(4).value;",expected:4},{id:4,name:"add one item, find an item that does not exist",inherit:[1],code:"dll.append(4);",evaluate:"dll.find(6);",expected:null},{id:5,name:"add three items, find an item",inherit:[1],code:"dll.append(1).append(2).append(3);",evaluate:"dll.find(2).value;",expected:2},{id:6,name:"add three items -two dupicates, return the first",inherit:[1],code:"dll.append(1).append(2).append(2);",evaluate:"dll.find(2) === dll.head.next;",expected:!0}],setupCode:"\n  DoublyLinkedList.prototype.append = function(value) {\n    const newNode = new DoublyLinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    newNode.previous = this.tail;\n    this.tail = newNode;\n    return this;\n  }\n  ",category:"Doubly Linked List",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,210],solutionLines:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  find(value) {"},{stage:2,text:"    if (!this.head) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:3,text:""},{stage:3,text:"    let currentNode = this.head;"},{stage:3,text:""},{stage:4,text:"    while (currentNode) {"},{stage:5,text:"      if (currentNode.value === value) {"},{stage:5,text:"        return currentNode;"},{stage:5,text:"      }"},{stage:6,text:""},{stage:6,text:"      currentNode = currentNode.next;"},{stage:4,text:"    }"},{stage:4,text:""},{stage:4,text:"    return null;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},14:{problemID:14,problemName:"Implement **deleteTail** in a *DoublyLinkedList* class.",problemText:"Write a **deleteTail** method in a *DoublyLinkedList* class that will remove and return the last `DoublyLinkedListNode` in the list, or `null` if the list is empty.",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"return null if list is empty",inherit:[1],code:"",evaluate:"dll.deleteTail();",expected:null},{id:3,name:"return item from 1 item list.",inherit:[1],code:"dll.append(5);",evaluate:"dll.deleteTail().value;",expected:5},{id:4,name:"return item from 1 item list - head set correctly.",inherit:[1,3],code:"dll.deleteTail();",evaluate:"dll.head;",expected:null},{id:5,name:"return item from 1 item list - tail set correctly.",inherit:[1,3],code:"dll.deleteTail();",evaluate:"dll.tail;",expected:null},{id:6,name:"add 3 items, deleteTail twice.",inherit:[1],code:"dll.append(5).append(4).append(3);dll.deleteTail();dll.deleteTail();",evaluate:"dll.head.value",expected:5},{id:7,name:"add 3 items, deleteTail twice.",inherit:[1,6],code:"",evaluate:"dll.tail.value",expected:5}],setupCode:"\n  DoublyLinkedList.prototype.append = function(value) {\n    const newNode = new DoublyLinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    newNode.previous = this.tail;\n    this.tail = newNode;\n    return this;\n  }\n  ",category:"Doubly Linked List",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,210],solutionLines:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  deleteTail() {"},{stage:2,text:"    if (!this.tail) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:3,text:""},{stage:3,text:"    if (this.head === this.tail) {"},{stage:4,text:"      const deletedTail = this.tail;"},{stage:4,text:"      this.head = null;"},{stage:4,text:"      this.tail = null;"},{stage:4,text:"      return deletedTail;"},{stage:3,text:"    }"},{stage:5,text:""},{stage:6,text:"    const deletedTail = this.tail;"},{stage:6,text:"    this.tail = this.tail.previous;"},{stage:6,text:"    this.tail.next = null;"},{stage:5,text:""},{stage:5,text:"    return deletedTail;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},15:{problemID:15,problemName:"Implement **deleteHead** in a *DoublyLinkedList* class.",problemText:"Write a **deleteHead** method in a *DoublyLinkedList* class that will remove and return the first `DoublyLinkedListNode` in the list (or `null` if the list is empty).",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"deleteHead from an empty list returns null",inherit:[1],code:"",evaluate:"dll.deleteHead();",expected:null},{id:3,name:"add item and delete item",inherit:[1],code:"dll.append(8);",evaluate:"dll.deleteHead().value;",expected:8},{id:4,name:"add item and delete item - check head;",inherit:[1],code:"dll.append(8);dll.deleteHead();",evaluate:"dll.head;",expected:null},{id:5,name:"add item and delete item",inherit:[1,4],code:"",evaluate:"dll.tail;",expected:null},{id:6,name:"add 3 items and delete one",inherit:[1],code:"dll.append(6).append(7).append(8);",evaluate:"dll.deleteHead().value;",expected:6},{id:7,name:"add 3 items and delete one - check head",inherit:[1,6],code:"dll.deleteHead();",evaluate:"dll.head.value;",expected:7},{id:8,name:"add 3 items and delete one - check tail",inherit:[1,6,7],code:"",evaluate:"dll.tail.value;",expected:8}],setupCode:"\n  DoublyLinkedList.prototype.append = function(value) {\n    const newNode = new DoublyLinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    newNode.previous = this.tail;\n    this.tail = newNode;\n    return this;\n  }\n  ",category:"Doubly Linked List",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  deleteHead() {"},{stage:2,text:"    if (!this.head) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:3,text:""},{stage:3,text:"    const deletedHead = this.head;"},{stage:3,text:""},{stage:4,text:"    if (this.head.next) {"},{stage:5,text:"      this.head = this.head.next;"},{stage:5,text:"      this.head.previous = null;"},{stage:4,text:"    } else {"},{stage:6,text:"      this.head = null;"},{stage:6,text:"      this.tail = null;"},{stage:4,text:"    }"},{stage:4,text:""},{stage:4,text:"    return deletedHead;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},16:{problemID:16,problemName:"Implement **fromArray** in a *DoublyLinkedList* class.",problemText:"Given a *DoublyLinkedList* class with an **append** method, create a **fromArray** method that will take in an array of `values` as a parameter, populate corresponding `DoublyLinkedListNode`'s and return the list.",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"empty array creates empty list - check head",inherit:[1],code:"dll.fromArray([]);",evaluate:"dll.head;",expected:null},{id:3,name:"empty array creates empty list - check tail",inherit:[1,2],code:"",evaluate:"dll.tail;",expected:null},{id:4,name:"creates one-item list - check head",inherit:[1],code:"dll.fromArray([5]);",evaluate:"dll.head.value;",expected:5},{id:5,name:"creates one-item list - check tail",inherit:[1,4],code:"",evaluate:"dll.tail.value;",expected:5},{id:6,name:"creates three-item list - check head",inherit:[1],code:"dll.fromArray([6,7,8]);",evaluate:"dll.head.value;",expected:6},{id:7,name:"creates three-item list - check tail",inherit:[1,6],code:"",evaluate:"dll.tail.value;",expected:8},{id:8,name:"creates three-item list - check head next",inherit:[1,6],code:"",evaluate:"dll.head.next.value;",expected:7}],setupCode:"\n  DoublyLinkedList.prototype.append = function (value) {\n    const newNode = new DoublyLinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    newNode.previous = this.tail;\n    this.tail = newNode;\n    return this;\n  }\n  ",category:"Doubly Linked List",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED: append(value: any) DoublyLinkedList"},{stage:-1,text:""},{stage:1,text:"  fromArray(values) {"},{stage:3,text:"    values.forEach(value => this.append(value));"},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},17:{problemID:17,problemName:"Implement **toArray** in a *DoublyLinkedList* class.",problemText:"Provide a class method **toArray** that converts `DoublyLinkedListNode` `value`'s in a *DoublyLinkedList* into array elements in matching order.",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"empty list makes empty array",inherit:[1],code:"",evaluate:"dll.toArray();",expected:JSON.stringify([])},{id:3,name:"one item list",inherit:[1],code:"dll.append(4);",evaluate:"dll.toArray();",expected:JSON.stringify([4])},{id:4,name:"three item list",inherit:[1],code:"dll.append(4).append(5).append(6);",evaluate:"dll.toArray();",expected:JSON.stringify([4,5,6])}],setupCode:"\n  DoublyLinkedList.prototype.append = function (value) {\n    const newNode = new DoublyLinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    newNode.previous = this.tail;\n    this.tail = newNode;\n    return this;\n  }\n  ",category:"Doubly Linked List",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,150],solutionLines:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  toArray() {"},{stage:2,text:"    const nodes = [];"},{stage:2,text:""},{stage:3,text:"    let currentNode = this.head;"},{stage:3,text:"    while (currentNode) {"},{stage:4,text:"      nodes.push(currentNode.value);"},{stage:4,text:"      currentNode = currentNode.next;"},{stage:3,text:"    }"},{stage:3,text:""},{stage:2,text:"    return nodes;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},18:{problemID:18,problemName:"Reverse a *DoublyLinkedList* in-place.",problemText:"Provide a class method **reverse** that will reverse a *DoublyLinkedList* in place (not using a copy), and return the list.",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"reversing an empty list - still empty",inherit:[1],code:"",evaluate:"dll.reverse();",expected:'{"head":null,"tail":null}'},{id:3,name:"reversing a one item list - check head",inherit:[1],code:"dll.append(5);",evaluate:"dll.reverse().head.value;",expected:5},{id:4,name:"reversing a one item list - check head",inherit:[1,3],code:"",evaluate:"dll.reverse().tail.value;",expected:5},{id:5,name:"reversing a three item list - check head",inherit:[1],code:"dll.append(6).append(7).append(8);",evaluate:"dll.reverse().head.value;",expected:8},{id:6,name:"reversing a three item list - check head",inherit:[1,5],code:"",evaluate:"dll.reverse().tail.value;",expected:6},{id:7,name:"reversing a three item list - check head next",inherit:[1,5],code:"",evaluate:"dll.reverse().head.next.value;",expected:7}],setupCode:"\n  DoublyLinkedList.prototype.append = function(value) {\n    const newNode = new DoublyLinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    newNode.previous = this.tail;\n    this.tail = newNode;\n    return this;\n  }\n  ",category:"Doubly Linked List",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,240],solutionLines:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  reverse() {"},{stage:2,text:"    let currNode = this.head;"},{stage:2,text:"    let prevNode = null;"},{stage:2,text:"    let nextNode = null;"},{stage:3,text:""},{stage:3,text:"    while (currNode) {"},{stage:4,text:"      nextNode = currNode.next;"},{stage:4,text:"      prevNode = currNode.previous;"},{stage:4,text:""},{stage:5,text:"      currNode.next = prevNode;"},{stage:5,text:"      currNode.previous = nextNode;"},{stage:5,text:""},{stage:6,text:"      prevNode = currNode;"},{stage:6,text:"      currNode = nextNode;"},{stage:3,text:"    }"},{stage:3,text:""},{stage:7,text:"    this.tail = this.head;"},{stage:7,text:"    this.head = prevNode;"},{stage:7,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},19:{problemID:19,problemName:"Implement a recursive fibonacci function.",problemText:"Implement a function **fibonacciNth** which takes an integer parameter `n` and returns the nth indexed fibonnaci number in the sequence.  For example, n=0 would return 0, n=1 would return 1, n=2 would return 1, and n=3 would return 2. ([0,1,1,2,3,5,8,13... etc])",testCases:[{id:1,name:"0 case",inherit:[],code:"",evaluate:"fibonacciNth(0);",expected:0},{id:2,name:"1 case",inherit:[],code:"",evaluate:"fibonacciNth(1);",expected:1},{id:3,name:"2 case",inherit:[],code:"",evaluate:"fibonacciNth(2);",expected:1},{id:4,name:"3 case",inherit:[],code:"",evaluate:"fibonacciNth(3);",expected:2},{id:5,name:"4 case",inherit:[],code:"",evaluate:"fibonacciNth(4);",expected:3},{id:6,name:"5 case",inherit:[],code:"",evaluate:"fibonacciNth(5);",expected:5},{id:7,name:"6 case",inherit:[],code:"",evaluate:"fibonacciNth(6);",expected:8},{id:8,name:"7 case",inherit:[],code:"",evaluate:"fibonacciNth(7);",expected:13},{id:9,name:"8 case",inherit:[],code:"",evaluate:"fibonacciNth(8);",expected:21}],setupCode:"",category:"Fibonacci",type:"algorithm",difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:1,text:"const fibonacciNth = n => {"},{stage:2,text:"  if (n === 0 || n === 1) return n;"},{stage:3,text:"  return fibonacciNth(n - 1) + fibonacciNth(n - 2);"},{stage:1,text:"};"},{stage:0,text:""}]}},20:{problemID:20,problemName:"Implement an iterative fibonacci function.",problemText:"Implement a function `fibonacciNth` which takes an integer parameter `n` and returns the nth indexed fibonnaci number in the sequence.  For example, n=0 would return 0, n=1 would return 1, n=2 would return 1, and n=3 would return 2. ([0,1,1,2,3,5,8,13... etc])",testCases:[{id:1,name:"0 case",inherit:[],code:"",evaluate:"fibonacciNth(0);",expected:0},{id:2,name:"1 case",inherit:[],code:"",evaluate:"fibonacciNth(1);",expected:1},{id:3,name:"2 case",inherit:[],code:"",evaluate:"fibonacciNth(2);",expected:1},{id:4,name:"3 case",inherit:[],code:"",evaluate:"fibonacciNth(3);",expected:2},{id:5,name:"4 case",inherit:[],code:"",evaluate:"fibonacciNth(4);",expected:3},{id:6,name:"5 case",inherit:[],code:"",evaluate:"fibonacciNth(5);",expected:5},{id:7,name:"6 case",inherit:[],code:"",evaluate:"fibonacciNth(6);",expected:8},{id:8,name:"7 case",inherit:[],code:"",evaluate:"fibonacciNth(7);",expected:13},{id:9,name:"8 case",inherit:[],code:"",evaluate:"fibonacciNth(8);",expected:21}],setupCode:"",category:"Fibonacci",type:"algorithm",difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,210],solutionLines:[{stage:1,text:"function fibonacciNth(n) {"},{stage:2,text:"  let currentValue = 1;"},{stage:2,text:"  let previousValue = 0;"},{stage:2,text:""},{stage:3,text:"  if (n <= 1) {"},{stage:3,text:"    return n;"},{stage:3,text:"  }"},{stage:3,text:""},{stage:4,text:"  let iteration = 2;"},{stage:4,text:""},{stage:5,text:"  while (iteration <= n) {"},{stage:6,text:"    currentValue += previousValue;"},{stage:6,text:"    previousValue = currentValue - previousValue;"},{stage:6,text:"    iteration++;"},{stage:5,text:"  }"},{stage:5,text:""},{stage:4,text:"  return currentValue;"},{stage:1,text:"}"},{stage:0,text:""}]}},21:{problemID:21,problemName:"Implement a *Queue* using a *Linked List*",problemText:"\nGiven a *Queue* class, implement the following methods: \n    \n - **isEmpty** (which returns a Boolean value indicating if there are any items in the queue)\n - **peek** (which returns - but does not remove - the value at the head of the queue)\n - **enqueue** (which adds a value to the end of the queue - does not return anything)\n - **dequeue** (which removes and returns the value at the head of the queue).  \n    \nBase the implementation on the given *LinkedList* base data structure.  Return `null` for **peek** and **dequeue** if the queue is empty.",testCases:[{id:1,name:"compiles",inherit:[],code:"const queue=new Queue();",evaluate:"Boolean(queue);",expected:!0},{id:2,name:"peek on an empty queue returns null",inherit:[1],code:"",evaluate:"queue.peek();",expected:null},{id:3,name:"dequeue on an empty queue returns null",inherit:[1],code:"",evaluate:"queue.dequeue();",expected:null},{id:4,name:"peek returns enqueued item",inherit:[1],code:"queue.enqueue(5);",evaluate:"queue.peek();",expected:5},{id:5,name:"peek, queue, dequeue work together properly",inherit:[1],code:"queue.enqueue(5);queue.enqueue(7);queue.dequeue();",evaluate:"queue.peek();",expected:7},{id:6,name:"peek returns enqueued item (3)",inherit:[1],code:"queue.enqueue(5);queue.enqueue(6);queue.enqueue(7);",evaluate:"queue.peek();",expected:5},{id:7,name:"dequeue multiple enqueued items",inherit:[1],code:"queue.enqueue(5);queue.enqueue(6);queue.enqueue(7);queue.dequeue();queue.dequeue();",evaluate:"queue.peek();",expected:7},{id:8,name:"isEmpty returns true for empty queue",inherit:[1],code:"",evaluate:"queue.isEmpty();",expected:!0},{id:9,name:"isEmpty returns false for queue with an item",inherit:[1],code:"queue.enqueue(5);",evaluate:"queue.isEmpty();",expected:!1},{id:10,name:"dequeue returns value, not node",inherit:[1],code:"queue.enqueue(5);",evaluate:"queue.dequeue();",expected:5}],setupCode:"\n  \n  class LinkedListNode {\n    constructor(value, next = null) {\n      this.value = value;\n      this.next = next;\n    }\n  }\n  \n  class LinkedList {\n    constructor() {\n      this.head = null;\n      this.tail = null;\n    }\n    \n    append(value) {\n      const newNode = new LinkedListNode(value);\n      if (!this.head) {\n        this.head = newNode;\n        this.tail = newNode;\n        return this;\n      }\n      this.tail.next = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    \n    deleteHead() {\n      if (!this.head) {\n        return null;\n      }\n      const deletedHead = this.head;\n      if (this.head.next) {\n        this.head = this.head.next;\n      } else {\n        this.head = null;\n        this.tail = null;\n      }\n      return deletedHead;\n    }\n  }\n  ",category:"Queue",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,240],solutionLines:[{stage:-1,text:"//  class LinkedListNode {"},{stage:-1,text:"//    constructor(value, next = null) {"},{stage:-1,text:"//      this.value = value;"},{stage:-1,text:"//      this.next = next;"},{stage:-1,text:"//    }"},{stage:-1,text:"//  }"},{stage:-1,text:"//"},{stage:-1,text:"//  class LinkedList {"},{stage:-1,text:"//    constructor() {"},{stage:-1,text:"//      this.head = null;"},{stage:-1,text:"//      this.tail = null;"},{stage:-1,text:"//    }"},{stage:-1,text:"//"},{stage:-1,text:"//    append(value: any) LinkedList"},{stage:-1,text:"//    deleteHead() LinkedListNode"},{stage:-1,text:"//"},{stage:-1,text:"//  }"},{stage:-1,text:"//"},{stage:-1,text:"// All code above is implicitly included in your environment"},{stage:0,text:""},{stage:0,text:""},{stage:0,text:"class Queue {"},{stage:1,text:"  constructor() {"},{stage:2,text:"    this.linkedList = new LinkedList();"},{stage:1,text:"  }"},{stage:1,text:""},{stage:3,text:"  isEmpty() {"},{stage:5,text:"    return !this.linkedList.head;"},{stage:3,text:"  }"},{stage:3,text:""},{stage:3,text:"  peek() {"},{stage:6,text:"    if (!this.linkedList.head) {"},{stage:6,text:"      return null;"},{stage:6,text:"    }"},{stage:6,text:"    return this.linkedList.head.value;"},{stage:3,text:"  }"},{stage:3,text:""},{stage:4,text:"  enqueue(value) {"},{stage:5,text:"    this.linkedList.append(value);"},{stage:4,text:"  }"},{stage:4,text:""},{stage:4,text:"  dequeue() {"},{stage:7,text:"    const removedHead = this.linkedList.deleteHead();"},{stage:7,text:"    return removedHead ? removedHead.value : null;"},{stage:4,text:"  }"},{stage:4,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},22:{problemID:22,problemName:"Implement a *Queue* from scratch using an *Array*",problemText:"\nGiven a *Queue* class, implement the following methods: \n    \n - **isEmpty** (which returns a Boolean value indicating if there are any items in the queue)\n - **peek** (which returns - but does not remove - the value at the head of the queue)\n - **enqueue** (which adds a value to the end of the queue - does not return anything)\n - **dequeue** (which removes and returns the value at the head of the queue).  \n    \nBase the implementation on the given *LinkedList* base data structure.  Return `null` for **peek** and **dequeue** if the queue is empty.",testCases:[{id:1,name:"compiles",inherit:[],code:"const queue=new Queue();",evaluate:"Boolean(queue);",expected:!0},{id:2,name:"peek on an empty queue returns null",inherit:[1],code:"",evaluate:"queue.peek();",expected:null},{id:3,name:"dequeue on an empty queue returns null",inherit:[1],code:"",evaluate:"queue.dequeue();",expected:null},{id:4,name:"peek returns enqueued item",inherit:[1],code:"queue.enqueue(5);",evaluate:"queue.peek();",expected:5},{id:5,name:"peek, queue, dequeue work together properly",inherit:[1],code:"queue.enqueue(5);queue.enqueue(7);queue.dequeue();",evaluate:"queue.peek();",expected:7},{id:6,name:"peek returns enqueued item (3)",inherit:[1],code:"queue.enqueue(5);queue.enqueue(6);queue.enqueue(7);",evaluate:"queue.peek();",expected:5},{id:7,name:"dequeue multiple enqueued items",inherit:[1],code:"queue.enqueue(5);queue.enqueue(6);queue.enqueue(7);queue.dequeue();queue.dequeue();",evaluate:"queue.peek();",expected:7},{id:8,name:"isEmpty returns true for empty queue",inherit:[1],code:"",evaluate:"queue.isEmpty();",expected:!0},{id:9,name:"isEmpty returns false for queue with an item",inherit:[1],code:"queue.enqueue(5);",evaluate:"queue.isEmpty();",expected:!1}],setupCode:"",category:"Queue",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,240],solutionLines:[{stage:0,text:"class Queue {"},{stage:1,text:"  constructor() {"},{stage:2,text:"    this.items = [];"},{stage:1,text:"  }"},{stage:2,text:""},{stage:3,text:"  isEmpty() {"},{stage:5,text:"    return !this.items.length;"},{stage:3,text:"  }"},{stage:3,text:""},{stage:3,text:"  peek() {"},{stage:5,text:"    if (this.isEmpty()) {"},{stage:5,text:"      return null;"},{stage:5,text:"    }"},{stage:6,text:"    return this.items[0];"},{stage:3,text:"  }"},{stage:3,text:""},{stage:4,text:"  enqueue(value) {"},{stage:6,text:"    this.items.push(value);"},{stage:4,text:"  }"},{stage:4,text:""},{stage:4,text:"  dequeue() {"},{stage:7,text:"    if (this.isEmpty()) {"},{stage:7,text:"      return null;"},{stage:7,text:"    }"},{stage:7,text:"    return this.items.shift();"},{stage:4,text:"  }"},{stage:4,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},23:{problemID:23,problemName:"Implement a *Stack* using a *Linked List*",problemText:"Given a *Stack* class, implement the following methods: **isEmpty** (which returns a boolean value indicating if there are any values in the stack), **peek** (which returns - but does not remove - the value at the top of the stack), **push** (which adds a value to the top of the stack - does not return anything), and **pop** (which removes and returns the value at the top of the stack).  Base the implementation on the given *LinkedList* base data structure.  Return `null` for **peek** and **pop** if the stack is empty.",testCases:[{id:1,name:"compiles",inherit:[],code:"const stack=new Stack();",evaluate:"Boolean(stack);",expected:!0},{id:2,name:"peek on empty stack is null",inherit:[1],code:"",evaluate:"stack.peek();",expected:null},{id:3,name:"pop on empty stack is null",inherit:[1],code:"",evaluate:"stack.pop();",expected:null},{id:4,name:"isEmpty on empty stack is true",inherit:[1],code:"",evaluate:"stack.isEmpty();",expected:!0},{id:5,name:"isEmpty on stack with an item is false",inherit:[1],code:"stack.push(5);",evaluate:"stack.isEmpty();",expected:!1},{id:6,name:"peek on stack with an item returns that value",inherit:[1,5],code:"",evaluate:"stack.peek();",expected:5},{id:7,name:"peek on stack with two items returns correct value",inherit:[1,5],code:"stack.push(9);",evaluate:"stack.peek();",expected:9},{id:8,name:"peek does not remove items",inherit:[1,5,7],code:"",evaluate:"stack.peek();stack.peek();",expected:9},{id:9,name:"pop removes and returns correct item in stack (1)",inherit:[1,5,7],code:"",evaluate:"stack.pop();",expected:9},{id:10,name:"pop removes and returns correct item in stack (2)",inherit:[1,5,7],code:"",evaluate:"stack.pop();stack.pop();",expected:5}],setupCode:"\n  class LinkedListNode {\n    constructor(value, next = null) {\n      this.value = value;\n      this.next = next;\n    }\n  }\n  \n  class LinkedList {\n    constructor() {\n      this.head = null;\n      this.tail = null;\n    }\n    \n    prepend(value) {\n      const newNode = new LinkedListNode(value, this.head);\n      this.head = newNode;\n      if (!this.tail) {\n        this.tail = newNode;\n      }\n      return this;\n    }\n    \n    deleteHead() {\n      if (!this.head) {\n        return null;\n      }\n      const deletedHead = this.head;\n      if (this.head.next) {\n        this.head = this.head.next;\n      } else {\n        this.head = null;\n        this.tail = null;\n      }\n      return deletedHead;\n    }\n  }\n  ",category:"Stack",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,240],solutionLines:[{stage:0,text:"//"},{stage:0,text:"//  class LinkedList {"},{stage:0,text:"//"},{stage:0,text:"//    prepend(value: any) LinkedList"},{stage:0,text:"//"},{stage:0,text:"//    deleteHead() LinkedListNode"},{stage:0,text:"//"},{stage:0,text:"//  }"},{stage:0,text:"//"},{stage:0,text:"// All code above is implicitly included in your environment"},{stage:0,text:""},{stage:1,text:"class Stack {"},{stage:2,text:"  constructor() {"},{stage:2,text:"    this.linkedList = new LinkedList();"},{stage:2,text:"  }"},{stage:2,text:""},{stage:3,text:"  isEmpty() {"},{stage:5,text:"    return !this.linkedList.head;"},{stage:3,text:"  }"},{stage:3,text:""},{stage:3,text:"  peek() {"},{stage:5,text:"    if (this.isEmpty()) {"},{stage:5,text:"      return null;"},{stage:5,text:"    }"},{stage:6,text:"    return this.linkedList.head.value;"},{stage:3,text:"  }"},{stage:4,text:""},{stage:4,text:"  push(value) {"},{stage:6,text:"    this.linkedList.prepend(value);"},{stage:4,text:"  }"},{stage:4,text:""},{stage:4,text:"  pop() {"},{stage:7,text:"    const removedHead = this.linkedList.deleteHead();"},{stage:7,text:"    return removedHead ? removedHead.value : null;"},{stage:4,text:"  }"},{stage:1,text:""},{stage:1,text:"}"},{stage:1,text:""}]}},24:{problemID:24,problemName:"Implement a *Stack* using an *Array*",problemText:"Given a *Stack* class, implement the following methods: **isEmpty** (which returns a boolean indicating if there are any values in the stack), **peek** (which returns - but does not remove - the value at the top of the stack), **push** (which adds a value to the top of the stack - does not return anything), and **pop** (which removes and returns the value at the top of the stack).  Base the implementation on an *Array* data structure.  Return `null` for **peek** and **pop** if the stack is empty.",testCases:[{id:1,name:"compiles",inherit:[],code:"const stack=new Stack();",evaluate:"Boolean(stack);",expected:!0},{id:2,name:"peek on empty stack is null",inherit:[1],code:"",evaluate:"stack.peek();",expected:null},{id:3,name:"pop on empty stack is null",inherit:[1],code:"",evaluate:"stack.pop();",expected:null},{id:4,name:"isEmpty on empty stack is true",inherit:[1],code:"",evaluate:"stack.isEmpty();",expected:!0},{id:5,name:"isEmpty on stack with an item is false",inherit:[1],code:"stack.push(5);",evaluate:"stack.isEmpty();",expected:!1},{id:6,name:"peek on stack with an item returns that value",inherit:[1,5],code:"",evaluate:"stack.peek();",expected:5},{id:7,name:"peek on stack with two items returns correct value",inherit:[1,5],code:"stack.push(9);",evaluate:"stack.peek();",expected:9},{id:8,name:"peek does not remove items",inherit:[1,5,7],code:"",evaluate:"stack.peek();stack.peek();",expected:9},{id:9,name:"pop removes and returns correct item in stack (1)",inherit:[1,5,7],code:"",evaluate:"stack.pop();",expected:9},{id:10,name:"pop removes and returns correct item in stack (2)",inherit:[1,5,7],code:"",evaluate:"stack.pop();stack.pop();",expected:5}],setupCode:"",category:"Stack",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,240],solutionLines:[{stage:1,text:"class Stack {"},{stage:2,text:"  constructor() {"},{stage:2,text:"    this.items = [];"},{stage:2,text:"  }"},{stage:2,text:""},{stage:3,text:"  isEmpty() {"},{stage:5,text:"    return !this.items.length;"},{stage:3,text:"  }"},{stage:3,text:""},{stage:3,text:"  peek() {"},{stage:5,text:"    if (this.isEmpty()) {"},{stage:5,text:"      return null;"},{stage:5,text:"    }"},{stage:6,text:"    return this.items[this.items.length - 1];"},{stage:3,text:"  }"},{stage:3,text:""},{stage:4,text:"  push(value) {"},{stage:6,text:"    this.items.push(value);"},{stage:4,text:"  }"},{stage:4,text:""},{stage:4,text:"  pop() {"},{stage:7,text:"    if (this.isEmpty()) {"},{stage:7,text:"      return null;"},{stage:7,text:"    }"},{stage:7,text:"    return this.items.pop();"},{stage:4,text:"  }"},{stage:4,text:""},{stage:1,text:"}"},{stage:1,text:""}]}},25:{problemID:25,problemName:"Implement **set** in a *HashTable* class.",problemText:"Given a *HashTable* class and a *LinkedList* class, implement a **set(key, value)** method in the *HashTable* class that will add or modify a `value` in the hash table for a given `key`.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ht=new HashTable();",evaluate:"Boolean(ht);",expected:!0},{id:2,name:"adds a new value",inherit:[1],code:"ht.set('key1', 5);",evaluate:"ht.get('key1');",expected:5},{id:3,name:"updates an existing value",inherit:[1,2],code:"ht.set('key1', 7);",evaluate:"ht.get('key1');",expected:7}],setupCode:"\n  class LinkedListNode {\n    constructor(key, value, next = null) {\n      this.key = key;\n      this.value = value;\n      this.next = next;\n    }\n  }\n  class LinkedList {\n    constructor() {\n      this.head = null;\n      this.tail = null;\n    }\n    append(key, value) {\n      const newNode = new LinkedListNode(key, value);\n      if (!this.head) {\n        this.head = newNode;\n        this.tail = newNode;\n        return this;\n      }\n      this.tail.next = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    findKey(key) {\n      if (!this.head) {\n        return null;\n      }\n      let current = this.head;\n      while (current) {\n        if (current.key === key) {\n          return current;\n        }\n        current = current.next;\n      }\n      return null;\n    }\n  }\n  HashTable.prototype.hash = function(key) {\n    const hash = Array.from(key).reduce(\n      (hashAccumulator, keySymbol) => hashAccumulator + keySymbol.charCodeAt(0), 0);\n      return hash % this.buckets.length;\n  };\n  HashTable.prototype.get = function(key) {\n    const bucketLinkedList = this.buckets[this.hash(key)];\n    const node = bucketLinkedList.findKey(key);\n    return node ? node.value : undefined;\n  };\n  ",category:"Hash-Table",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:-1,text:"// class LinkedList {"},{stage:-1,text:"//   append(key: string, value: any) LinkedList"},{stage:-1,text:"//   findKey(key: string) LinkedListNode"},{stage:-1,text:"// }"},{stage:-1,text:"//"},{stage:-1,text:"// All code above is implicitly included in your environment"},{stage:0,text:""},{stage:0,text:"class HashTable {"},{stage:0,text:"  constructor(hashTableSize = 32) {"},{stage:0,text:"    this.buckets = Array(hashTableSize)"},{stage:0,text:"      .fill(null)"},{stage:0,text:"      .map(() => new LinkedList());"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED:  hash(key: string) int"},{stage:-1,text:""},{stage:1,text:"  set(key, value) {"},{stage:2,text:"    const keyHash = this.hash(key);"},{stage:2,text:"    const bucketLinkedList = this.buckets[keyHash];"},{stage:3,text:"    const node = bucketLinkedList.findKey(key);"},{stage:3,text:""},{stage:4,text:"    if (!node) {"},{stage:5,text:"      bucketLinkedList.append(key, value);"},{stage:4,text:"    } else {"},{stage:5,text:"      node.value = value;"},{stage:4,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},26:{problemID:26,problemName:"Implement **get** in a *HashTable* class.",problemText:"Given a *HashTable* class and an associated *LinkedList* class, implement a **get** method in the *HashTable* class that will retrieve a `value` from the hash table for a given `key`, or `undefined` if the `key` does not exist.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ht=new HashTable();",evaluate:"Boolean(ht);",expected:!0},{id:2,name:"get a key that doesnt exist",inherit:[1],code:"",evaluate:"ht.get('key1');",expected:void 0},{id:3,name:"get a key",inherit:[1],code:"ht.set('key1', 99);",evaluate:"ht.get('key1');",expected:99}],setupCode:"\n  class LinkedListNode {\n    constructor(key, value, next = null) {\n      this.key = key;\n      this.value = value;\n      this.next = next;\n    }\n  }\n  class LinkedList {\n    constructor() {\n      this.head = null;\n      this.tail = null;\n    }\n    append(key, value) {\n      const newNode = new LinkedListNode(key, value);\n      if (!this.head) {\n        this.head = newNode;\n        this.tail = newNode;\n        return this;\n      }\n      this.tail.next = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    findKey(key) {\n      if (!this.head) {\n        return null;\n      }\n      let current = this.head;\n      while (current) {\n        if (current.key === key) {\n          return current;\n        }\n        current = current.next;\n      }\n      return null;\n    }\n  }\n  HashTable.prototype.hash = function(key) {\n    const hash = Array.from(key).reduce(\n      (hashAccumulator, keySymbol) => hashAccumulator + keySymbol.charCodeAt(0), 0);\n      return hash % this.buckets.length;\n  };\n  HashTable.prototype.set = function(key, value) {\n    const keyHash = this.hash(key);\n    const bucketLinkedList = this.buckets[keyHash];\n    const node = bucketLinkedList.findKey(key);\n    if (!node) {\n      bucketLinkedList.append(key, value);\n    } else {\n      node.value = value;\n    }\n  };\n  ",category:"Hash-Table",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:-1,text:"// class LinkedList {"},{stage:-1,text:"//   findKey(key: string) LinkedListNode"},{stage:-1,text:"// }"},{stage:-1,text:"//"},{stage:-1,text:"// All code above is implicitly included in your environment"},{stage:0,text:""},{stage:0,text:"class HashTable {"},{stage:0,text:"  constructor(hashTableSize = 32) {"},{stage:0,text:"    this.buckets = Array(hashTableSize)"},{stage:0,text:"      .fill(null)"},{stage:0,text:"      .map(() => new LinkedList());"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED:  hash(key: string) int"},{stage:-1,text:""},{stage:1,text:"  get(key) {"},{stage:2,text:"    const bucketLinkedList = this.buckets[this.hash(key)];"},{stage:3,text:"    const node = bucketLinkedList.findKey(key);"},{stage:3,text:"    return node ? node.value : undefined;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},27:{problemID:27,problemName:"Implement **delete** in a *HashTable* class.",problemText:"Given a *HashTable* class and an associated *LinkedList* class, implement a **delete** method in the *HashTable* class that will delete the entry for a given `key`.\n  \n  The method must return the value of the deleted item, or `null` if an item matching the `key` was not found.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ht=new HashTable();",evaluate:"Boolean(ht);",expected:!0},{id:2,name:"deleting a key that does not exist returns null",inherit:[1],code:"",evaluate:"ht.delete('key1');",expected:null},{id:3,name:"deleting a key that does exist",inherit:[1],code:"ht.set('key1', 77);",evaluate:"ht.delete('key1');",expected:77}],setupCode:"\n  class LinkedListNode {\n    constructor(key, value, next = null) {\n      this.key = key;\n      this.value = value;\n      this.next = next;\n    }\n  }\n  class LinkedList {\n    constructor() {\n      this.head = null;\n      this.tail = null;\n    }\n    append(key, value) {\n      const newNode = new LinkedListNode(key, value);\n      if (!this.head) {\n        this.head = newNode;\n        this.tail = newNode;\n        return this;\n      }\n      this.tail.next = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    findKey(key) {\n      if (!this.head) {\n        return null;\n      }\n      let current = this.head;\n      while (current) {\n        if (current.key === key) {\n          return current;\n        }\n        current = current.next;\n      }\n      return null;\n    }\n    deleteKey(key) {\n      if (!this.head) {\n        return null;\n      }\n      if (key === this.head.key) {\n        const deletedHead = this.head;\n        if (this.head.next) {\n          this.head = this.head.next;\n        } else {\n          this.head = null;\n          this.tail = null;\n        }\n        return deletedHead;\n      } else if (key === this.tail.key) {\n        const deletedTail = this.tail;\n        let currentNode = this.head;\n        while (currentNode.next) {\n          if (!currentNode.next.next) {\n            currentNode.next = null;\n          } else {\n            currentNode = currentNode.next;\n          }\n        }\n        this.tail = currentNode;\n        return deletedTail;\n      } else {\n        let currentNode = this.head;\n        while (currentNode.next) {\n          if (currentNode.next.key === key) {\n            const deletedNode = currentNode.next;\n            currentNode.next = deletedNode.next;\n            return deletedNode;\n          }\n          currentNode = currentNode.next;\n        }\n        return null;\n      }\n    }\n  }\n  HashTable.prototype.hash = function(key) {\n    const hash = Array.from(key).reduce(\n      (hashAccumulator, keySymbol) => hashAccumulator + keySymbol.charCodeAt(0), 0);\n      return hash % this.buckets.length;\n  };\n  HashTable.prototype.set = function(key, value) {\n    const keyHash = this.hash(key);\n    const bucketLinkedList = this.buckets[keyHash];\n    const node = bucketLinkedList.findKey(key);\n    if (!node) {\n      bucketLinkedList.append(key, value);\n    } else {\n      node.value = value;\n    }\n  };\n  HashTable.prototype.get = function(key) {\n    const bucketLinkedList = this.buckets[this.hash(key)];\n    const node = bucketLinkedList.findKey(key);\n    return node ? node.value : undefined;\n  };\n  ",category:"Hash-Table",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,150],solutionLines:[{stage:-1,text:"// class LinkedList {"},{stage:-1,text:"//   append(key: string, value: any) LinkedList"},{stage:-1,text:"//   findKey(key: string) LinkedListNode"},{stage:-1,text:"//   deleteKey(key: string) LinkedListNode"},{stage:-1,text:"// }"},{stage:-1,text:"//"},{stage:-1,text:"// All code above is implicitly included in your environment"},{stage:0,text:""},{stage:0,text:"class HashTable {"},{stage:0,text:"  constructor(hashTableSize = 32) {"},{stage:0,text:"    this.buckets = Array(hashTableSize)"},{stage:0,text:"      .fill(null)"},{stage:0,text:"      .map(() => new LinkedList());"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED:  hash(key: string) int"},{stage:-1,text:""},{stage:1,text:"  delete(key) {"},{stage:2,text:"    const keyHash = this.hash(key);"},{stage:2,text:"    const bucketLinkedList = this.buckets[keyHash];"},{stage:3,text:"    const deletedNode = bucketLinkedList.deleteKey(key);"},{stage:4,text:"    if (deletedNode) {"},{stage:4,text:"      return deletedNode.value;"},{stage:4,text:"    }"},{stage:3,text:"    return null;"},{stage:1,text:"  }"},{stage:0,text:"}"},{stage:0,text:""}]}},28:{problemID:28,problemName:"Implement child index functions for a *MinHeap* class.",problemText:"Implement the following methods for the *MinHeap* data structure:  \n  **getLeftChildIndex** (parentIndex: integer) => integer  \n  **getRightChildIndex** (parentIndex: integer) => integer  \n  **hasLeftChild** (parentIndex: integer) => boolean  \n  **hasRightChild** (parentIndex: integer) => boolean  \n  **leftChild** (parentIndex: integer) => heap value  \n  **rightChild** (parentIndex: integer) => heap value\n",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"getLeftChildIndex - test 0",inherit:[1],code:"",evaluate:"minheap.getLeftChildIndex(0);",expected:1},{id:2,name:"getLeftChildIndex - test 1",inherit:[1],code:"",evaluate:"minheap.getLeftChildIndex(5);",expected:11},{id:3,name:"getRightChildIndex - test 0",inherit:[1],code:"",evaluate:"minheap.getRightChildIndex(0);",expected:2},{id:4,name:"getRightChildIndex - test 1",inherit:[1],code:"",evaluate:"minheap.getRightChildIndex(12);",expected:26},{id:5,name:"hasLeftChild - true",inherit:[1],code:"minheap.heapContainer.length = 10;",evaluate:"minheap.hasLeftChild(4);",expected:!0},{id:6,name:"hasLeftChild - false",inherit:[1],code:"minheap.heapContainer.length = 9;",evaluate:"minheap.hasLeftChild(4);",expected:!1},{id:7,name:"hasRightChild - true",inherit:[1],code:"minheap.heapContainer.length = 11;",evaluate:"minheap.hasRightChild(4);",expected:!0},{id:8,name:"hasRightChild - false",inherit:[1],code:"minheap.heapContainer.length = 10;",evaluate:"minheap.hasRightChild(4);",expected:!1},{id:9,name:"leftChild",inherit:[1],code:"minheap.heapContainer = [1,4,5,8,10,12,16];",evaluate:"minheap.leftChild(0);",expected:4},{id:10,name:"leftChild",inherit:[1,9],code:"",evaluate:"minheap.leftChild(2);",expected:12},{id:11,name:"rightChild",inherit:[1,9],code:"",evaluate:"minheap.rightChild(0);",expected:5},{id:12,name:"rightChild",inherit:[1,9],code:"",evaluate:"minheap.rightChild(2);",expected:16}],setupCode:"",category:c,type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,240],solutionLines:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  getLeftChildIndex(parentIndex) {"},{stage:2,text:"    return 2 * parentIndex + 1;"},{stage:1,text:"  }"},{stage:2,text:""},{stage:1,text:"  getRightChildIndex(parentIndex) {"},{stage:3,text:"    return 2 * parentIndex + 2;"},{stage:1,text:"  }"},{stage:3,text:""},{stage:1,text:"  hasLeftChild(parentIndex) {"},{stage:4,text:"    return this.getLeftChildIndex(parentIndex) < this.heapContainer.length;"},{stage:1,text:"  }"},{stage:4,text:""},{stage:1,text:"  hasRightChild(parentIndex) {"},{stage:5,text:"    return this.getRightChildIndex(parentIndex) < this.heapContainer.length;"},{stage:1,text:"  }"},{stage:5,text:""},{stage:1,text:"  leftChild(parentIndex) {"},{stage:6,text:"    return this.heapContainer[this.getLeftChildIndex(parentIndex)];"},{stage:1,text:"  }"},{stage:6,text:""},{stage:1,text:"  rightChild(parentIndex) {"},{stage:7,text:"    return this.heapContainer[this.getRightChildIndex(parentIndex)];"},{stage:1,text:"  }"},{stage:0,text:"}"},{stage:0,text:""}]}},29:{problemID:29,problemName:"Implement parent index functions for a *MinHeap* class.",problemText:"Implement the following methods for the *MinHeap* data structure:  \n  **getParentIndex** (childIndex: integer) => integer  \n  **hasParent** (childIndex: integer) => boolean  \n  **parent** (childIndex: integer) => heap value  \n",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"getParentIndex - 1",inherit:[1],code:"",evaluate:"minheap.getParentIndex(1);",expected:0},{id:3,name:"getParentIndex - 2",inherit:[1],code:"",evaluate:"minheap.getParentIndex(2);",expected:0},{id:4,name:"getParentIndex - 3",inherit:[1],code:"",evaluate:"minheap.getParentIndex(5);",expected:2},{id:5,name:"getParentIndex - 4",inherit:[1],code:"",evaluate:"minheap.getParentIndex(6);",expected:2},{id:6,name:"getParentIndex - 5",inherit:[1],code:"",evaluate:"minheap.getParentIndex(7);",expected:3},{id:7,name:"hasParent - 1",inherit:[1],code:"",evaluate:"minheap.hasParent(0);",expected:!1},{id:8,name:"hasParent - 2",inherit:[1],code:"",evaluate:"minheap.hasParent(1);",expected:!0},{id:9,name:"parent - 1",inherit:[1],code:"minheap.heapContainer = [1,4,5,8,10,12,16];",evaluate:"minheap.parent(1);",expected:1},{id:10,name:"parent - 2",inherit:[1,9],code:"",evaluate:"minheap.parent(2);",expected:1},{id:11,name:"parent - 3",inherit:[1,9],code:"",evaluate:"minheap.parent(3);",expected:4},{id:12,name:"parent - 4",inherit:[1,9],code:"",evaluate:"minheap.parent(4);",expected:4},{id:13,name:"parent - 5",inherit:[1,9],code:"",evaluate:"minheap.parent(5);",expected:5},{id:14,name:"parent - 6",inherit:[1,9],code:"",evaluate:"minheap.parent(6);",expected:5}],setupCode:"",category:c,type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,150],solutionLines:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  getParentIndex(childIndex) {"},{stage:2,text:"    return Math.floor((childIndex - 1) / 2);"},{stage:1,text:"  }"},{stage:2,text:""},{stage:1,text:"  hasParent(childIndex) {"},{stage:3,text:"    return this.getParentIndex(childIndex) >= 0;"},{stage:1,text:"  }"},{stage:3,text:""},{stage:1,text:"  parent(childIndex) {"},{stage:4,text:"    return this.heapContainer[this.getParentIndex(childIndex)];"},{stage:1,text:"  }"},{stage:4,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},30:{problemID:30,problemName:"Implement the **peek** method for a *MinHeap* class.",problemText:"Implement a **peek** method that will return the value of the first (next-up) item in a *MinHeap*.",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"null if no values in heap",inherit:[1],code:"minheap.heapContainer = [];",evaluate:"minheap.peek();",expected:null},{id:3,name:"first value - 1",inherit:[1],code:"minheap.heapContainer = [5];",evaluate:"minheap.peek();",expected:5},{id:4,name:"first value - 2",inherit:[1],code:"minheap.heapContainer = [3,7];",evaluate:"minheap.peek();",expected:3}],setupCode:"",category:c,type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  peek() {"},{stage:2,text:"    if (this.heapContainer.length === 0) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:3,text:"    return this.heapContainer[0];"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},31:{problemID:31,problemName:"Implement the **find** method for a *MinHeap* class.",problemText:"Implement a **find** method for a *MinHeap* that accepts a parameter `item` and returns an array of indices where matching items are found in the *MinHeap*.",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"empty heap",inherit:[1],code:"",evaluate:"minheap.find(5);",expected:JSON.stringify([])},{id:3,name:"one item heap, no match",inherit:[1],code:"minheap.heapContainer = [4];",evaluate:"minheap.find(5);",expected:JSON.stringify([])},{id:4,name:"one item heap, match",inherit:[1],code:"minheap.heapContainer = [4];",evaluate:"minheap.find(4);",expected:JSON.stringify([0])},{id:5,name:"multi-item heap, no match",inherit:[1],code:"minheap.heapContainer = [4,6,8,10,12];",evaluate:"minheap.find(7);",expected:JSON.stringify([])},{id:6,name:"multi-item heap, one match",inherit:[1],code:"minheap.heapContainer = [4,6,8,10,12];",evaluate:"minheap.find(8);",expected:JSON.stringify([2])},{id:7,name:"multi-item heap, multiple matches",inherit:[1],code:"minheap.heapContainer = [4,6,8,8,8,10,12];",evaluate:"minheap.find(8);",expected:JSON.stringify([2,3,4])}],setupCode:"",category:c,type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,150],solutionLines:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  find(item) {"},{stage:2,text:"    const foundItemIndices = [];"},{stage:3,text:"    for (let itemIndex = 0; itemIndex < this.heapContainer.length; itemIndex += 1) {"},{stage:4,text:"      if (item === this.heapContainer[itemIndex]) {"},{stage:4,text:"        foundItemIndices.push(itemIndex);"},{stage:4,text:"      }"},{stage:3,text:"    }"},{stage:2,text:"    return foundItemIndices;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},32:{problemID:32,problemName:"Implement **poll** for a *MinHeap* class.",problemText:"Implement a **poll** method for a *MinHeap* to remove and return the item at the top of the heap.",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"empty list",inherit:[1],code:"",evaluate:"minheap.poll();",expected:null},{id:3,name:"list, return top item",inherit:[1],code:"minheap.heapContainer = [1,2,4,6,3,5,6,10,8,7];",evaluate:"minheap.poll();",expected:1},{id:4,name:"list, correct 2nd item",inherit:[1,3],code:"minheap.poll();",evaluate:"minheap.poll();",expected:2},{id:5,name:"list, correct 3rd item",inherit:[1,3,4],code:"minheap.poll();",evaluate:"minheap.poll();",expected:3},{id:6,name:"list, correct 4th item",inherit:[1,3,4,5],code:"minheap.poll();",evaluate:"minheap.poll();",expected:4},{id:7,name:"list, correct 5th item",inherit:[1,3,4,5,6],code:"minheap.poll();",evaluate:"minheap.poll();",expected:5}],setupCode:"\n  MinHeap.prototype.getLeftChildIndex = function(parentIndex) {\n    return 2 * parentIndex + 1;\n  };\n  MinHeap.prototype.getRightChildIndex = function(parentIndex) {\n    return 2 * parentIndex + 2;\n  };\n  MinHeap.prototype.hasLeftChild = function(parentIndex) {\n    return this.getLeftChildIndex(parentIndex) < this.heapContainer.length;\n  };\n  MinHeap.prototype.hasRightChild = function(parentIndex) {\n    return this.getRightChildIndex(parentIndex) < this.heapContainer.length;\n  };\n  MinHeap.prototype.leftChild = function(parentIndex) {\n    return this.heapContainer[this.getLeftChildIndex(parentIndex)];\n  };\n  MinHeap.prototype.rightChild = function(parentIndex) {\n    return this.heapContainer[this.getRightChildIndex(parentIndex)];\n  };\n  MinHeap.prototype.heapifyDown = function (customStartIndex = 0) {\n    let currentIndex = customStartIndex;\n    let nextIndex = null;\n    while (this.hasLeftChild(currentIndex)) {\n      if (\n        this.hasRightChild(currentIndex) &&\n        this.rightChild(currentIndex) <= this.leftChild(currentIndex)\n      ) {\n        nextIndex = this.getRightChildIndex(currentIndex);\n      } else {\n        nextIndex = this.getLeftChildIndex(currentIndex);\n      }\n      if (this.heapContainer[currentIndex] <= this.heapContainer[nextIndex]) {\n        break;\n      }\n      this.swap(currentIndex, nextIndex);\n      currentIndex = nextIndex;\n    }\n  };\n  MinHeap.prototype.swap = function (indexOne, indexTwo) {\n    const tmp = this.heapContainer[indexTwo];\n    this.heapContainer[indexTwo] = this.heapContainer[indexOne];\n    this.heapContainer[indexOne] = tmp;\n  };\n  ",category:c,type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED:  heapifyDown(startIndex: int = 0)"},{stage:0,text:""},{stage:1,text:"  poll() {"},{stage:2,text:"    if (this.heapContainer.length === 0) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:3,text:""},{stage:3,text:"    if (this.heapContainer.length === 1) {"},{stage:3,text:"      return this.heapContainer.pop();"},{stage:3,text:"    }"},{stage:4,text:""},{stage:4,text:"    const item = this.heapContainer[0];"},{stage:4,text:""},{stage:5,text:"    this.heapContainer[0] = this.heapContainer.pop();"},{stage:5,text:"    this.heapifyDown();"},{stage:4,text:"    return item;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},33:{problemID:33,problemName:"Implement **add** for a *MinHeap* class.",problemText:"Implement an **add** method for a *MinHeap* to receive an `item` (integer) and add it to the heap.  The method should then return the heap.",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"add item to empty heap",inherit:[1],code:"minheap.add(5);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([5])},{id:3,name:"add 2nd item to heap",inherit:[1,2],code:"minheap.add(6);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([5,6])},{id:4,name:"add 3rd item to heap",inherit:[1,2,3],code:"minheap.add(3);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([3,6,5])},{id:5,name:"add 4th item to heap",inherit:[1,2,3,4],code:"minheap.add(8);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([3,6,5,8])},{id:6,name:"add 5th item to heap",inherit:[1,2,3,4,5],code:"minheap.add(1);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,3,5,8,6])},{id:7,name:"add 6th item to heap",inherit:[1,2,3,4,5,6],code:"minheap.add(4);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,3,4,8,6,5])},{id:8,name:"add 7th item to heap",inherit:[1,2,3,4,5,6,7],code:"minheap.add(2);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,3,2,8,6,5,4])},{id:9,name:"method should return itself",inherit:[1,2,3,4,5,6,7],code:"",evaluate:"minheap.add(2) === minheap",expected:!0}],setupCode:"\n  MinHeap.prototype.getParentIndex = function (childIndex) {\n    return Math.floor((childIndex - 1) / 2);\n  };\n  MinHeap.prototype.hasParent = function (childIndex) {\n    return this.getParentIndex(childIndex) >= 0;\n  };\n  MinHeap.prototype.parent = function (childIndex) {\n    return this.heapContainer[this.getParentIndex(childIndex)];\n  };\n  MinHeap.prototype.heapifyUp = function (customStartIndex) {\n    let currentIndex = customStartIndex || this.heapContainer.length - 1;\n    while (\n      this.hasParent(currentIndex) &&\n      this.parent(currentIndex) > this.heapContainer[currentIndex]\n    ) {\n      this.swap(currentIndex, this.getParentIndex(currentIndex));\n      currentIndex = this.getParentIndex(currentIndex);\n    }\n  };\n  MinHeap.prototype.swap = function (indexOne, indexTwo) {\n    const tmp = this.heapContainer[indexTwo];\n    this.heapContainer[indexTwo] = this.heapContainer[indexOne];\n    this.heapContainer[indexOne] = tmp;\n  };\n  ",category:c,type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED:  heapifyUp()"},{stage:0,text:""},{stage:1,text:"  add(item) {"},{stage:2,text:"    this.heapContainer.push(item);"},{stage:3,text:"    this.heapifyUp();"},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},34:{problemID:34,problemName:"Implement **remove** for a *MinHeap* class.",problemText:"Implement a **remove** method for a *MinHeap* to receive an `item` (integer) and remove all instances of that item from the heap.  The method should then return the heap.\n  \n  (note: remove duplicate items from back to front)",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"remove from empty heap, remains empty heap",inherit:[1],code:"",evaluate:"minheap.remove(5);JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([])},{id:3,name:"remove from empty heap, returns empty heap",inherit:[1],code:"",evaluate:"minheap.remove(5) === minheap;",expected:!0},{id:4,name:"remove one from one item heap, heap becomes empty",inherit:[1],code:"minheap.heapContainer = [5];minheap.remove(5);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([])},{id:5,name:"remove one from two item heap, one item remains",inherit:[1],code:"minheap.heapContainer = [5,6];minheap.remove(5);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([6])},{id:6,name:"remove value from two item heap where value is duplicated",inherit:[1],code:"minheap.heapContainer = [5,5];minheap.remove(5);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([])},{id:7,name:"complex example",inherit:[1],code:"minheap.heapContainer = [1,2,4,6,3,5,6,10,8,7];minheap.remove(5).remove(6);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,2,4,10,3,7,8])}],setupCode:"\n  MinHeap.prototype.getParentIndex = function (childIndex) {\n    return Math.floor((childIndex - 1) / 2);\n  };\n  MinHeap.prototype.hasParent = function (childIndex) {\n    return this.getParentIndex(childIndex) >= 0;\n  };\n  MinHeap.prototype.parent = function (childIndex) {\n    return this.heapContainer[this.getParentIndex(childIndex)];\n  };\n  MinHeap.prototype.getLeftChildIndex = function(parentIndex) {\n    return 2 * parentIndex + 1;\n  };\n  MinHeap.prototype.getRightChildIndex = function(parentIndex) {\n    return 2 * parentIndex + 2;\n  };\n  MinHeap.prototype.hasLeftChild = function(parentIndex) {\n    return this.getLeftChildIndex(parentIndex) < this.heapContainer.length;\n  };\n  MinHeap.prototype.hasRightChild = function(parentIndex) {\n    return this.getRightChildIndex(parentIndex) < this.heapContainer.length;\n  };\n  MinHeap.prototype.leftChild = function(parentIndex) {\n    return this.heapContainer[this.getLeftChildIndex(parentIndex)];\n  };\n  MinHeap.prototype.rightChild = function(parentIndex) {\n    return this.heapContainer[this.getRightChildIndex(parentIndex)];\n  };\n  MinHeap.prototype.find = function (item) {\n    const foundItemIndices = [];\n    for (let itemIndex = 0; itemIndex < this.heapContainer.length; itemIndex += 1) {\n      if (item === this.heapContainer[itemIndex]) {\n        foundItemIndices.push(itemIndex);\n      }\n    }\n    return foundItemIndices;\n  };\n  MinHeap.prototype.heapifyUp = function (customStartIndex) {\n    let currentIndex = customStartIndex || this.heapContainer.length - 1;\n    while (\n      this.hasParent(currentIndex) &&\n      this.parent(currentIndex) > this.heapContainer[currentIndex]\n    ) {\n      this.swap(currentIndex, this.getParentIndex(currentIndex));\n      currentIndex = this.getParentIndex(currentIndex);\n    }\n  };\n  MinHeap.prototype.heapifyDown = function (customStartIndex = 0) {\n    let currentIndex = customStartIndex;\n    let nextIndex = null;\n    while (this.hasLeftChild(currentIndex)) {\n      if (\n        this.hasRightChild(currentIndex) &&\n        this.rightChild(currentIndex) <= this.leftChild(currentIndex)\n      ) {\n        nextIndex = this.getRightChildIndex(currentIndex);\n      } else {\n        nextIndex = this.getLeftChildIndex(currentIndex);\n      }\n      if (this.heapContainer[currentIndex] <= this.heapContainer[nextIndex]) {\n        break;\n      }\n      this.swap(currentIndex, nextIndex);\n      currentIndex = nextIndex;\n    }\n  };\n  MinHeap.prototype.swap = function (indexOne, indexTwo) {\n    const tmp = this.heapContainer[indexTwo];\n    this.heapContainer[indexTwo] = this.heapContainer[indexOne];\n    this.heapContainer[indexOne] = tmp;\n  };\n  ",category:c,type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,210,270],solutionLines:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED:  heapifyUp(index: int)"},{stage:-1,text:"// IMPLEMENTED:  heapifyDown(index: int)"},{stage:-1,text:"// IMPLEMENTED:  find(item: int) []index:int"},{stage:-1,text:"// IMPLEMENTED:  parent(index: int) item:int"},{stage:-1,text:"// IMPLEMENTED:  hasLeftChild(index: int) bool"},{stage:0,text:""},{stage:1,text:"  remove(item) {"},{stage:2,text:"    const numberOfItemsToRemove = this.find(item).length;"},{stage:2,text:""},{stage:3,text:"    for (let iteration = 0; iteration < numberOfItemsToRemove; iteration += 1) {"},{stage:4,text:"      const indexToRemove = this.find(item).pop();"},{stage:4,text:"      if (indexToRemove === this.heapContainer.length - 1) {"},{stage:5,text:"        this.heapContainer.pop();"},{stage:4,text:"      } else {"},{stage:5,text:"        this.heapContainer[indexToRemove] = this.heapContainer.pop();"},{stage:5,text:"        const parentItem = this.parent(indexToRemove);"},{stage:6,text:""},{stage:6,text:"        if ("},{stage:6,text:"          this.hasLeftChild(indexToRemove) &&"},{stage:6,text:"          (!parentItem || parentItem <= this.heapContainer[indexToRemove])"},{stage:6,text:"        ) {"},{stage:7,text:"          this.heapifyDown(indexToRemove);"},{stage:6,text:"        } else {"},{stage:8,text:"          this.heapifyUp(indexToRemove);"},{stage:6,text:"        }"},{stage:4,text:"      }"},{stage:3,text:"    }"},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},35:{problemID:35,problemName:"Implement **heapifyUp** for a *MinHeap* class.",problemText:"Implement a **heapifyUp** method for a *MinHeap* to take an array item at a specified `index` (the last index in the array by default) and move it up to the correct placement in the heap.",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"heapifyUp on one item heap, remains same",inherit:[1],code:"minheap.heapContainer = [5];minheap.heapifyUp();",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([5])},{id:3,name:"heapifyUp on two item heap",inherit:[1],code:"minheap.heapContainer = [5,4];minheap.heapifyUp(1);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([4,5])},{id:4,name:"heapifyUp on three item heap",inherit:[1],code:"minheap.heapContainer = [5,6,4];minheap.heapifyUp(2);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([4,6,5])},{id:5,name:"heapifyUp on four item heap",inherit:[1],code:"minheap.heapContainer = [4,6,5,3];minheap.heapifyUp(3);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([3,4,5,6])},{id:6,name:"heapifyUp on complex heap",inherit:[1],code:"minheap.heapContainer = [2,3,5,7,4,6,7,11,9,8,1];minheap.heapifyUp(10);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,2,5,7,3,6,7,11,9,8,4])},{id:7,name:"by default, works on last item in heap",inherit:[1],code:"minheap.heapContainer = [2,3,5,7,4,6,7,11,9,8,1];minheap.heapifyUp();",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,2,5,7,3,6,7,11,9,8,4])}],setupCode:"\n  MinHeap.prototype.getParentIndex = function (childIndex) {\n    return Math.floor((childIndex - 1) / 2);\n  };\n  MinHeap.prototype.hasParent = function (childIndex) {\n    return this.getParentIndex(childIndex) >= 0;\n  };\n  MinHeap.prototype.parent = function (childIndex) {\n    return this.heapContainer[this.getParentIndex(childIndex)];\n  };\n  MinHeap.prototype.swap = function (indexOne, indexTwo) {\n    const tmp = this.heapContainer[indexTwo];\n    this.heapContainer[indexTwo] = this.heapContainer[indexOne];\n    this.heapContainer[indexOne] = tmp;\n  };\n  ",category:c,type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED:  swap(index1: int, index2: int)"},{stage:-1,text:"// IMPLEMENTED:  getParentIndex(index: int) int"},{stage:-1,text:"// IMPLEMENTED:  hasParent(index: int) bool"},{stage:-1,text:"// IMPLEMENTED:  parent(index: int) int"},{stage:0,text:""},{stage:1,text:"  heapifyUp(customStartIndex) {"},{stage:2,text:"    let currentIndex = customStartIndex || this.heapContainer.length - 1;"},{stage:2,text:""},{stage:3,text:"    while ("},{stage:3,text:"      this.hasParent(currentIndex) &&"},{stage:3,text:"      (this.parent(currentIndex) > this.heapContainer[currentIndex])"},{stage:3,text:"    ) {"},{stage:4,text:"      this.swap(currentIndex, this.getParentIndex(currentIndex));"},{stage:5,text:"      currentIndex = this.getParentIndex(currentIndex);"},{stage:3,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},36:{problemID:36,problemName:"Implement **heapifyDown** for a *MinHeap* class.",problemText:"Implement a **heapifyDown** method for a *MinHeap* to take an array item at a specified `index` (the first item in the array by default) and move it down to the correct placement in the heap.",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"one item in heap, heap is same",inherit:[1],code:"minheap.heapContainer = [1];  minheap.heapifyDown();",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1])},{id:3,name:"two items in heap, no change",inherit:[1],code:"minheap.heapContainer = [1,2];  minheap.heapifyDown();",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,2])},{id:4,name:"two items in heap, reorder",inherit:[1],code:"minheap.heapContainer = [2,1];  minheap.heapifyDown();",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,2])},{id:5,name:"five items in heap, reorder",inherit:[1],code:"minheap.heapContainer = [5,1,2,3,4];  minheap.heapifyDown();",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,3,2,5,4])},{id:6,name:"five items in heap, specific index",inherit:[1],code:"minheap.heapContainer = [1,5,2,3,4];  minheap.heapifyDown(1);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,3,2,5,4])}],setupCode:"\n  MinHeap.prototype.getLeftChildIndex = function(parentIndex) {\n    return 2 * parentIndex + 1;\n  };\n  MinHeap.prototype.getRightChildIndex = function(parentIndex) {\n    return 2 * parentIndex + 2;\n  };\n  MinHeap.prototype.hasLeftChild = function(parentIndex) {\n    return this.getLeftChildIndex(parentIndex) < this.heapContainer.length;\n  };\n  MinHeap.prototype.hasRightChild = function(parentIndex) {\n    return this.getRightChildIndex(parentIndex) < this.heapContainer.length;\n  };\n  MinHeap.prototype.leftChild = function(parentIndex) {\n    return this.heapContainer[this.getLeftChildIndex(parentIndex)];\n  };\n  MinHeap.prototype.rightChild = function(parentIndex) {\n    return this.heapContainer[this.getRightChildIndex(parentIndex)];\n  };\n  MinHeap.prototype.swap = function (indexOne, indexTwo) {\n    const tmp = this.heapContainer[indexTwo];\n    this.heapContainer[indexTwo] = this.heapContainer[indexOne];\n    this.heapContainer[indexOne] = tmp;\n  };\n  ",category:c,type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,240],solutionLines:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED:  swap(index1: int, index2: int)"},{stage:-1,text:"// IMPLEMENTED:  getLeftChildIndex(index: int) int"},{stage:-1,text:"// IMPLEMENTED:  getRightChildIndex(index: int) int"},{stage:-1,text:"// IMPLEMENTED:  hasLeftChild(index: int) bool"},{stage:-1,text:"// IMPLEMENTED:  hasRightChild(index: int) bool"},{stage:-1,text:"// IMPLEMENTED:  getLeftChildIndex(index: int) int"},{stage:-1,text:"// IMPLEMENTED:  getrightChildIndex(index: int) int"},{stage:0,text:""},{stage:1,text:"  heapifyDown(customStartIndex = 0) {"},{stage:2,text:"    let currentIndex = customStartIndex;"},{stage:2,text:"    let nextIndex = null;"},{stage:2,text:""},{stage:3,text:"    while (this.hasLeftChild(currentIndex)) {"},{stage:4,text:"      if ("},{stage:4,text:"        this.hasRightChild(currentIndex) &&"},{stage:4,text:"        this.rightChild(currentIndex) <= this.leftChild(currentIndex)"},{stage:4,text:"      ) {"},{stage:5,text:"        nextIndex = this.getRightChildIndex(currentIndex);"},{stage:4,text:"      } else {"},{stage:5,text:"        nextIndex = this.getLeftChildIndex(currentIndex);"},{stage:4,text:"      }"},{stage:5,text:""},{stage:6,text:"      if (this.heapContainer[currentIndex] <= this.heapContainer[nextIndex]) {"},{stage:6,text:"        break;"},{stage:6,text:"      }"},{stage:6,text:""},{stage:7,text:"      this.swap(currentIndex, nextIndex);"},{stage:7,text:"      currentIndex = nextIndex;"},{stage:3,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},37:{problemID:37,problemName:"Implement **insert** in a *BinarySearchTree* class.",problemText:"Write an **insert** method in a *BinarySearchTree* class that accepts a `value` (integer) and inserts it at the proper place in the tree.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"Insert value into empty tree.",inherit:[1],code:"tree.insert(5);",evaluate:"tree.root.value;",expected:5},{id:3,name:"Insert 2nd value.",inherit:[1,2],code:"tree.insert(7);",evaluate:"tree.root.right.value;",expected:7},{id:4,name:"Insert 3rd value.",inherit:[1,2,3],code:"tree.insert(6);",evaluate:"tree.root.right.left.value;",expected:6},{id:5,name:"Insert 4th value.",inherit:[1,2,3,4],code:"tree.insert(1);",evaluate:"tree.root.left.value;",expected:1},{id:6,name:"Insert 5th value.",inherit:[1,2,3,4,5],code:"tree.insert(2);",evaluate:"tree.root.left.right.value;",expected:2}],setupCode:"",category:"Binary Search Tree",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,210,240,300],solutionLines:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  insert(value) {"},{stage:2,text:"    const thisNode = new BinarySearchTreeNode(value);"},{stage:3,text:"    if (!this.root) {"},{stage:4,text:"      this.root = thisNode;"},{stage:3,text:"    } else {"},{stage:4,text:"      let currentRoot = this.root;"},{stage:4,text:"      while (true) {"},{stage:5,text:"        if (currentRoot.value > value) {"},{stage:6,text:"          if (currentRoot.left != null) {"},{stage:7,text:"            currentRoot = currentRoot.left;"},{stage:6,text:"          } else {"},{stage:7,text:"            currentRoot.left = thisNode;"},{stage:7,text:"            break;"},{stage:6,text:"          }"},{stage:5,text:"        } else if (currentRoot.value < value) {"},{stage:8,text:"          if (currentRoot.right != null) {"},{stage:9,text:"            currentRoot = currentRoot.right;"},{stage:8,text:"          } else {"},{stage:9,text:"            currentRoot.right = thisNode;"},{stage:9,text:"            break;"},{stage:8,text:"          }"},{stage:5,text:"        } else {"},{stage:9,text:"          break;"},{stage:5,text:"        }"},{stage:4,text:"      }"},{stage:3,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},38:{problemID:38,problemName:"Implement **search** in a *BinarySearchTree* class.",problemText:"Write a **search** method in a *BinarySearchTree* class that accepts a `value` (integer) and returns a boolean `true` or `false` indicating whether that integer is found within the tree.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"search an empty tree returns false",inherit:[1],code:"",evaluate:"tree.search(5);",expected:!1},{id:3,name:"search a tree finds value",inherit:[1],code:"tree.insert(5);",evaluate:"tree.search(5);",expected:!0},{id:4,name:"search a tree does not find value",inherit:[1],code:"tree.insert(5);",evaluate:"tree.search(2);",expected:!1},{id:5,name:"complex tree, found (1)",inherit:[1],code:"tree.insert(5);tree.insert(7);tree.insert(6);tree.insert(1);tree.insert(2);",evaluate:"tree.search(6);",expected:!0},{id:6,name:"complex tree, found (2)",inherit:[1,5],code:"",evaluate:"tree.search(1);",expected:!0},{id:7,name:"complex tree, not found (1)",inherit:[1,5],code:"",evaluate:"tree.search(8);",expected:!1},{id:8,name:"complex tree, not found (2)",inherit:[1,5],code:"",evaluate:"tree.search(4);",expected:!1}],setupCode:"\n  BinarySearchTree.prototype.insert = function(value) {\n    const thisNode = new BinarySearchTreeNode(value);\n    if (!this.root) {\n      this.root = thisNode;\n    } else {\n      let currentRoot = this.root;\n      while (true) {\n        if (currentRoot.value > value) {\n          if (currentRoot.left != null) {\n            currentRoot = currentRoot.left;\n          } else {\n            currentRoot.left = thisNode;\n            break;\n          }\n        } else if (currentRoot.value < value) {\n          if (currentRoot.right != null) {\n            currentRoot = currentRoot.right;\n          } else {\n            currentRoot.right = thisNode;\n            break;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n  };\n  ",category:"Binary Search Tree",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,210],solutionLines:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  search(value) {"},{stage:2,text:"    let currentRoot = this.root;"},{stage:2,text:"    let found = false;"},{stage:3,text:"    while (currentRoot) {"},{stage:4,text:"      if (currentRoot.value > value) {"},{stage:5,text:"        currentRoot = currentRoot.left;"},{stage:4,text:"      } else if (currentRoot.value < value) {"},{stage:5,text:"        currentRoot = currentRoot.right;"},{stage:4,text:"      } else {"},{stage:6,text:"        found = true;"},{stage:6,text:"        break;"},{stage:4,text:"      }"},{stage:3,text:"    }"},{stage:3,text:"    return found;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},39:{problemID:39,problemName:"Implement **delete** in a *BinarySearchTree* class.",problemText:"Write a **delete** method in a *BinarySearchTree* class that accepts an integer `value` and deletes it from a tree, while maintaining a valid Binary Search Tree structure.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"delete on empty tree, no crash",inherit:[1],code:"tree.delete(5);",evaluate:"Boolean(tree);",expected:!0},{id:3,name:"insert an item into tree.  delete it. find it.",inherit:[1],code:"tree.insert(5);tree.delete(5);",evaluate:"tree.search(5);",expected:!1},{id:4,name:"insert two items into tree.  delete one. find the other.",inherit:[1],code:"tree.insert(5);tree.insert(6);tree.delete(5);",evaluate:"tree.search(6);",expected:!0},{id:5,name:"find the deleted of task #4.",inherit:[1,4],code:"",evaluate:"tree.search(5);",expected:!1}],setupCode:"\n  BinarySearchTree.prototype.insert = function(value) {\n    const thisNode = new BinarySearchTreeNode(value);\n    if (!this.root) {\n      this.root = thisNode;\n    } else {\n      let currentRoot = this.root;\n      while (true) {\n        if (currentRoot.value > value) {\n          if (currentRoot.left != null) {\n            currentRoot = currentRoot.left;\n          } else {\n            currentRoot.left = thisNode;\n            break;\n          }\n        } else if (currentRoot.value < value) {\n          if (currentRoot.right != null) {\n            currentRoot = currentRoot.right;\n          } else {\n            currentRoot.right = thisNode;\n            break;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n  };\n  BinarySearchTree.prototype.search = function(value) {\n    let currentRoot = this.root;\n    let found = false;\n    while (currentRoot) {\n      if (currentRoot.value > value) {\n        currentRoot = currentRoot.left;\n      } else if (currentRoot.value < value) {\n        currentRoot = currentRoot.right;\n      } else {\n        found = true;\n        break;\n      }\n    }\n    return found;\n  };\n  ",category:"Binary Search Tree",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,210,240,270,330],solutionLines:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  delete(value) {"},{stage:2,text:"    this.root = deleteRecursively(this.root, value);"},{stage:2,text:""},{stage:2,text:"    function deleteRecursively(root, value) {"},{stage:3,text:"      if (!root) {"},{stage:4,text:"        return null;"},{stage:3,text:"      } else if (value < root.value) {"},{stage:4,text:"        root.left = deleteRecursively(root.left, value);"},{stage:3,text:"      } else if (value > root.value) {"},{stage:5,text:"        root.right = deleteRecursively(root.right, value);"},{stage:3,text:"      } else {"},{stage:6,text:"        if (!root.left && !root.right) {"},{stage:7,text:"          return null;"},{stage:6,text:"        } else if (!root.left) {"},{stage:7,text:"          root = root.right;"},{stage:7,text:"          return root;"},{stage:6,text:"        } else if (!root.right) {"},{stage:8,text:"          root = root.left;"},{stage:8,text:"          return root;"},{stage:6,text:"        } else {"},{stage:8,text:"          const temp = findMin(root.right);"},{stage:10,text:"          root.value = temp.value;"},{stage:10,text:"          root.right = deleteRecursively(root.right, temp.value);"},{stage:10,text:"          return root;"},{stage:6,text:"        }"},{stage:3,text:"      }"},{stage:5,text:"      return root;"},{stage:2,text:"    }"},{stage:9,text:""},{stage:8,text:"    function findMin(root) {"},{stage:9,text:"      while (root.left) {"},{stage:9,text:"        root = root.left;"},{stage:9,text:"      }"},{stage:9,text:"      return root;"},{stage:8,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},40:{problemID:40,problemName:"Implement **traversePreOrderIterative** in a *BinarySearchTree* class.",problemText:"Write a **traversePreOrderIterative** method in a *BinarySearchTree* Class that traverses a tree iteratively and runs the supplied `callback` function on each node value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"proper pre-order ranking",inherit:[1],code:"tree.insert(5);tree.insert(3);tree.insert(11);tree.insert(0);tree.insert(7);tree.insert(2);tree.traversePreOrderIterative();",evaluate:"JSON.stringify(tree.tempNodeList);",expected:JSON.stringify([5,3,0,2,11,7])}],setupCode:"\n  BinarySearchTree.prototype.tempNodeList = [];\n  BinarySearchTree.prototype.callback = function (value) {\n    BinarySearchTree.prototype.tempNodeList.push(value);\n  };\n  BinarySearchTree.prototype.clearTempNodeList = function (value) {\n    BinarySearchTree.prototype.tempNodeList = [];\n  };\n  BinarySearchTree.prototype.insert = function(value) {\n    const thisNode = new BinarySearchTreeNode(value);\n    if (!this.root) {\n      this.root = thisNode;\n    } else {\n      let currentRoot = this.root;\n      while (true) {\n        if (currentRoot.value > value) {\n          if (currentRoot.left != null) {\n            currentRoot = currentRoot.left;\n          } else {\n            currentRoot.left = thisNode;\n            break;\n          }\n        } else if (currentRoot.value < value) {\n          if (currentRoot.right != null) {\n            currentRoot = currentRoot.right;\n          } else {\n            currentRoot.right = thisNode;\n            break;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n  };\n  ",category:"Binary Search Tree",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED  callback(value)"},{stage:-1,text:""},{stage:0,text:"  traversePreOrderIterative(node = this.root, callback = this.callback) {"},{stage:1,text:"    const nodeStack = [];"},{stage:1,text:"    nodeStack.push(node);"},{stage:1,text:""},{stage:2,text:"    while (nodeStack.length) {"},{stage:3,text:"      let next = nodeStack.pop();"},{stage:3,text:"      callback(next.value);"},{stage:4,text:"      if (next.right) {"},{stage:4,text:"        nodeStack.push(next.right);"},{stage:4,text:"      }"},{stage:5,text:"      if (next.left) {"},{stage:5,text:"        nodeStack.push(next.left);"},{stage:5,text:"      }"},{stage:2,text:"    }"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},41:{problemID:41,problemName:"Implement **traversePreOrderRecursive** in a *BinarySearchTree* class.",problemText:"Write a **traversePreOrderRecursive** method in a *BinarySearchTree* class that traverses a tree recursively and runs the supplied `callback` function on each node value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"proper pre-order ranking",inherit:[1],code:"tree.insert(5);tree.insert(3);tree.insert(11);tree.insert(0);tree.insert(7);tree.insert(2);tree.traversePreOrderRecursive();",evaluate:"JSON.stringify(tree.tempNodeList);",expected:JSON.stringify([5,3,0,2,11,7])}],setupCode:"\n  BinarySearchTree.prototype.tempNodeList = [];\n  BinarySearchTree.prototype.callback = function (value) {\n    BinarySearchTree.prototype.tempNodeList.push(value);\n  };\n  BinarySearchTree.prototype.clearTempNodeList = function (value) {\n    BinarySearchTree.prototype.tempNodeList = [];\n  };\n  BinarySearchTree.prototype.insert = function(value) {\n    const thisNode = new BinarySearchTreeNode(value);\n    if (!this.root) {\n      this.root = thisNode;\n    } else {\n      let currentRoot = this.root;\n      while (true) {\n        if (currentRoot.value > value) {\n          if (currentRoot.left != null) {\n            currentRoot = currentRoot.left;\n          } else {\n            currentRoot.left = thisNode;\n            break;\n          }\n        } else if (currentRoot.value < value) {\n          if (currentRoot.right != null) {\n            currentRoot = currentRoot.right;\n          } else {\n            currentRoot.right = thisNode;\n            break;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n  };\n  ",category:"Binary Search Tree",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED  callback(value)"},{stage:-1,text:""},{stage:0,text:"  traversePreOrderRecursive(node = this.root, callback = this.callback) {"},{stage:1,text:"    if (!node) {"},{stage:1,text:"      return;"},{stage:1,text:"    }"},{stage:2,text:"    callback(node.value);"},{stage:3,text:"    this.traversePreOrderRecursive(node.left);"},{stage:3,text:"    this.traversePreOrderRecursive(node.right);"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},42:{problemID:42,problemName:"Implement **traverseInOrderIterative** in a *BinarySearchTree* class.",problemText:"Write a **traverseInOrderIterative** method in a *BinarySearchTree* class that traverses a tree iteratively and runs the supplied `callback` function on each node value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"proper in-order ranking",inherit:[1],code:"tree.insert(5);tree.insert(3);tree.insert(11);tree.insert(0);tree.insert(7);tree.insert(2);tree.traverseInOrderIterative();",evaluate:"JSON.stringify(tree.tempNodeList);",expected:JSON.stringify([0,2,3,5,7,11])}],setupCode:"\n  BinarySearchTree.prototype.tempNodeList = [];\n  BinarySearchTree.prototype.callback = function (value) {\n    BinarySearchTree.prototype.tempNodeList.push(value);\n  };\n  BinarySearchTree.prototype.clearTempNodeList = function (value) {\n    BinarySearchTree.prototype.tempNodeList = [];\n  };\n  BinarySearchTree.prototype.insert = function(value) {\n    const thisNode = new BinarySearchTreeNode(value);\n    if (!this.root) {\n      this.root = thisNode;\n    } else {\n      let currentRoot = this.root;\n      while (true) {\n        if (currentRoot.value > value) {\n          if (currentRoot.left != null) {\n            currentRoot = currentRoot.left;\n          } else {\n            currentRoot.left = thisNode;\n            break;\n          }\n        } else if (currentRoot.value < value) {\n          if (currentRoot.right != null) {\n            currentRoot = currentRoot.right;\n          } else {\n            currentRoot.right = thisNode;\n            break;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n  };\n  ",category:"Binary Search Tree",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,240],solutionLines:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED  callback(value)"},{stage:-1,text:""},{stage:0,text:"  traverseInOrderIterative(node = this.root, callback = this.callback) {"},{stage:1,text:"    let stack = [];"},{stage:1,text:"    let done = false;"},{stage:1,text:""},{stage:2,text:"    while (!done) {"},{stage:3,text:"      if (node != null) {"},{stage:4,text:"        stack.push(node);"},{stage:4,text:"        node = node.left;"},{stage:3,text:"      } else {"},{stage:5,text:"        if (stack.length) {"},{stage:6,text:"          node = stack.pop();"},{stage:6,text:"          callback(node.value);"},{stage:7,text:"          node = node.right;"},{stage:5,text:"        } else {"},{stage:7,text:"          done = true;"},{stage:5,text:"        }"},{stage:3,text:"      }"},{stage:2,text:"    }"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},43:{problemID:43,problemName:"Implement **traverseInOrderRecursive** in a *BinarySearchTree* class.",problemText:"Write a **traverseInOrderRecursive** method in a *BinarySearchTree* class that traverses a tree recursively and runs the supplied `callback` function on each node value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"proper in-order ranking",inherit:[1],code:"tree.insert(5);tree.insert(3);tree.insert(11);tree.insert(0);tree.insert(7);tree.insert(2);tree.traverseInOrderRecursive();",evaluate:"JSON.stringify(tree.tempNodeList);",expected:JSON.stringify([0,2,3,5,7,11])}],setupCode:"\n  BinarySearchTree.prototype.tempNodeList = [];\n  BinarySearchTree.prototype.callback = function (value) {\n    BinarySearchTree.prototype.tempNodeList.push(value);\n  };\n  BinarySearchTree.prototype.clearTempNodeList = function (value) {\n    BinarySearchTree.prototype.tempNodeList = [];\n  };\n  BinarySearchTree.prototype.insert = function(value) {\n    const thisNode = new BinarySearchTreeNode(value);\n    if (!this.root) {\n      this.root = thisNode;\n    } else {\n      let currentRoot = this.root;\n      while (true) {\n        if (currentRoot.value > value) {\n          if (currentRoot.left != null) {\n            currentRoot = currentRoot.left;\n          } else {\n            currentRoot.left = thisNode;\n            break;\n          }\n        } else if (currentRoot.value < value) {\n          if (currentRoot.right != null) {\n            currentRoot = currentRoot.right;\n          } else {\n            currentRoot.right = thisNode;\n            break;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n  };\n  ",category:"Binary Search Tree",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED  callback(value)"},{stage:-1,text:""},{stage:0,text:"  traverseInOrderRecursive(node = this.root, callback = this.callback) {"},{stage:1,text:"    if (!node) {"},{stage:1,text:"      return;"},{stage:1,text:"    }"},{stage:2,text:"    this.traverseInOrderRecursive(node.left);"},{stage:2,text:"    callback(node.value);"},{stage:3,text:"    this.traverseInOrderRecursive(node.right);"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},44:{problemID:44,problemName:"Implement **traversePostOrderIterative** in a *BinarySearchTree* class.",problemText:"Write a **traversePostOrderIterative** method in a *BinarySearchTree* class that traverses a tree iteratively and runs the supplied `callback` function on each node value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"proper post-order ranking",inherit:[1],code:"tree.insert(5);tree.insert(3);tree.insert(11);tree.insert(0);tree.insert(7);tree.insert(2);tree.traversePostOrderIterative();",evaluate:"JSON.stringify(tree.tempNodeList);",expected:JSON.stringify([2,0,3,7,11,5])}],setupCode:"\n  BinarySearchTree.prototype.tempNodeList = [];\n  BinarySearchTree.prototype.callback = function (value) {\n    BinarySearchTree.prototype.tempNodeList.push(value);\n  };\n  BinarySearchTree.prototype.clearTempNodeList = function (value) {\n    BinarySearchTree.prototype.tempNodeList = [];\n  };\n  BinarySearchTree.prototype.insert = function(value) {\n    const thisNode = new BinarySearchTreeNode(value);\n    if (!this.root) {\n      this.root = thisNode;\n    } else {\n      let currentRoot = this.root;\n      while (true) {\n        if (currentRoot.value > value) {\n          if (currentRoot.left != null) {\n            currentRoot = currentRoot.left;\n          } else {\n            currentRoot.left = thisNode;\n            break;\n          }\n        } else if (currentRoot.value < value) {\n          if (currentRoot.right != null) {\n            currentRoot = currentRoot.right;\n          } else {\n            currentRoot.right = thisNode;\n            break;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n  };\n  ",category:"Binary Search Tree",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,240],solutionLines:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED  callback(value)"},{stage:-1,text:""},{stage:0,text:"  traversePostOrderIterative(node = this.root, callback = this.callback) {"},{stage:1,text:"    const s1 = [];"},{stage:1,text:"    const s2 = [];"},{stage:1,text:"    s1.push(node);"},{stage:1,text:""},{stage:2,text:"    while (s1.length) {"},{stage:3,text:"      const next = s1.pop();"},{stage:3,text:"      s2.push(next);"},{stage:3,text:""},{stage:4,text:"      if (next.left) {"},{stage:4,text:"        s1.push(next.left);"},{stage:4,text:"      }"},{stage:5,text:"      if (next.right) {"},{stage:5,text:"        s1.push(next.right);"},{stage:5,text:"      }"},{stage:2,text:"    }"},{stage:6,text:"    while (s2.length) {"},{stage:7,text:"      const next = s2.pop();"},{stage:7,text:"      callback(next.value);"},{stage:6,text:"    }"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},45:{problemID:45,problemName:"Implement **traversePostOrderRecursive** in a *BinarySearchTree* class.",problemText:"Write a **traversePostOrderRecursive** method in a *BinarySearchTree* class that traverses a tree recursively and runs the supplied `callback` function on each node value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"proper post-order ranking",inherit:[1],code:"tree.insert(5);tree.insert(3);tree.insert(11);tree.insert(0);tree.insert(7);tree.insert(2);tree.traversePostOrderRecursive();",evaluate:"JSON.stringify(tree.tempNodeList);",expected:JSON.stringify([2,0,3,7,11,5])}],setupCode:"\n  BinarySearchTree.prototype.tempNodeList = [];\n  BinarySearchTree.prototype.callback = function (value) {\n    BinarySearchTree.prototype.tempNodeList.push(value);\n  };\n  BinarySearchTree.prototype.clearTempNodeList = function (value) {\n    BinarySearchTree.prototype.tempNodeList = [];\n  };\n  BinarySearchTree.prototype.insert = function(value) {\n    const thisNode = new BinarySearchTreeNode(value);\n    if (!this.root) {\n      this.root = thisNode;\n    } else {\n      let currentRoot = this.root;\n      while (true) {\n        if (currentRoot.value > value) {\n          if (currentRoot.left != null) {\n            currentRoot = currentRoot.left;\n          } else {\n            currentRoot.left = thisNode;\n            break;\n          }\n        } else if (currentRoot.value < value) {\n          if (currentRoot.right != null) {\n            currentRoot = currentRoot.right;\n          } else {\n            currentRoot.right = thisNode;\n            break;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n  };\n  ",category:"Binary Search Tree",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED  callback(value)"},{stage:-1,text:""},{stage:0,text:"  traversePostOrderRecursive(node = this.root, callback = this.callback) {"},{stage:1,text:"    if (node.left) {"},{stage:1,text:"      this.traversePostOrderRecursive(node.left);"},{stage:1,text:"    }"},{stage:2,text:"    if (node.right) {"},{stage:2,text:"      this.traversePostOrderRecursive(node.right);"},{stage:2,text:"    }"},{stage:3,text:"    callback(node.value);"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},46:{problemID:46,problemName:"Implement a **traverseLevelOrderBfs** method in a *BinarySearchTree* class.",problemText:"Write a **traverseLevelOrderBfs** method in a *BinarySearchTree* class that traverses a tree iteratively and runs the supplied `callback` function on each node value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"proper bfs",inherit:[1],code:"tree.insert(5);tree.insert(3);tree.insert(11);tree.insert(0);tree.insert(7);tree.insert(2);tree.traverseLevelOrderBfs();",evaluate:"JSON.stringify(tree.tempNodeList);",expected:JSON.stringify([5,3,11,0,7,2])}],setupCode:"\n  BinarySearchTree.prototype.tempNodeList = [];\n  BinarySearchTree.prototype.callback = function (value) {\n    BinarySearchTree.prototype.tempNodeList.push(value);\n  };\n  BinarySearchTree.prototype.clearTempNodeList = function (value) {\n    BinarySearchTree.prototype.tempNodeList = [];\n  };\n  BinarySearchTree.prototype.insert = function(value) {\n    const thisNode = new BinarySearchTreeNode(value);\n    if (!this.root) {\n      this.root = thisNode;\n    } else {\n      let currentRoot = this.root;\n      while (true) {\n        if (currentRoot.value > value) {\n          if (currentRoot.left != null) {\n            currentRoot = currentRoot.left;\n          } else {\n            currentRoot.left = thisNode;\n            break;\n          }\n        } else if (currentRoot.value < value) {\n          if (currentRoot.right != null) {\n            currentRoot = currentRoot.right;\n          } else {\n            currentRoot.right = thisNode;\n            break;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n  };\n  ",category:"Binary Search Tree",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150],solutionLines:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  traverseLevelOrderBfs(node = this.root, callback = this.callback) {"},{stage:1,text:"    const queue = [];"},{stage:1,text:"    if (!node) {"},{stage:1,text:"      return;"},{stage:1,text:"    }"},{stage:2,text:"    queue.push(node);"},{stage:2,text:"    while (queue.length) {"},{stage:3,text:"      const temp = queue.shift();"},{stage:3,text:"      callback(temp.value);"},{stage:4,text:"      if (temp.left) {"},{stage:4,text:"        queue.push(temp.left);"},{stage:4,text:"      }"},{stage:5,text:"      if (temp.right) {"},{stage:5,text:"        queue.push(temp.right);"},{stage:5,text:"      }"},{stage:2,text:"    }"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},47:{problemID:47,problemName:"Implement the **addVertex** method for a *Graph* class.",problemText:"Implement an **addVertex** method that accepts a string `vertex` key, with no return value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"add single vertex, check vertices inventory",inherit:[1],code:"graph.addVertex('A');",evaluate:"graph.vertices['A'].key;",expected:"A"},{id:3,name:"adds single vertex, check adjacency list",inherit:[1,2],code:"",evaluate:"JSON.stringify(graph.adjList['A']);",expected:JSON.stringify({})}],setupCode:"",category:"Graph",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  addVertex(key) {"},{stage:2,text:"    const vertex = new Vertex(key);"},{stage:2,text:"    this.vertices[key] = vertex;"},{stage:2,text:""},{stage:3,text:"    if (!this.adjList[key]) {"},{stage:3,text:"      this.adjList[key] = {};"},{stage:3,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},48:{problemID:48,problemName:"Implement the **addEdge** method for a *Graph* class.",problemText:"Implement an **addEdge** method that accepts a `startingVertex` key (string) and an `endingVertex` key (string) and an optional `edgeWeight` (int, defaults to 1), with no return value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"creates vertices if they do not exist - start",inherit:[1],code:"graph.addEdge('A', 'B', 2);",evaluate:"Boolean(graph.vertices['A']);",expected:!0},{id:3,name:"creates vertices if they do not exist - end",inherit:[1,2],code:"",evaluate:"Boolean(graph.vertices['B']);",expected:!0},{id:4,name:"sets the proper edge weight",inherit:[1,2],code:"",evaluate:"graph.adjList['A']['B'].weight;",expected:2},{id:5,name:"defaults to 1 if edge weight is not given",inherit:[1],code:"graph.addEdge('A', 'B');",evaluate:"graph.adjList['A']['B'].weight;",expected:1},{id:6,name:"creates reverse path if not a directed network",inherit:[],code:"const graph=new Graph(false);graph.addEdge('A', 'B', 2);",evaluate:"graph.adjList['B']['A'].weight;",expected:2}],setupCode:"\n  Graph.prototype.addVertex = function (key) {\n    const vertex = new Vertex(key);\n    this.vertices[key] = vertex;\n    if (!this.adjList[key]) {\n      this.adjList[key] = {};\n    }\n  };\n  ",category:"Graph",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED: addVertex(key: string) void"},{stage:-1,text:""},{stage:1,text:"  addEdge(startVertexKey, endVertexKey, edgeWeight = 1) {"},{stage:2,text:"    if (!this.vertices[startVertexKey]) {"},{stage:2,text:"      this.addVertex(startVertexKey);"},{stage:2,text:"    }"},{stage:2,text:""},{stage:3,text:"    if (!this.vertices[endVertexKey]) {"},{stage:3,text:"      this.addVertex(endVertexKey);"},{stage:3,text:"    }"},{stage:3,text:""},{stage:4,text:"    const edge = new Edge(edgeWeight);"},{stage:4,text:""},{stage:4,text:"    this.adjList[startVertexKey][endVertexKey] = edge;"},{stage:4,text:""},{stage:5,text:"    if (!this.isDirected) {"},{stage:5,text:"      this.adjList[endVertexKey][startVertexKey] = edge;"},{stage:5,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},49:{problemID:49,problemName:"Implement the **deleteVertex** method for a *Graph* class.",problemText:"Implement a **deleteVertex** method that accepts a `vertexKey` (string), with no return value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"add, then delete vertex",inherit:[1],code:"graph.addVertex('A');graph.deleteVertex('A');",evaluate:"Boolean(graph.vertices['A']);",expected:!1},{id:3,name:"add edge, make sure vertex is deleted from AdjList",inherit:[1],code:"graph.addEdge('A','B');graph.deleteVertex('A');",evaluate:"graph.adjList['A'] === undefined;",expected:!0},{id:4,name:"removed from reverse side of AdjList",inherit:[],code:"const graph=new Graph(false);graph.addEdge('A','B');graph.deleteVertex('A');",evaluate:"JSON.stringify(graph.adjList['B']);",expected:JSON.stringify({})}],setupCode:"\n  Graph.prototype.addVertex = function(key) {\n    const vertex = new Vertex(key);\n    this.vertices[key] = vertex;\n    if (!this.adjList[key]) {\n      this.adjList[key] = {};\n    }\n  };\n  Graph.prototype.addEdge = function(startVertexKey, endVertexKey, edgeWeight = 1) {\n    if (!this.vertices[startVertexKey]) {\n      this.addVertex(startVertexKey);\n    }\n    if (!this.vertices[endVertexKey]) {\n      this.addVertex(endVertexKey);\n    }\n    const edge = new Edge(edgeWeight);\n    this.adjList[startVertexKey][endVertexKey] = edge;\n    if (!this.isDirected) {\n      this.adjList[endVertexKey][startVertexKey] = edge;\n    }\n  };\n  ",category:"Graph",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  deleteVertex(vertexKey) {"},{stage:2,text:"    delete this.vertices[vertexKey];"},{stage:2,text:"    delete this.adjList[vertexKey];"},{stage:3,text:"    for (let key of Object.keys(this.adjList)) {"},{stage:4,text:"      for (let vk of Object.keys(this.adjList[key])) {"},{stage:5,text:"        if (vk === vertexKey) {"},{stage:5,text:"          delete this.adjList[key][vk];"},{stage:5,text:"        }"},{stage:4,text:"      }"},{stage:3,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},50:{problemID:50,problemName:"Implement the **deleteEdge** method for a *Graph* class.",problemText:"Implement a **deleteEdge** method that accepts a `startingVertex` key (string) and an `endingVertex` key (string), with no return value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"add edge, then delete. Check edge.",inherit:[1],code:"graph.addEdge('A', 'B');graph.deleteEdge('A', 'B');",evaluate:"Boolean(graph.adjList['A'] && graph.adjList['A']['B']);",expected:!1},{id:2,name:"add edge, then delete. Check reverse edge on undirected graph.",inherit:[],code:"const graph=new Graph(false);graph.addEdge('A', 'B');graph.deleteEdge('A', 'B');",evaluate:"Boolean(graph.adjList['B'] && graph.adjList['B']['A']);",expected:!1}],setupCode:"\n  Graph.prototype.addVertex = function(key) {\n    const vertex = new Vertex(key);\n    this.vertices[key] = vertex;\n    if (!this.adjList[key]) {\n      this.adjList[key] = {};\n    }\n  };\n  Graph.prototype.addEdge = function(startVertexKey, endVertexKey, edgeWeight = 1) {\n    if (!this.vertices[startVertexKey]) {\n      this.addVertex(startVertexKey);\n    }\n    if (!this.vertices[endVertexKey]) {\n      this.addVertex(endVertexKey);\n    }\n    const edge = new Edge(edgeWeight);\n    this.adjList[startVertexKey][endVertexKey] = edge;\n    if (!this.isDirected) {\n      this.adjList[endVertexKey][startVertexKey] = edge;\n    }\n  };\n  ",category:"Graph",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  deleteEdge(startVertexKey, endVertexKey) {"},{stage:2,text:"    delete this.adjList[startVertexKey][endVertexKey];"},{stage:3,text:"    if (!this.isDirected) {"},{stage:3,text:"      delete this.adjList[endVertexKey][startVertexKey];"},{stage:3,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},51:{problemID:51,problemName:"Implement a **dfs** (depth first search) method for a *Graph* class.",problemText:"Implement a **dfs** method that accepts a `startingVertex` key (string) and a `callback` function (supplied) to be run on each graph node.",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"dfs network 1",inherit:[1],code:"graph.addEdge('42', '41');graph.addEdge('42', '50');graph.addEdge('41', '10');graph.addEdge('41', '40');graph.addEdge('50', '45');graph.addEdge('50', '75');graph.dfs('42');",evaluate:"JSON.stringify(graph.tempSet);",expected:JSON.stringify(["42","41","10","40","50","45","75"])},{id:3,name:"dfs network 2",inherit:[1],code:"graph.addEdge('A', 'B');graph.addEdge('B', 'C');graph.addEdge('B', 'E');graph.addEdge('C', 'D');graph.addEdge('D', 'G');graph.addEdge('D', 'F');graph.addEdge('G', 'H');graph.addEdge('F', 'J');graph.dfs('A');",evaluate:"JSON.stringify(graph.tempSet);",expected:JSON.stringify(["A","B","C","D","G","H","F","J","E"])}],setupCode:"\n  Graph.prototype.tempSet = [];\n  Graph.prototype.callback = function(key) {\n    Graph.prototype.tempSet.push(key);\n  };\n  Graph.prototype.addVertex = function(key) {\n    const vertex = new Vertex(key);\n    this.vertices[key] = vertex;\n    if (!this.adjList[key]) {\n      this.adjList[key] = {};\n    }\n  };\n  Graph.prototype.addEdge = function(startVertexKey, endVertexKey, edgeWeight = 1) {\n    if (!this.vertices[startVertexKey]) {\n      this.addVertex(startVertexKey);\n    }\n    if (!this.vertices[endVertexKey]) {\n      this.addVertex(endVertexKey);\n    }\n\n    const edge = new Edge(edgeWeight);\n\n    this.adjList[startVertexKey][endVertexKey] = edge;\n\n    if (!this.isDirected) {\n      this.adjList[endVertexKey][startVertexKey] = edge;\n    }\n  };\n  ",category:"Graph",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,210],solutionLines:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED: callback(vertex: Vertex) void"},{stage:-1,text:""},{stage:0,text:"  dfs(startVertexKey, callback = this.callback) {"},{stage:1,text:"    const visited = {};"},{stage:1,text:""},{stage:2,text:"    const traverseDfs = vertex => {"},{stage:3,text:"      visited[vertex] = true;"},{stage:3,text:"      callback(vertex);"},{stage:4,text:"      for (let adjacent of Object.keys(this.adjList[vertex] || [])) {"},{stage:5,text:"        if (!visited[adjacent]) {"},{stage:5,text:"          traverseDfs(adjacent);"},{stage:5,text:"        }"},{stage:4,text:"      }"},{stage:2,text:"    };"},{stage:6,text:""},{stage:6,text:"    traverseDfs(startVertexKey);"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},52:{problemID:52,problemName:"Implement a **bfs** (breadth first search) method for a *Graph* class.",problemText:"Implement a **bfs** method that accepts a `startingVertex` key (string) and a `callback` function (supplied) to be run on each graph node.",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"bfs network 1",inherit:[1],code:"graph.addEdge('42', '41');graph.addEdge('42', '50');graph.addEdge('41', '10');graph.addEdge('41', '40');graph.addEdge('50', '45');graph.addEdge('50', '75');graph.bfs('42');",evaluate:"JSON.stringify(graph.tempSet);",expected:JSON.stringify(["42","41","50","10","40","45","75"])},{id:3,name:"bfs network 2",inherit:[1],code:"graph.addEdge('A', 'B');graph.addEdge('B', 'C');graph.addEdge('B', 'E');graph.addEdge('C', 'D');graph.addEdge('D', 'G');graph.addEdge('D', 'F');graph.addEdge('G', 'H');graph.addEdge('F', 'J');graph.bfs('A');",evaluate:"JSON.stringify(graph.tempSet);",expected:JSON.stringify(["A","B","C","E","D","G","F","H","J"])}],setupCode:"\n  Graph.prototype.tempSet = [];\n  Graph.prototype.callback = function(key) {\n    Graph.prototype.tempSet.push(key);\n  };\n  Graph.prototype.addVertex = function(key) {\n    const vertex = new Vertex(key);\n    this.vertices[key] = vertex;\n    if (!this.adjList[key]) {\n      this.adjList[key] = {};\n    }\n  };\n  Graph.prototype.addEdge = function(startVertexKey, endVertexKey, edgeWeight = 1) {\n    if (!this.vertices[startVertexKey]) {\n      this.addVertex(startVertexKey);\n    }\n    if (!this.vertices[endVertexKey]) {\n      this.addVertex(endVertexKey);\n    }\n\n    const edge = new Edge(edgeWeight);\n\n    this.adjList[startVertexKey][endVertexKey] = edge;\n\n    if (!this.isDirected) {\n      this.adjList[endVertexKey][startVertexKey] = edge;\n    }\n  };\n  ",category:"Graph",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED: callback(vertex: Vertex) void"},{stage:-1,text:""},{stage:0,text:"  bfs(startVertexKey, callback = this.callback) {"},{stage:1,text:"    const queue = [];"},{stage:1,text:"    const visited = {};"},{stage:1,text:"    queue.push(startVertexKey);"},{stage:1,text:""},{stage:2,text:"    while (queue.length) {"},{stage:3,text:"      const vertexKey = queue.shift();"},{stage:3,text:"      if (!visited[vertexKey]) {"},{stage:4,text:"        callback(vertexKey);"},{stage:4,text:"        visited[vertexKey] = true;"},{stage:5,text:"        for (let adjacent of Object.keys(this.adjList[vertexKey] || {})) {"},{stage:5,text:"          queue.push(adjacent);"},{stage:5,text:"        }"},{stage:3,text:"      }"},{stage:2,text:"    }"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},53:{problemID:53,problemName:"Implement the **insert** method for a *Trie* class.",problemText:"Implement an **insert** method that takes a `word` (string) as a parameter, with no return value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const trie=new Trie();",evaluate:"Boolean(trie);",expected:!0},{id:2,name:"insert word, search true",inherit:[1],code:"trie.insert('daniel');",evaluate:"trie.search('daniel');",expected:!0},{id:3,name:"insert word, search half of that word.  return false",inherit:[1,2],code:"",evaluate:"trie.search('dan');",expected:!1}],setupCode:"\n  Trie.prototype.search = function(word) {\n    let current = this.root;\n    for (let i = 0; i < word.length; i++) {\n      const ch = word.charAt(i);\n      const node = current.children[ch];\n      if (node == null) {\n        return false;\n      }\n      current = node;\n    }\n    return current.endOfWord;\n  };\n  ",category:"Trie",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,210],solutionLines:[{stage:0,text:"class TrieNode {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.children = {};"},{stage:0,text:"    this.endOfWord = false;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Trie {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = new TrieNode();"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  insert(word) {"},{stage:2,text:"    let current = this.root;"},{stage:2,text:"    for (let i = 0; i < word.length; i++) {"},{stage:3,text:"      const ch = word.charAt(i);"},{stage:3,text:"      let node = current.children[ch];"},{stage:4,text:"      if (node == null) {"},{stage:5,text:"        node = new TrieNode();"},{stage:5,text:"        current.children[ch] = node;"},{stage:4,text:"      }"},{stage:6,text:"      current = node;"},{stage:2,text:"    }"},{stage:6,text:"    current.endOfWord = true;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},54:{problemID:54,problemName:"Implement the **search** method for a *Trie* class.",problemText:"Implement a **search** method that takes in a `word` (string) and returns a boolean `true` or `false` depending on if it can be found in the Trie.",testCases:[{id:1,name:"compiles",inherit:[],code:"const trie=new Trie();",evaluate:"Boolean(trie);",expected:!0},{id:2,name:"nothing in trie should return false on search",inherit:[1],code:"",evaluate:"trie.search('');",expected:!1},{id:3,name:"insert word, search true",inherit:[1],code:"trie.insert('daniel');",evaluate:"trie.search('daniel');",expected:!0},{id:4,name:"insert word, search half of that word.  return false",inherit:[1,3],code:"",evaluate:"trie.search('dan');",expected:!1}],setupCode:"\n  Trie.prototype.insert = function(word) {\n    let current = this.root;\n    for (let i = 0; i < word.length; i++) {\n      const ch = word.charAt(i);\n      let node = current.children[ch];\n      if (node == null) {\n        node = new TrieNode();\n        current.children[ch] = node;\n      }\n      current = node;\n    }\n    current.endOfWord = true;\n  };\n  ",category:"Trie",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:0,text:"class TrieNode {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.children = {};"},{stage:0,text:"    this.endOfWord = false;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Trie {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = new TrieNode();"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  search(word) {"},{stage:2,text:"    let current = this.root;"},{stage:2,text:"    for (let i = 0; i < word.length; i++) {"},{stage:3,text:"      const ch = word.charAt(i);"},{stage:3,text:"      const node = current.children[ch];"},{stage:4,text:"      if (node == null) {"},{stage:4,text:"        return false;"},{stage:4,text:"      }"},{stage:5,text:"      current = node;"},{stage:2,text:"    }"},{stage:5,text:"    return current.endOfWord;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},55:{problemID:55,problemName:"Implement the **delete** method for a *Trie* class.",problemText:"Implement a **delete** method that takes in a `word` (string) and removes it from the Trie.",testCases:[{id:1,name:"compiles",inherit:[],code:"const trie=new Trie();",evaluate:"Boolean(trie);",expected:!0},{id:2,name:"insert, delete.  search is false.",inherit:[1],code:"trie.insert('daniel');trie.insert('david');trie.delete('daniel');",evaluate:"trie.search('daniel');",expected:!1},{id:3,name:"insert, delete.  search for non-deleted is true.",inherit:[1,2],code:"",evaluate:"trie.search('david');",expected:!0},{id:4,name:"delete remaining word.  search should be false.",inherit:[1,2],code:"trie.delete('david');",evaluate:"trie.search('david');",expected:!1}],setupCode:"\n  Trie.prototype.insert = function(word) {\n    let current = this.root;\n    for (let i = 0; i < word.length; i++) {\n      const ch = word.charAt(i);\n      let node = current.children[ch];\n      if (node == null) {\n        node = new TrieNode();\n        current.children[ch] = node;\n      }\n      current = node;\n    }\n    current.endOfWord = true;\n  };\n  Trie.prototype.search = function(word) {\n    let current = this.root;\n    for (let i = 0; i < word.length; i++) {\n      const ch = word.charAt(i);\n      const node = current.children[ch];\n      if (node == null) {\n        return false;\n      }\n      current = node;\n    }\n    return current.endOfWord;\n  };\n  ",category:"Trie",type:d,difficulty:"B",maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,210,240,300],solutionLines:[{stage:0,text:"class TrieNode {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.children = {};"},{stage:0,text:"    this.endOfWord = false;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Trie {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = new TrieNode();"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  delete(word) {"},{stage:2,text:"    deleteRecursively(this.root, word, 0);"},{stage:2,text:""},{stage:2,text:"    function deleteRecursively(current, word, index) {"},{stage:3,text:"      if (index === word.length) {"},{stage:4,text:"        if (!current.endOfWord) {"},{stage:4,text:"          return false;"},{stage:4,text:"        }"},{stage:5,text:"        current.endOfWord = false;"},{stage:5,text:"        return Object.keys(current.children).length === 0;"},{stage:3,text:"      }"},{stage:6,text:"      const ch = word.charAt(index);"},{stage:6,text:"      const node = current.children[ch];"},{stage:7,text:"      if (node == null) {"},{stage:7,text:"        return false;"},{stage:7,text:"      }"},{stage:8,text:"      const shouldDelete = deleteRecursively(node, word, index + 1);"},{stage:8,text:"      if (shouldDelete) {"},{stage:9,text:"        delete current.children[ch];"},{stage:9,text:"        return Object.keys(current.children).length === 0;"},{stage:8,text:"      }"},{stage:9,text:"      return false;"},{stage:2,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}}},h=0;Object.keys(u).forEach((function(e){var t=u[e].solution.solutionLines,n=0;t.forEach((function(e){e.stage>0&&n++})),n>h&&(h=n),u[e].effort=n}));var x=h,g=u,p=Array.from(new Set(Object.keys(u).map((function(e){return u[e].category})))).sort(),m=n(63),v=n.n(m),f=n(87),y=n(94),k=n.n(y),b=n(117),L=n(98),N=n(6),w=n(47),E=Object(w.c)({name:"game",initialState:{value:"",value2:"",results:[],revealButtonPressed:!1,isBusyTesting:!1,activeIndex:0,totalSeconds:0,isRunning:!1,open:!1,noteCode:"",tableSort:"id",sessionHistory:[]},reducers:{setValue:function(e,t){t.type;var n=t.payload;e.value=n},setValue2:function(e,t){t.type;var n=t.payload;e.value2=n},setResults:function(e,t){t.type;var n=t.payload;e.results=n},setRevealButtonPressed:function(e,t){t.type;var n=t.payload;e.revealButtonPressed=n},setIsBusyTesting:function(e,t){t.type;var n=t.payload;e.setIsBusyTesting=n},setActiveIndex:function(e,t){t.type;var n=t.payload;e.activeIndex=n},setTotalSeconds:function(e,t){t.type;var n=t.payload;e.totalSeconds=n},setOpen:function(e,t){t.type;var n=t.payload;e.open=n},setNoteCode:function(e,t){t.type;var n=t.payload;e.noteCode=n},updateTableSort:function(e,t){t.type;var n=t.payload;e.tableSort=n},setSessionHistory:function(e,t){t.type;var n=t.payload;e.sessionHistory=n},incrementTotalSeconds:function(e,t){t.type,t.payload;e.totalSeconds=e.totalSeconds+1},setIsRunning:function(e,t){t.type;var n=t.payload;e.isRunning=n},startRunningTests:function(e,t){t.type,t.payload;e.results=[],e.activeIndex=1,e.isBusyTesting=!0},concludeRunningTests:function(e,t){t.type;var n=t.payload,a=n.r,i=n.entry;e.results=a,e.isBusyTesting=!1,a.every((function(e){return e.ok}))&&!e.revealButtonPressed&&(e.isRunning=!1,e.sessionHistory.push(i),e.revealButtonPressed=!0)},clickNextToResults:function(e,t){t.type,t.payload;e.totalSeconds=0,e.isRunning=!1,e.revealButtonPressed=!1,e.activeIndex=0,e.value="",e.results=[]},clickSkipToResults:function(e,t){t.type;var n=t.payload;e.revealButtonPressed||e.sessionHistory.push({id:n,seconds:null}),e.totalSeconds=0,e.isRunning=!1,e.revealButtonPressed=!1,e.activeIndex=0,e.value="",e.results=[]},clickNext:function(e,t){t.type,t.payload;e.totalSeconds=0,e.isRunning=!0,e.revealButtonPressed=!1,e.activeIndex=0,e.value="",e.results=[]},clickSkip:function(e,t){t.type;var n=t.payload;e.revealButtonPressed||e.sessionHistory.push({id:n,seconds:null}),e.totalSeconds=0,e.isRunning=!0,e.revealButtonPressed=!1,e.activeIndex=0,e.value="",e.results=[]},revealAnswer:function(e,t){t.type;var n=t.payload,a=n.id,i=n.data;e.revealButtonPressed=!0,e.isRunning=!1,e.sessionHistory.push({id:a,seconds:null}),e.value2=i.solution.solutionLines.map((function(e){return e.text})).join("\n")}}}),C=E.actions,I=C.setValue,T=C.setValue2,S=(C.setResults,C.setRevealButtonPressed),B=(C.setIsBusyTesting,C.setActiveIndex),O=(C.setTotalSeconds,C.setOpen),R=C.setNoteCode,D=C.updateTableSort,H=C.setSessionHistory,M=C.incrementTotalSeconds,j=C.setIsRunning,A=C.startRunningTests,q=C.concludeRunningTests,P=C.clickNextToResults,V=C.clickSkipToResults,J=C.clickNext,K=C.clickSkip,G=C.revealAnswer,W=E.reducer,z=n(135),U=n(136);function F(){return new Worker(n.p+"static/js/worker.645b15e5.worker.js")}function _(e){try{var t=localStorage.getItem("personalBests"),n=JSON.parse(t);if(!n)throw new Error("Need to populate initial data.");var a=n[e.id];(!a||e.seconds<a)&&(n[e.id]=e.seconds,localStorage.setItem("personalBests",JSON.stringify(n)))}catch(s){var i={};i[e.id]=e.seconds,localStorage.setItem("personalBests",JSON.stringify(i))}}function Q(){try{var e=localStorage.getItem("personalBests"),t=JSON.parse(e);if(!t)throw new Error("Need to populate initial data.");return t}catch(a){var n={};return localStorage.setItem("personalBests",JSON.stringify(n)),n}}function Y(e,t,n,a){var i,s=";",r=Object(o.a)(t);try{var l=function(){var t=i.value,n=e.find((function(e){return e.id===t}));n?s+=n.code:console.error("Could not find testCase id: ".concat(t))};for(r.s();!(i=r.n()).done;)l()}catch(d){r.e(d)}finally{r.f()}return s+=n+a}function X(e){if(!e)return"00:00:00";var t=function(e){var t=0,n=0;e>3600&&(t=Math.floor(e/3600),e%=3600);e>60&&(n=Math.floor(e/60),e%=60);return{hours:t,minutes:n,seconds:e}}(e),n=t.hours,a=t.minutes,i=t.seconds;return"".concat(String(n).padStart(2,"0"),":").concat(String(a).padStart(2,"0"),":").concat(String(i).padStart(2,"0"))}function Z(e,t,n,a){var i=Q()[t.problemID],s="green";return i&&e>i&&(s="blue"),(e>t.solution.stages[t.solution.stages.length-1]||n)&&(s="red"),a&&(s="green"),s}var $=Object(w.b)("",function(){var e=Object(f.a)(v.a.mark((function e(t,n){var a,i,s,r;return v.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return a=n.getState(),i=a.game.value,s=g[t],n.dispatch(A()),r=s.testCases.map(function(){var e=Object(f.a)(v.a.mark((function e(t){var n,a,r,l,o,d,c,u,h;return v.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return n=new F,a=U.b(n),r="",l=a.evaluate(i+s.setupCode+Y(s.testCases,t.inherit,t.code,t.evaluate)).catch((function(e){r=e.message})),o=new Promise((function(e,t){setTimeout(t,1e3*s.maxExecutionTime,new Error("Timeout"))})).catch((function(e){r=e.message})),e.next=7,Promise.race([l,o]);case 7:return d=e.sent,a[U.a](),n.terminate(),c="",c="object"===typeof d&&null!=d?JSON.stringify(d):d,u=t.expected===c,h="string"!==typeof c?JSON.stringify(c):c,e.abrupt("return",Object(z.a)(Object(z.a)({},t),{},{actual:h,error:r,ok:u}));case 15:case"end":return e.stop()}}),e)})));return function(t){return e.apply(this,arguments)}}()),e.next=7,Promise.all(r).then((function(e){var i={id:t,seconds:a.game.totalSeconds};n.dispatch(q({r:e,entry:i})),_(i)}));case 7:case"end":return e.stop()}}),e)})));return function(t,n){return e.apply(this,arguments)}}()),ee=n(20);var te=function(){var e=Object(N.b)(),t=Object(N.c)((function(e){return e.game.value})),n=a.useRef(),i=a.useRef({}),s=Object(ee.g)().id;return i.current.id=s,a.createElement("div",{style:{padding:"1vh 1vw",width:"48.5vw",backgroundColor:"ivory",borderRadius:"5px"}},a.createElement(k.a,{ref:n,placeholder:"Enter text here...",mode:"javascript",theme:"dawn",name:"editor1",onChange:function(t){e(I(t)),n.current.editor.resize()},value:t,width:"47vw",height:"59vh",showGutter:!0,highlightActiveLine:!0,wrapEnabled:!0,setOptions:{enableBasicAutocompletion:!0,enableLiveAutocompletion:!0,showLineNumbers:!0,tabSize:2},commands:[{name:"prettier",bindKey:{win:"Ctrl-S",mac:"Cmd-S"},exec:function(t){try{var n=b.a.format(t.session.getValue(),{parser:"babel",plugins:[L.a]});e(I(n))}catch(a){console.log("There was an error in compilation.")}}},{name:"run tests",bindKey:{win:"Ctrl-M",mac:"Cmd-M"},exec:function(){var t=Object(f.a)(v.a.mark((function t(){return v.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.prev=0,t.next=3,e($(i.current.id));case 3:t.next=8;break;case 5:t.prev=5,t.t0=t.catch(0),console.log("Encountered an error when attempting to run tests.");case 8:case"end":return t.stop()}}),t,null,[[0,5]])})));return function(){return t.apply(this,arguments)}}()}]}))};var ne=function(){var e=Object(N.c)((function(e){return e.game.value2})),t=a.useRef();return a.createElement("div",{style:{padding:"1vh 1vw",width:"48.5vw",backgroundColor:"ivory",borderRadius:"5px"}},a.createElement(k.a,{ref:t,placeholder:"No suggestions...",mode:"javascript",theme:"github",width:"47vw",height:"59vh",name:"editor2",readOnly:!0,showGutter:!0,onChange:function(){t.current.editor.resize()},value:e,highlightActiveLine:!1,wrapEnabled:!0,setOptions:{showLineNumbers:!0,tabSize:2}}))},ae=n(655),ie=n(10),se=n(654),re=n(84),le=n(653),oe=n(656),de=n(139),ce=n.n(de),ue=n(157),he=n.n(ue);n(205);ce.a.registerLanguage("javascript",he.a);var xe=function(){var e=Object(N.b)(),t=Object(N.c)((function(e){return e.game.open})),n=Object(N.c)((function(e){return e.game.noteCode}));return a.createElement(le.a,{onClose:function(){return e(O(!1))},onOpen:function(){return e(O(!0))},open:t},a.createElement(le.a.Header,null,"Test Code"),a.createElement(le.a.Content,null,a.createElement("div",{style:{whiteSpace:"pre"},dangerouslySetInnerHTML:{__html:ce.a.highlight("javascript",n).value}})),a.createElement(le.a.Actions,null,a.createElement(oe.a,{style:{width:"138px"},onClick:function(){return e(O(!1))}},"Close")))};var ge=function(){var e=Object(N.b)(),t=Object(N.c)((function(e){return e.game.results})),n=Object(N.c)((function(e){return e.game.tableSort})),i=Object(ee.g)().id,s=Object(ie.a)(t).sort((function(e,t){if("id"===n)return e.id-t.id;if("fail"===n)return(e.ok?e.id+1e4:e.id)-(t.ok?t.id+1e4:t.id);if("success"===n)return(e.ok?e.id:e.id+1e4)-(t.ok?t.id:t.id+1e4);throw new Error("Invalid sort choice: ".concat(n))}));if(!s.length)return null;var r=g[i];return a.createElement("div",null,a.createElement(xe,null),a.createElement(se.a,{celled:!0,compact:"very",className:"run-results"},a.createElement(se.a.Header,null,a.createElement(se.a.Row,null,a.createElement(se.a.HeaderCell,{style:{textAlign:"center"}},"ID"),a.createElement(se.a.HeaderCell,{style:{textAlign:"center"}},"Code"),a.createElement(se.a.HeaderCell,null,"Description"),a.createElement(se.a.HeaderCell,null,"Expected"),a.createElement(se.a.HeaderCell,null,"Actual"),a.createElement(se.a.HeaderCell,null,"Error"),a.createElement(se.a.HeaderCell,{onClick:function(){if("id"===n)e(D("fail"));else if("fail"===n)e(D("success"));else{if("success"!==n)throw new Error("Invalid sort choice: ".concat(n));e(D("id"))}},style:{textAlign:"center",cursor:"pointer"}},"Status"))),a.createElement(se.a.Body,null,s.map((function(t){return a.createElement(se.a.Row,{key:t.id,style:{backgroundColor:t.ok?"rgba(0, 255, 0, 0.3)":"rgba(255, 0, 0, 0.3)"}},a.createElement(se.a.Cell,{style:{textAlign:"center"}},t.id),a.createElement(se.a.Cell,{style:{textAlign:"center"}},a.createElement(re.a,{className:"hover-note",name:"sticky note outline",role:"button",onClick:function(){var n=Y(r.testCases,t.inherit,t.code,t.evaluate),a=b.a.format(n,{parser:"babel",plugins:[L.a]});e(R(a)),e(O(!0))}})),a.createElement(se.a.Cell,null,t.name),a.createElement(se.a.Cell,null,"string"!==typeof t.expected?JSON.stringify(t.expected):t.expected),a.createElement(se.a.Cell,null,t.actual),a.createElement(se.a.Cell,null,t.error),a.createElement(se.a.Cell,{style:{textAlign:"center"}},t.ok?a.createElement(re.a,{color:"green",name:"checkmark"}):a.createElement(re.a,{color:"red",name:"checkmark"})))})))))},pe=n(42),me=n.n(pe),ve=new me.a.Converter;var fe=function(){var e=Object(N.b)(),t=Object(N.c)((function(e){return e.game.isBusyTesting})),n=Object(N.c)((function(e){return e.game.activeIndex})),i=Object(N.c)((function(e){return e.game.results})),s=Object(ee.g)().id,r=g[s];if(!r)return[];var l=i.length;return a.createElement(ae.a,{fluid:!0,raised:!0,style:{height:"calc(32vh - 40px)"}},a.createElement("p",{style:{padding:"10px 0 0 10px"}},a.createElement("span",{className:0===n?"pane-base chosen-pane":"pane-base",onClick:function(){return e(B(0))}},"Problem")," ","|"," ",a.createElement("span",{className:1===n?"pane-base chosen-pane":"pane-base",onClick:function(){return e(B(1))}},"Test Results")),a.createElement(ae.a.Content,{style:{height:"calc(32vh - 70px)",overflowY:"scroll"}},0===n?a.createElement("div",{dangerouslySetInnerHTML:{__html:ve.makeHtml(r.problemText)}}):null,1===n?t?a.createElement("p",null,"Testing in Progress..."):l?a.createElement(ge,{id:s}):a.createElement("p",null,"Tests have not been run yet for this problem."):null))};var ye=function(){var e=Object(N.b)(),t=Object(N.c)((function(e){return e.game.value})),n=Object(N.c)((function(e){return e.game.value2})),i=Object(N.c)((function(e){return e.game.revealButtonPressed})),s=Object(N.c)((function(e){return e.game.totalSeconds})),r=Object(ee.g)().id,d=g[r];return a.useEffect((function(){if(d){if(!t){var a=[];d.solution.solutionLines.forEach((function(e){0===e.stage&&a.push(e.text)})),e(I(a.join("\n")))}!i&&s>d.solution.stages[d.solution.stages.length-1]&&(e(S(!0)),e(j(!1)));var r,c=0,u=Object(o.a)(d.solution.stages.entries());try{for(u.s();!(r=u.n()).done;){var h=Object(l.a)(r.value,2),x=h[0],g=h[1];s>=g&&(c=x)}}catch(m){u.e(m)}finally{u.f()}i&&(c=1/0);var p=d.solution.solutionLines.map((function(e){return e.stage<=c?e.text:"  //"})).join("\n");JSON.stringify(n)!==JSON.stringify(p)&&e(T(p))}}),[d,i,s,t,n,e]),d?a.createElement(a.Fragment,null,a.createElement("div",{style:{padding:"1vh 1vw"}},a.createElement("div",{style:{height:"calc(35vh - 40px)",padding:"1vh 0 1vh 0vw"}},a.createElement(fe,null)),a.createElement("div",{className:"editor-area columns"},a.createElement("div",{className:"editor-area column"},a.createElement(te,null)),a.createElement("div",{className:"column"},a.createElement(ne,null))))):a.createElement("p",null,"Problem Not Found")},ke=p.map((function(e){return{name:e,isSelected:!0}})),be=Object(w.c)({name:"filter",initialState:{selections:[],results:[],showModal:!1,activeProblemText:"",categories:ke,dsChecked:!0,algChecked:!0,minEffort:0,maxEffort:x,begChecked:!0,intChecked:!0,advChecked:!0},reducers:{setSelections:function(e,t){t.type;var n=t.payload;e.selections=n},shiftSelection:function(e,t){t.type,t.payload;e.selections=e.selections.slice(1)},setResults:function(e,t){t.type;var n=t.payload;e.results=n},setShowModal:function(e,t){t.type;var n=t.payload;e.showModal=n},setActiveProblemText:function(e,t){t.type;var n=t.payload;e.activeProblemText=n},setCategories:function(e,t){t.type;var n=t.payload;e.categories=n},setDsChecked:function(e,t){t.type;var n=t.payload;e.dsChecked=n},setAlgChecked:function(e,t){t.type;var n=t.payload;e.algChecked=n},setEffortSlider:function(e,t){t.type;var n=t.payload;e.minEffort=n[0],e.maxEffort=n[1]},pressReset:function(e,t){t.type,t.payload;e.categories=ke,e.minEffort=0,e.maxEffort=x,e.dsChecked=!0,e.algChecked=!0,e.begChecked=!0,e.intChecked=!0,e.advChecked=!0},setBegChecked:function(e,t){t.type;var n=t.payload;e.begChecked=n},setIntChecked:function(e,t){t.type;var n=t.payload;e.intChecked=n},setAdvChecked:function(e,t){t.type;var n=t.payload;e.advChecked=n}}}),Le=be.actions,Ne=Le.setSelections,we=Le.setResults,Ee=Le.setShowModal,Ce=Le.setActiveProblemText,Ie=Le.setCategories,Te=Le.setDsChecked,Se=Le.setAlgChecked,Be=Le.pressReset,Oe=Le.setEffortSlider,Re=Le.shiftSelection,De=Le.setBegChecked,He=Le.setIntChecked,Me=Le.setAdvChecked,je=be.reducer,Ae=new me.a.Converter;var qe=function(){var e=Object(N.b)(),t=Object(N.c)((function(e){return e.game.sessionHistory})),n=Object(ee.f)(),i=Q();return a.createElement("div",{style:{paddingBottom:"30px"}},a.createElement("h2",{style:{margin:"0 auto",padding:"30px 0",textAlign:"center"}},"Session Statistics"),a.createElement("div",{style:{margin:"auto",height:"90px",width:"60vw",maxWidth:"500px",padding:"20px 0"}},a.createElement(oe.a,{style:{float:"left",width:"138px"},onClick:function(){n.push("/")}},"Go Home"),a.createElement(oe.a,{style:{float:"right",width:"138px"},onClick:function(){e(H([]))}},"Clear Stats")),a.createElement(se.a,{style:{margin:"auto",width:"80vw",maxWidth:"1200px",letterSpacing:"1px"}},a.createElement(se.a.Header,null,a.createElement(se.a.Row,null,a.createElement(se.a.HeaderCell,null,"ID"),a.createElement(se.a.HeaderCell,null,"Name"),a.createElement(se.a.HeaderCell,{style:{textAlign:"center"}},"Result"),a.createElement(se.a.HeaderCell,{style:{textAlign:"center"}},"Best"))),a.createElement(se.a.Body,null,t.map((function(t,n){var s=X(t.seconds),r=X(i[t.id]);return a.createElement(se.a.Row,{key:n,style:{backgroundColor:s===r?"rgba(0,255,0,0.2)":"rgba(255,0,0,0.2)"}},a.createElement(se.a.Cell,null,t.id),a.createElement(se.a.Cell,null,a.createElement("div",{style:{display:"inline"},className:"hover-link",onClick:function(){return n=g[t.id].problemText,e(Ce(n)),void e(Ee(!0));var n},dangerouslySetInnerHTML:{__html:Ae.makeHtml(g[t.id].problemName)}})),a.createElement(se.a.Cell,{style:{textAlign:"center"}},s),a.createElement(se.a.Cell,{style:{textAlign:"center"}},r))})))),t.length?null:a.createElement("p",{style:{padding:"10px",margin:"auto",width:"80vw"}},"The session history is empty."))},Pe=n(652),Ve=n(651);var Je=function(){var e,t=Object(N.b)(),n=Object(N.c)((function(e){return e.game.isBusyTesting})),i=Object(N.c)((function(e){return e.game.revealButtonPressed})),s=Object(N.c)((function(e){return e.game.results})),r=Object(N.c)((function(e){return e.game.totalSeconds})),l=Object(N.c)((function(e){return e.filter.selections})),d=Object(ee.f)(),c=Object(ee.g)().id,u=g[c],h=0,x=Object(o.a)(s);try{for(x.s();!(e=x.n()).done;){e.value.ok&&h++}}catch(f){x.e(f)}finally{x.f()}var p=(u&&u.testCases&&u.testCases.length)===h,m=Boolean(l&&l.length>0),v=s.length>0&&s.every((function(e){return e.ok}));return a.createElement(Pe.a,null,u&&c?a.createElement(Pe.a.Item,null,a.createElement(oe.a.Group,null,a.createElement(Ve.a,{content:"Home",trigger:a.createElement(oe.a,{icon:!0,onClick:function(){d.push("/")}},a.createElement(re.a,{name:"home"}))}))):null,a.createElement(Pe.a.Item,null,a.createElement("span",{style:{fontWeight:"bolder",fontSize:"20px",fontVariant:"small-caps"}},"Puzzler")),c?null:a.createElement(Pe.a.Item,null,a.createElement(oe.a.Group,null,a.createElement(Ve.a,{content:"Reset Filters",trigger:a.createElement(oe.a,{icon:!0,onClick:function(){t(Be())}},a.createElement(re.a,{name:"undo"}))}))),u&&c?a.createElement(a.Fragment,null,a.createElement(Pe.a.Item,null,a.createElement(oe.a.Group,null,a.createElement(Ve.a,{content:"Run Tests",trigger:a.createElement(oe.a,{icon:!0,onClick:function(){n||i||t($(c))},disabled:n||i},a.createElement(re.a,{name:"rocket",className:n?"animate-icon":""}))}),a.createElement(Ve.a,{content:"Proceed to Next Problem",trigger:a.createElement(oe.a,{icon:!0,onClick:function(){if(p)if(m){var e=l[0];t(J(c)),t(Re()),d.push("/".concat(e))}else t(P(c)),d.push("/sessionStats")},disabled:!p},a.createElement(re.a,{name:"step forward"}))}))),a.createElement(Pe.a.Item,null,a.createElement("span",{style:{color:Z(r,u,i,v)}},X(r)),function(e,t){return t?a.createElement("span",{style:{color:"green",fontWeight:"bold"}},"- PASSED!"):e?a.createElement("span",{style:{color:"red"}},"- Stopped"):null}(i,v)),m?null:a.createElement(Pe.a.Item,null,a.createElement("span",{style:{fontWeight:"bold",color:"orange"}},"Last Problem")),a.createElement(Pe.a.Item,null,a.createElement(oe.a.Group,null,a.createElement(Ve.a,{content:"Reveal Solution",trigger:a.createElement(oe.a,{icon:!0,onClick:function(){i||v||t(G({id:c,data:u}))},disabled:i||v},a.createElement(re.a,{name:"eye"}))}))),a.createElement(Pe.a.Item,null,a.createElement(oe.a.Group,null,a.createElement(Ve.a,{content:"Skip this Problem",trigger:a.createElement(oe.a,{icon:!0,onClick:function(){if(!v)if(m){var e=l[0];t(K(c)),t(Re()),d.push("/".concat(e))}else t(V(c)),d.push("/sessionStats")},disabled:v},a.createElement(re.a,{name:"fast forward"}))})))):null,a.createElement(Pe.a.Item,{position:"right"},a.createElement(Ve.a,{content:"See Session Stats",trigger:a.createElement(oe.a,{icon:!0,onClick:function(){c&&t(V(c)),d.push("/sessionStats")}},a.createElement(re.a,{name:"file alternate outline"}))})))},Ke=n(650),Ge=new me.a.Converter;var We=function(){var e=Object(N.b)(),t=Object(N.c)((function(e){return e.filter.selections})),n=Object(N.c)((function(e){return e.filter.results})),i=function(n){e(Ne([].concat(Object(ie.a)(t),[n])))},s=n.filter((function(e){return!t.includes(e)}));return a.createElement(ae.a,{style:{width:"100%",height:"100%"}},a.createElement(ae.a.Content,{header:"Filter Results"}),a.createElement(Ke.a,{style:{padding:"0",margin:"0"}}),a.createElement("div",{style:{overflowY:"scroll"}},a.createElement("div",{style:{padding:"1em",height:"63px"}},a.createElement("div",{style:{display:"inline",height:"36px",lineHeight:"36px",float:"left"}},"Found ",s.length," results."),a.createElement(oe.a,{onClick:function(){return function(){var e=s[Math.floor(Math.random()*s.length)];i(e)}()},disabled:Boolean(!s.length),icon:!0,labelPosition:"right",style:{display:"inline",float:"right"}},"Add Random",a.createElement(re.a,{name:"right arrow"}))),a.createElement("div",{style:{padding:"0 1em 1em 1em",clear:"both"}},a.createElement(se.a,{celled:!0,compact:"very"},a.createElement(se.a.Header,null,a.createElement(se.a.Row,null,a.createElement(se.a.HeaderCell,null,"Name"),a.createElement(se.a.HeaderCell,{style:{textAlign:"center"}},"Difficulty"),a.createElement(se.a.HeaderCell,{style:{textAlign:"center"}},"Effort"),a.createElement(se.a.HeaderCell,{style:{textAlign:"center"}},"Category"),a.createElement(se.a.HeaderCell,{style:{textAlign:"center"}},"Action"))),a.createElement(se.a.Body,null,s.length?s.map((function(n){var s=g[n],r=t.includes(s.problemID);return a.createElement(se.a.Row,{key:s.problemID,className:r?"existing-selection":""},a.createElement(se.a.Cell,null,a.createElement("div",{style:{display:"inline"},className:"hover-link",onClick:function(){return t=s.problemText,e(Ce(t)),void e(Ee(!0));var t},dangerouslySetInnerHTML:{__html:Ge.makeHtml("**".concat(s.problemID,"**:  ")+s.problemName)}})),a.createElement(se.a.Cell,{style:{textAlign:"center"}},a.createElement("span",{style:{backgroundColor:"azure",color:"black",display:"inline-block",border:"1px solid darkslategrey",borderRadius:"50%",width:"1.5em",height:"1.5em",lineHeight:"1.25em",verticalAlign:"center",boxShadow:"1px 1px 2px lightslategrey"}},s.difficulty)),a.createElement(se.a.Cell,{style:{textAlign:"center"}},s.effort),a.createElement(se.a.Cell,{style:{textAlign:"center"}},s.category),a.createElement(se.a.Cell,{style:{textAlign:"center"}},r?a.createElement(oe.a,{icon:!0,onClick:function(){return n=s.problemID,void e(Ne(t.filter((function(e){return e!==n}))));var n}},a.createElement(re.a,{className:"hover-circle-off",name:"minus"})):a.createElement(oe.a,{icon:!0,onClick:function(){return i(s.problemID)}},a.createElement(re.a,{className:"hover-circle-on",name:"add"}))))})):a.createElement(se.a.Row,{key:0},a.createElement(se.a.Cell,{colSpan:"4"},"No Results")))))))},ze=new me.a.Converter;var Ue=function(){var e=Object(ee.f)(),t=Object(ee.g)().id,n=Object(N.b)(),i=Object(N.c)((function(e){return e.filter.selections}));return a.createElement(ae.a,{style:{width:"100%",height:"100%"}},a.createElement(ae.a.Content,{header:"Selections"}),a.createElement(Ke.a,{style:{padding:"0",margin:"0"}}),a.createElement("div",{style:{overflowY:"scroll"}},a.createElement("div",{style:{padding:"1em",height:"63px"}},a.createElement(oe.a,{disabled:Boolean(!i.length),style:{float:"left"},onClick:function(){n(Ne([]))}},"Clear All"),a.createElement(oe.a,{style:{float:"right"},onClick:function(){var a=i[0];n(J(t)),n(Re()),e.push("/".concat(a))},disabled:Boolean(!i.length),primary:!0},"START")),a.createElement(Ke.a,{style:{padding:"0",margin:"0"}}),a.createElement("div",{style:{padding:"1em 1em 0 1em"}},i.length," Problem(s) Selected."),a.createElement("div",{style:{padding:"1em"}},a.createElement(se.a,{celled:!0,compact:"very"},a.createElement(se.a.Header,null,a.createElement(se.a.Row,null,a.createElement(se.a.HeaderCell,null,"Name"),a.createElement(se.a.HeaderCell,{style:{textAlign:"center"}},"Difficulty"),a.createElement(se.a.HeaderCell,{style:{textAlign:"center"}},"Effort"),a.createElement(se.a.HeaderCell,{style:{textAlign:"center"}},"Category"),a.createElement(se.a.HeaderCell,{style:{textAlign:"center"}},"Action"))),a.createElement(se.a.Body,null,i.length?i.map((function(e){var t=g[e];return a.createElement(se.a.Row,{key:t.problemID},a.createElement(se.a.Cell,null,a.createElement("div",{style:{display:"inline"},className:"hover-link",onClick:function(){return e=t.problemText,n(Ce(e)),void n(Ee(!0));var e},dangerouslySetInnerHTML:{__html:ze.makeHtml("**".concat(t.problemID,"**:  ")+t.problemName)}})),a.createElement(se.a.Cell,{style:{textAlign:"center"}},a.createElement("span",{style:{backgroundColor:"azure",color:"black",display:"inline-block",border:"1px solid darkslategrey",borderRadius:"50%",width:"1.5em",height:"1.5em",lineHeight:"1.25em",verticalAlign:"center",boxShadow:"1px 1px 2px lightslategrey"}},t.difficulty)),a.createElement(se.a.Cell,{style:{textAlign:"center"}},t.effort),a.createElement(se.a.Cell,{style:{textAlign:"center"}},t.category),a.createElement(se.a.Cell,{style:{textAlign:"center"}},a.createElement(oe.a,{icon:!0,onClick:function(){return e=t.problemID,void n(Ne(i.filter((function(t){return t!==e}))));var e}},a.createElement(re.a,{className:"hover-circle-off",name:"minus"}))))})):a.createElement(se.a.Row,{key:0},a.createElement(se.a.Cell,{colSpan:"4"},"No Selections")))))))},Fe=n(659);function _e(){var e=Object(N.b)(),t=Object(N.c)((function(e){return e.filter.categories})),n=t.every((function(e){return!0===e.isSelected})),i=t.every((function(e){return!1===e.isSelected}));return a.createElement(ae.a,{style:{width:"100%",height:"100%"}},a.createElement(ae.a.Content,{header:"Categories"}),a.createElement(Ke.a,{style:{padding:"0",margin:"0"}}),a.createElement("div",{style:{width:"100%",height:"100%",overflowY:"scroll"}},a.createElement("div",{style:{padding:"1em"}},a.createElement(Ve.a,{content:"Select All",trigger:a.createElement(oe.a,{icon:"add",disabled:n,onClick:function(){e(Ie(t.map((function(e){return{name:e.name,isSelected:!0}}))))}})}),a.createElement(Ve.a,{content:"Clear All",trigger:a.createElement(oe.a,{icon:"remove",disabled:i,onClick:function(){e(Ie(t.map((function(e){return{name:e.name,isSelected:!1}}))))}})})),a.createElement(Ke.a,{style:{padding:"0",margin:"0"}}),a.createElement("div",{style:{padding:"1em"}},t.map((function(n){return a.createElement(Fe.a,{style:{display:"block",padding:"5px 5px"},key:n.name,label:n.name,onChange:function(){!function(n){var a=t.map((function(e){return e.name===n?{name:e.name,isSelected:!e.isSelected}:e}));e(Ie(a))}(n.name)},checked:n.isSelected})})))))}var Qe=n(160),Ye=n.n(Qe);var Xe=function(){var e=Object(N.b)(),t=Object(N.c)((function(e){return e.filter.dsChecked})),n=Object(N.c)((function(e){return e.filter.algChecked})),i=Object(N.c)((function(e){return e.filter.minEffort})),s=Object(N.c)((function(e){return e.filter.maxEffort})),r=Object(N.c)((function(e){return e.filter.begChecked})),l=Object(N.c)((function(e){return e.filter.intChecked})),o=Object(N.c)((function(e){return e.filter.advChecked}));return a.createElement(ae.a,{style:{width:"100%",height:"100%",overflowY:"scroll"}},a.createElement(ae.a.Content,{header:"Options"}),a.createElement(ae.a.Content,{style:{width:"100%",height:"100%",padding:"1em 2em .5em 2em"}},a.createElement("div",{style:{display:"block",width:"100%",height:"50%"}},a.createElement("div",{style:{display:"block",width:"50%",float:"left"}},a.createElement(Fe.a,{style:{display:"block",padding:"5px 0"},label:"Beginner",onChange:function(){e(De(!r))},checked:r}),a.createElement(Fe.a,{style:{display:"block",padding:"5px 0"},label:"Intermediate",onChange:function(){e(He(!l))},checked:l}),a.createElement(Fe.a,{style:{display:"block",padding:"5px 0"},label:"Advanced",onChange:function(){e(Me(!o))},checked:o})),a.createElement("div",{style:{display:"block",width:"50%",float:"right"}},a.createElement(Fe.a,{style:{display:"block",padding:"5px 0"},label:"Data Structures",onChange:function(){e(Te(!t))},checked:t}),a.createElement(Fe.a,{style:{display:"block",padding:"5px 0"},label:"Algorithms",onChange:function(){e(Se(!n))},checked:n}))),a.createElement("div",{style:{display:"block",width:"100%",height:"50%"}},a.createElement("p",{style:{fontWeight:"bold",width:"100%",textAlign:"center"}},"Estimated Effort (lines)"),a.createElement(Ye.a,{className:"slider-view",selectedMinValue:i,selectedMaxValue:s,onSliderValuesChange:function(t,n){e(Oe([t,n]))},sliderMinValue:0,sliderMaxValue:x}))))};var Ze=function(){var e=Object(N.b)(),t=Object(N.c)((function(e){return e.filter.categories})),n=Object(N.c)((function(e){return e.filter.dsChecked})),i=Object(N.c)((function(e){return e.filter.algChecked})),s=Object(N.c)((function(e){return e.filter.minEffort})),r=Object(N.c)((function(e){return e.filter.maxEffort})),l=Object(N.c)((function(e){return e.filter.begChecked})),o=Object(N.c)((function(e){return e.filter.intChecked})),d=Object(N.c)((function(e){return e.filter.advChecked})),c=a.useCallback((function(){var a=t.filter((function(e){return e.isSelected})).map((function(e){return e.name})),c=Object.keys(g).map((function(e){return Number(e)})).filter((function(e){var t=g[String(e)];return!!a.includes(t.category)&&(!("B"===t.difficulty&&!l)&&(!("I"===t.difficulty&&!o)&&(!("A"===t.difficulty&&!d)&&(!(t.effort<s||t.effort>r)&&(!("data-structure"===t.type&&!n)&&!("algorithm"===t.type&&!i))))))}));e(we(c))}),[i,t,n,r,s,l,o,d,e]);return a.useEffect((function(){c()}),[c]),a.createElement("div",{className:"ui card",style:{width:"100%",height:"100%",overflowY:"hidden",overflowX:"hidden"}},a.createElement(ae.a.Content,null,a.createElement("div",{style:{position:"absolute",top:"0",left:"0",height:"calc(48vh - 40px)",width:"18vw"}},a.createElement(_e,{categories:t})),a.createElement("div",{style:{position:"absolute",top:"0",left:"19vw",height:"calc(48vh - 40px)",width:"36vw"}},a.createElement(Xe,null))))};function $e(){return a.createElement(a.Fragment,null,a.createElement("div",{style:{position:"absolute",top:"calc(40px + 3vh)",left:"2vw",height:"calc(48vh - 40px)",width:"55vw"}},a.createElement(Ze,null)),a.createElement("div",{style:{border:"1px solid yellow",position:"absolute",top:"calc(40px + 3vh)",left:"58vw",height:"calc(94vh - 40px)",width:"40vw"}},a.createElement(Ue,null)),a.createElement("div",{style:{position:"absolute",top:"52vh",left:"2vw",height:"45vh",width:"55vw"}},a.createElement(We,null)))}var et=new me.a.Converter;var tt=function(){var e=Object(N.b)(),t=Object(N.c)((function(e){return e.game.showModal})),n=Object(N.c)((function(e){return e.game.activeProblemText}));return a.createElement(le.a,{onClose:function(){return e(Ee(!1))},onOpen:function(){return e(Ee(!0))},open:t},a.createElement(le.a.Header,null,"Problem Text"),a.createElement(le.a.Content,null,a.createElement("div",{dangerouslySetInnerHTML:{__html:et.makeHtml(n)}})),a.createElement(le.a.Actions,null,a.createElement(oe.a,{style:{width:"138px"},onClick:function(){return e(Ee(!1))}},"Close")))},nt=null;var at=function(){var e=Object(N.b)(),t=Object(N.c)((function(e){return e.game.isRunning}));return a.useEffect((function(){t?nt=window.setInterval((function(){e(M())}),1e3):nt&&window.clearInterval(nt)}),[t,e]),a.createElement(a.Fragment,null,a.createElement(tt,null),a.createElement(ee.c,null,a.createElement(ee.a,{exact:!0,path:"/"},a.createElement(Je,null),a.createElement($e,null)),a.createElement(ee.a,{exact:!0,path:"/sessionStats",children:a.createElement(qe,null)}),a.createElement(ee.a,{exact:!0,path:"/:id"},a.createElement(Je,null),a.createElement(ye,null))))},it=(n(85),n(210),n(211),n(212),n(213),n(214),n(629),n(630),n(40)),st=n(161),rt=n.n(st),lt=n(162),ot=n(51),dt=n(25),ct=Object(dt.c)({game:W,filter:je}),ut={key:"root",version:1,storage:rt.a},ht=Object(ot.g)(ut,ct),xt=Object(w.a)({reducer:ht,middleware:Object(w.d)({serializableCheck:{ignoredActions:[ot.a,ot.f,ot.b,ot.c,ot.d,ot.e]}})}),gt=Object(ot.h)(xt);r.a.render(i.a.createElement(N.a,{store:xt},i.a.createElement(lt.a,{loading:null,persistor:gt},i.a.createElement(it.a,null,i.a.createElement(at,null)))),document.getElementById("root"))}},[[172,1,2]]]);
//# sourceMappingURL=main.43ff2490.chunk.js.map