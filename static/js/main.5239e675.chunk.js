(this.webpackJsonppuzzler=this.webpackJsonppuzzler||[]).push([[0],{172:function(e,t,a){e.exports=a(633)},630:function(e,t,a){},633:function(e,t,a){"use strict";a.r(t);var n=a(0),s=a.n(n),i=a(46),r=a.n(i),l=a(14),o=a(8),d="data-structure",c="Beginner",h="Intermediate",u="Advanced",x="Heap",g="Graph",p={problemID:1,problemName:"Implement **prepend** in a *LinkedList* class.",problemText:"Write a **prepend** method in a *LinkedList* class that accepts an arbitrary `value` parameter, creates a new Node, and inserts it at the front of the list.  The method should return the original list.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"empty list, head value",inherit:[1],code:"ll.prepend(5);",evaluate:"ll.head.value;",expected:5},{id:3,name:"empty list, tail value",inherit:[1],code:"ll.prepend(6);",evaluate:"ll.tail.value;",expected:6},{id:4,name:"insert two nodes",inherit:[1,2],code:"ll.prepend(7);",evaluate:"ll.tail.value === 5 && ll.head.value === 7;",expected:!0},{id:5,name:"returns itself",inherit:[1,2],code:"",evaluate:"ll.prepend(10) === ll;",expected:!0}],setupCode:"",category:"Linked List",type:d,difficulty:c,maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  prepend(value) {"},{stage:2,text:"    const newNode = new LinkedListNode(value, this.head);"},{stage:2,text:"    this.head = newNode;"},{stage:2,text:""},{stage:3,text:"    if (!this.tail) {"},{stage:3,text:"      this.tail = newNode;"},{stage:3,text:"    }"},{stage:2,text:""},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:"}"},{stage:0,text:""}]}},m={problemID:2,problemName:"Implement **append** in a *LinkedList* class.",problemText:"Write an **append** method in a *LinkedList* class that accepts an arbitrary `value` parameter, creates a new Node, and inserts it at the end of the list.  The method should return the original list.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"append one node, check head",inherit:[1],code:"ll.append(5);",evaluate:"ll.head.value;",expected:5},{id:3,name:"append one node, check tail",inherit:[1,2],code:"",evaluate:"ll.tail.value;",expected:5},{id:4,name:"append two nodes, check head",inherit:[1,2],code:"ll.append(7);",evaluate:"ll.head.value;",expected:5},{id:5,name:"append two nodes, check tail",inherit:[1,2,4],code:"",evaluate:"ll.tail.value;",expected:7},{id:6,name:"returns itself",inherit:[1,2],code:"",evaluate:"ll.append(10) === ll;",expected:!0}],setupCode:"",category:"Linked List",type:d,difficulty:c,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  append(value) {"},{stage:2,text:"    const newNode = new LinkedListNode(value);"},{stage:2,text:""},{stage:3,text:"    if (!this.head) {"},{stage:4,text:"      this.head = newNode;"},{stage:4,text:"      this.tail = newNode;"},{stage:4,text:"      return this;"},{stage:3,text:"    }"},{stage:3,text:""},{stage:5,text:"    this.tail.next = newNode;"},{stage:5,text:"    this.tail = newNode;"},{stage:5,text:""},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:"}"},{stage:0,text:""}]}},y={problemID:3,problemName:"Implement **delete** in a *LinkedList* class.",problemText:"Write a **delete** method in a *LinkedList* class that accepts an arbitrary `value` parameter and removes all nodes that match that value.  The method should return the last node deleted (or `null` if no match found).",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"delete head return value",inherit:[1],code:"ll.append(5);ll.append(4);ll.append(7);ll.append(8);",evaluate:"ll.delete(5).value;",expected:5},{id:3,name:"delete tail return value",inherit:[1,2],code:"",evaluate:"ll.delete(8).value;",expected:8},{id:4,name:"delete head resets head",inherit:[1,2],code:"",evaluate:"ll.delete(5);ll.head.value;",expected:4},{id:5,name:"delete tail resets tail",inherit:[1,2],code:"",evaluate:"ll.delete(8);ll.tail.value;",expected:7},{id:6,name:"delete second item, head points to correct next",inherit:[1,2],code:"",evaluate:"ll.delete(4);ll.head.next.value;",expected:7}],setupCode:"\n  LinkedList.prototype.append = function (value) {\n    const newNode = new LinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    this.tail = newNode;\n    return this;\n  };",category:"Linked List",type:d,difficulty:u,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,210,270],solutionLines:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  delete(value) {"},{stage:2,text:"    if (!this.head) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:2,text:""},{stage:3,text:"    let deletedNode = null;"},{stage:3,text:""},{stage:4,text:"    while (this.head && this.head.value === value) {"},{stage:4,text:"      deletedNode = this.head;"},{stage:4,text:"      this.head = this.head.next;"},{stage:4,text:"    }"},{stage:4,text:""},{stage:5,text:"    let currentNode = this.head;"},{stage:5,text:""},{stage:5,text:"    if (currentNode !== null) {"},{stage:6,text:"      while (currentNode.next) {"},{stage:6,text:"        if (currentNode.next.value === value) {"},{stage:7,text:"          deletedNode = currentNode.next;"},{stage:7,text:"          currentNode.next = currentNode.next.next;"},{stage:7,text:"        } else {"},{stage:7,text:"          currentNode = currentNode.next;"},{stage:6,text:"        }"},{stage:6,text:"      }"},{stage:5,text:"    }"},{stage:5,text:""},{stage:8,text:"    if (this.tail.value === value) {"},{stage:8,text:"      this.tail = currentNode;"},{stage:8,text:"    }"},{stage:3,text:""},{stage:2,text:"    return deletedNode;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},f={problemID:4,problemName:"Implement **find** in a *LinkedList* class.",problemText:"Write a **find** method in a *LinkedList* class that accepts an arbitrary `value` parameter and returns the first node that matches that value, or `null` if no matching value was found.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"find head value",inherit:[1],code:"ll.append(5);ll.append(4);ll.append(7);ll.append(8);",evaluate:"ll.find(5).value;",expected:5},{id:3,name:"find tail value",inherit:[1,2],code:"",evaluate:"ll.find(8).value;",expected:8},{id:4,name:"find a middle value",inherit:[1,2],code:"",evaluate:"ll.find(7).value;",expected:7},{id:5,name:"return null for non-existent value",inherit:[1,2],code:"",evaluate:"ll.find(17);",expected:null},{id:6,name:"return null when empty list",inherit:[1],code:"",evaluate:"ll.find(27);",expected:null}],setupCode:"\n  LinkedList.prototype.append = function (value) {\n    const newNode = new LinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    this.tail = newNode;\n    return this;\n  };",category:"Linked List",type:d,difficulty:c,maxExecutionTime:2,solution:{stages:[0,30,60,90,150],solutionLines:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  find(value) {"},{stage:2,text:"    let currentNode = this.head;"},{stage:2,text:""},{stage:3,text:"    while (currentNode) {"},{stage:4,text:"      if (currentNode.value === value) {"},{stage:4,text:"        return currentNode;"},{stage:4,text:"      }"},{stage:4,text:"      currentNode = currentNode.next;"},{stage:3,text:"    }"},{stage:3,text:""},{stage:2,text:"    return null;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},v={problemID:5,problemName:"Implement **deleteTail** in a *LinkedList* class.",problemText:"Write a **deleteTail** method in a *LinkedList* class that will remove the last node (the tail) of a list (if it exists, else null) and return it.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"delete tail and find return value",inherit:[1],code:"ll.append(5);ll.append(4);ll.append(7);ll.append(8);",evaluate:"ll.deleteTail().value;",expected:8},{id:3,name:"properly resets so following tail element can be deleted",inherit:[1,2],code:"",evaluate:"ll.deleteTail();ll.deleteTail().value;",expected:7},{id:4,name:"deleting tail of an empty list returns null",inherit:[1],code:"",evaluate:"ll.deleteTail();",expected:null}],setupCode:"\n  LinkedList.prototype.append = function (value) {\n    const newNode = new LinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    this.tail = newNode;\n    return this;\n  };",category:"Linked List",type:d,difficulty:h,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,240],solutionLines:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  deleteTail() {"},{stage:2,text:"    const deletedTail = this.tail;"},{stage:3,text:""},{stage:3,text:"    if (this.head === this.tail) {"},{stage:4,text:"      this.head = null;"},{stage:4,text:"      this.tail = null;"},{stage:4,text:"      return deletedTail;"},{stage:3,text:"    }"},{stage:3,text:""},{stage:5,text:"    let currentNode = this.head;"},{stage:5,text:"    while (currentNode.next) {"},{stage:6,text:"      if (!currentNode.next.next) {"},{stage:7,text:"        currentNode.next = null;"},{stage:6,text:"      } else {"},{stage:7,text:"        currentNode = currentNode.next;"},{stage:6,text:"      }"},{stage:5,text:"    }"},{stage:6,text:""},{stage:6,text:"    this.tail = currentNode;"},{stage:6,text:""},{stage:2,text:"    return deletedTail;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},k={problemID:6,problemName:"Implement **deleteHead** in a *LinkedList* class.",problemText:"Write a **deleteHead** method in a *LinkedList* class that will remove the first node (the head) of a list (if it exists, else null) and return it.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"delete head and find return value",inherit:[1],code:"ll.append(5);ll.append(4);ll.append(7);ll.append(8);",evaluate:"ll.deleteHead().value;",expected:5},{id:3,name:"delete head, properly set next head, delete and find return value",inherit:[1,2],code:"",evaluate:"ll.deleteHead();ll.deleteHead().value;",expected:4},{id:4,name:"delete head from empty list returns null",inherit:[1],code:"",evaluate:"ll.deleteHead();",expected:null}],setupCode:"\n  LinkedList.prototype.append = function (value) {\n    const newNode = new LinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    this.tail = newNode;\n    return this;\n  };",category:"Linked List",type:d,difficulty:c,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,210],solutionLines:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  deleteHead() {"},{stage:2,text:"    if (!this.head) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:3,text:""},{stage:3,text:"    const deletedHead = this.head;"},{stage:3,text:""},{stage:4,text:"    if (this.head.next) {"},{stage:5,text:"      this.head = this.head.next;"},{stage:4,text:"    } else {"},{stage:6,text:"      this.head = null;"},{stage:6,text:"      this.tail = null;"},{stage:4,text:"    }"},{stage:3,text:""},{stage:3,text:"    return deletedHead;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},b={problemID:7,problemName:"Implement **fromArray** in a *LinkedList* class.",problemText:"Given a *LinkedList* class with an **append** method, create a **fromArray** method that will take in an array of `values` as a parameter and return a *LinkedList*.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"converts array to linked list (and back)",inherit:[1],code:"ll.fromArray([1,2,3,4,5]);",evaluate:"ll.toArray()",expected:JSON.stringify([1,2,3,4,5])},{id:3,name:"double check values by stepping through (head)",inherit:[1,2],code:"",evaluate:"ll.head.value",expected:1},{id:4,name:"double check values by stepping through (tail)",inherit:[1,2],code:"",evaluate:"ll.tail.value",expected:5},{id:5,name:"empty fromArray results in empty list",inherit:[1],code:"ll.fromArray([]);",evaluate:"ll.head == null;",expected:!0},{id:6,name:"empty fromArray results in empty list",inherit:[1,5],code:"",evaluate:"ll.toArray();",expected:JSON.stringify([])},{id:7,name:"double check values by stepping through (head next)",inherit:[1,2],code:"",evaluate:"ll.head.next.value",expected:2}],setupCode:"\n  LinkedList.prototype.append = function (value) {\n    const newNode = new LinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    this.tail = newNode;\n    return this;\n  };\n  LinkedList.prototype.toArray = function () {\n    const values = [];\n    let currentNode = this.head;\n    while (currentNode) {\n      values.push(currentNode.value);\n      currentNode = currentNode.next;\n    }\n    return values;\n  };\n  ",category:"Linked List",type:d,difficulty:c,maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED: append(value: any) LinkedList"},{stage:-1,text:""},{stage:1,text:"  fromArray(values) {"},{stage:3,text:"    values.forEach(value => this.append(value));"},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},L={problemID:8,problemName:"Implement **toArray** in a *LinkedList* class.",problemText:"Provide a class method **toArray** that converts the value property of each *LinkedListNode* into a new array item, and returns that array.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"converts empty linked list to empty array",inherit:[1],code:"",evaluate:"ll.toArray();",expected:JSON.stringify([])},{id:3,name:"linked list of 4 items into array",inherit:[1],code:"ll.append(2).append(3).append(4).append(5);",evaluate:"ll.toArray();",expected:JSON.stringify([2,3,4,5])}],setupCode:"\n  LinkedList.prototype.append = function (value) {\n    const newNode = new LinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    this.tail = newNode;\n    return this;\n  };",category:"Linked List",type:d,difficulty:c,maxExecutionTime:2,solution:{stages:[0,30,60,90,150],solutionLines:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  toArray() {"},{stage:2,text:"    const values = [];"},{stage:2,text:""},{stage:3,text:"    let currentNode = this.head;"},{stage:3,text:"    while (currentNode) {"},{stage:4,text:"      values.push(currentNode.value);"},{stage:4,text:"      currentNode = currentNode.next;"},{stage:3,text:"    }"},{stage:3,text:""},{stage:2,text:"    return values;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},N={problemID:9,problemName:"Reverse a *Linked List*.",problemText:"Write a **reverse** method to reverse a Linked List in-place (not using a copy) which then returns itself.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"reverse a list",inherit:[1],code:"ll.append(1).append(2).append(3).append(4);",evaluate:"ll.reverse().toArray();",expected:JSON.stringify([4,3,2,1])},{id:3,name:"reverse an empty list",inherit:[1],code:"",evaluate:"ll.reverse().toArray();",expected:JSON.stringify([])}],setupCode:"\n  LinkedList.prototype.append = function (value) {\n    const newNode = new LinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    this.tail = newNode;\n    return this;\n  };\n  LinkedList.prototype.toArray = function () {\n    const values = [];\n    let currentNode = this.head;\n    while (currentNode) {\n      values.push(currentNode.value);\n      currentNode = currentNode.next;\n    }\n    return values;\n  };\n  ",category:"Linked List",type:d,difficulty:u,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,240],solutionLines:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  reverse() {"},{stage:1,text:"    let currNode = this.head;"},{stage:2,text:"    let prevNode = null;"},{stage:2,text:"    let nextNode = null;"},{stage:3,text:""},{stage:4,text:"    while (currNode) {"},{stage:5,text:"      nextNode = currNode.next;"},{stage:5,text:"      currNode.next = prevNode;"},{stage:6,text:"      prevNode = currNode;"},{stage:6,text:"      currNode = nextNode;"},{stage:4,text:"    }"},{stage:4,text:""},{stage:7,text:"    this.tail = this.head;"},{stage:7,text:"    this.head = prevNode;"},{stage:3,text:""},{stage:2,text:"    return this;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},w={problemID:10,problemName:"Implement **prepend** in a *DoublyLinkedList* class.",problemText:"Write a **prepend** method in a *DoublyLinkedList* class that accepts an arbitrary `value` parameter, creates a *DoublyLinkedListNode*, and inserts it at the front of the list.  The method should return the original list.",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"prepend element onto empty list",inherit:[1],code:"dll.prepend(5);",evaluate:"dll.head.value;",expected:5},{id:3,name:"prepend element onto empty list, tail correct",inherit:[1,2],code:"",evaluate:"dll.tail.value;",expected:5},{id:4,name:"prepend 2nd element onto list, head correct",inherit:[1],code:"dll.prepend(7);",evaluate:"dll.head.value;",expected:7},{id:5,name:"prepend 2nd element onto list, tail correct",inherit:[1,2,4],code:"",evaluate:"dll.tail.value;",expected:5},{id:6,name:"prepend 2nd element onto list, head next correct",inherit:[1,2,4],code:"",evaluate:"dll.head.next.value;",expected:5}],setupCode:"",category:"Doubly Linked List",type:d,difficulty:h,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  prepend(value) {"},{stage:2,text:"    const newNode = new DoublyLinkedListNode(value, this.head);"},{stage:2,text:""},{stage:3,text:"    if (this.head) {"},{stage:4,text:"      this.head.previous = newNode;"},{stage:3,text:"    }"},{stage:4,text:"    this.head = newNode;"},{stage:3,text:""},{stage:5,text:"    if (!this.tail) {"},{stage:5,text:"      this.tail = newNode;"},{stage:5,text:"    }"},{stage:4,text:""},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},E={problemID:11,problemName:"Implement **append** in a *DoublyLinkedList* class.",problemText:"Write an **append** method in a *DoublyLinkedList* class that accepts an arbitrary `value` parameter, creates a *DoublyLinkedListNode*, and adds it to the end of the list.  The method should return the original list.",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"append onto empty list, head set correctly",inherit:[1],code:"dll.append(3);",evaluate:"dll.head.value;",expected:3},{id:3,name:"append onto empty list, tail set correctly",inherit:[1,2],code:"",evaluate:"dll.tail.value;",expected:3},{id:4,name:"append 2nd item onto list, check head",inherit:[1,2],code:"dll.append(8);",evaluate:"dll.head.value;",expected:3},{id:5,name:"append 2nd item onto list, check tail",inherit:[1,2,4],code:"",evaluate:"dll.tail.value;",expected:8},{id:6,name:"append 2nd item onto list, check head next",inherit:[1,2,4],code:"",evaluate:"dll.head.next.value;",expected:8}],setupCode:"",category:"Doubly Linked List",type:d,difficulty:h,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  append(value) {"},{stage:2,text:"    const newNode = new DoublyLinkedListNode(value);"},{stage:2,text:""},{stage:3,text:"    if (!this.head) {"},{stage:4,text:"      this.head = newNode;"},{stage:4,text:"      this.tail = newNode;"},{stage:4,text:"      return this;"},{stage:3,text:"    }"},{stage:3,text:""},{stage:5,text:"    this.tail.next = newNode;"},{stage:5,text:"    newNode.previous = this.tail;"},{stage:5,text:"    this.tail = newNode;"},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},I={problemID:12,problemName:"Implement **delete** in a *DoublyLinkedList* class.",problemText:"Write a **delete** method in a *DoublyLinkedList* class that accepts an arbitrary `value` parameter and deletes all `DoublyLinkedListNode` nodes that have a matching value.  The method should return the last node deleted (or `null` if no match found).",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"return null on empty list",inherit:[1],code:"",evaluate:"dll.delete(5);",expected:null},{id:3,name:"add and cleanly remove node from list (check head)",inherit:[1],code:"dll.append(5);dll.delete(5);",evaluate:"dll.head",expected:null},{id:4,name:"add and cleanly remove node from list (check tail)",inherit:[1,3],code:"",evaluate:"dll.tail",expected:null},{id:5,name:"add 3 nodes and delete the first",inherit:[1],code:"dll.append(1).append(2).append(3);",evaluate:"dll.delete(1);dll.head.value;",expected:2},{id:6,name:"add 3 nodes and delete the first (check tail)",inherit:[1,5],code:"",evaluate:"dll.delete(1);dll.tail.value;",expected:3},{id:7,name:"add 3 nodes and delete the second (check head connector)",inherit:[1,5],code:"",evaluate:"dll.delete(2);dll.head.next.value;",expected:3},{id:8,name:"add 3 nodes and delete the last (check tail)",inherit:[1,5],code:"",evaluate:"dll.delete(3);dll.tail.value;",expected:2},{id:9,name:"add 3 nodes and delete them all (check head)",inherit:[1,5],code:"",evaluate:"dll.delete(3);dll.delete(2);dll.delete(1);dll.head;",expected:null},{id:10,name:"add 3 nodes and delete them all (check tail)",inherit:[1,5],code:"",evaluate:"dll.delete(3);dll.delete(2);dll.delete(1);dll.tail;",expected:null}],setupCode:"\n  DoublyLinkedList.prototype.append = function(value) {\n    const newNode = new DoublyLinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    newNode.previous = this.tail;\n    this.tail = newNode;\n    return this;\n  }\n  ",category:"Doubly Linked List",type:d,difficulty:u,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,210,240,270,300,330,360,420],solutionLines:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  delete(value) {"},{stage:2,text:"    if (!this.head) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:2,text:""},{stage:3,text:"    let deletedNode = null;"},{stage:3,text:"    let currentNode = this.head;"},{stage:3,text:""},{stage:4,text:"    while (currentNode) {"},{stage:5,text:"      if (currentNode.value === value) {"},{stage:6,text:"        deletedNode = currentNode;"},{stage:6,text:""},{stage:6,text:"        if (deletedNode === this.head) {"},{stage:7,text:"          this.head = deletedNode.next;"},{stage:7,text:""},{stage:8,text:"          if (this.head) {"},{stage:8,text:"            this.head.previous = null;"},{stage:8,text:"          }"},{stage:8,text:""},{stage:9,text:"          if (deletedNode === this.tail) {"},{stage:9,text:"            this.tail = null;"},{stage:9,text:"          }"},{stage:6,text:"        } else if (deletedNode === this.tail) {"},{stage:10,text:"          this.tail = deletedNode.previous;"},{stage:10,text:"          this.tail.next = null;"},{stage:6,text:"        } else {"},{stage:11,text:"          const previousNode = deletedNode.previous;"},{stage:11,text:"          const nextNode = deletedNode.next;"},{stage:11,text:""},{stage:12,text:"          previousNode.next = nextNode;"},{stage:12,text:"          nextNode.previous = previousNode;"},{stage:6,text:"        }"},{stage:5,text:"      }"},{stage:5,text:""},{stage:13,text:"      currentNode = currentNode.next;"},{stage:4,text:"    }"},{stage:7,text:""},{stage:7,text:"    return deletedNode;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},C={problemID:13,problemName:"Implement **find** in a *DoublyLinkedList* class.",problemText:"Write a **find** method in a *DoublyLinkedList* class that accepts an arbitrary `value` parameter and returns the first `DoublyLinkedListNode` that has a matching value (or `null` if no match found).",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"find on an empty list",inherit:[1],code:"",evaluate:"dll.find(5);",expected:null},{id:3,name:"add one item, find that item",inherit:[1],code:"dll.append(4);",evaluate:"dll.find(4).value;",expected:4},{id:4,name:"add one item, find an item that does not exist",inherit:[1],code:"dll.append(4);",evaluate:"dll.find(6);",expected:null},{id:5,name:"add three items, find an item",inherit:[1],code:"dll.append(1).append(2).append(3);",evaluate:"dll.find(2).value;",expected:2},{id:6,name:"add three items -two dupicates, return the first",inherit:[1],code:"dll.append(1).append(2).append(2);",evaluate:"dll.find(2) === dll.head.next;",expected:!0}],setupCode:"\n  DoublyLinkedList.prototype.append = function(value) {\n    const newNode = new DoublyLinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    newNode.previous = this.tail;\n    this.tail = newNode;\n    return this;\n  }\n  ",category:"Doubly Linked List",type:d,difficulty:c,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,210],solutionLines:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  find(value) {"},{stage:2,text:"    if (!this.head) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:3,text:""},{stage:3,text:"    let currentNode = this.head;"},{stage:3,text:""},{stage:4,text:"    while (currentNode) {"},{stage:5,text:"      if (currentNode.value === value) {"},{stage:5,text:"        return currentNode;"},{stage:5,text:"      }"},{stage:6,text:""},{stage:6,text:"      currentNode = currentNode.next;"},{stage:4,text:"    }"},{stage:4,text:""},{stage:4,text:"    return null;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},T={problemID:14,problemName:"Implement **deleteTail** in a *DoublyLinkedList* class.",problemText:"Write a **deleteTail** method in a *DoublyLinkedList* class that will remove and return the last `DoublyLinkedListNode` in the list, or `null` if the list is empty.",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"return null if list is empty",inherit:[1],code:"",evaluate:"dll.deleteTail();",expected:null},{id:3,name:"return item from 1 item list.",inherit:[1],code:"dll.append(5);",evaluate:"dll.deleteTail().value;",expected:5},{id:4,name:"return item from 1 item list - head set correctly.",inherit:[1,3],code:"dll.deleteTail();",evaluate:"dll.head;",expected:null},{id:5,name:"return item from 1 item list - tail set correctly.",inherit:[1,3],code:"dll.deleteTail();",evaluate:"dll.tail;",expected:null},{id:6,name:"add 3 items, deleteTail twice.",inherit:[1],code:"dll.append(5).append(4).append(3);dll.deleteTail();dll.deleteTail();",evaluate:"dll.head.value",expected:5},{id:7,name:"add 3 items, deleteTail twice.",inherit:[1,6],code:"",evaluate:"dll.tail.value",expected:5}],setupCode:"\n  DoublyLinkedList.prototype.append = function(value) {\n    const newNode = new DoublyLinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    newNode.previous = this.tail;\n    this.tail = newNode;\n    return this;\n  }\n  ",category:"Doubly Linked List",type:d,difficulty:h,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,210],solutionLines:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  deleteTail() {"},{stage:2,text:"    if (!this.tail) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:3,text:""},{stage:3,text:"    if (this.head === this.tail) {"},{stage:4,text:"      const deletedTail = this.tail;"},{stage:4,text:"      this.head = null;"},{stage:4,text:"      this.tail = null;"},{stage:4,text:"      return deletedTail;"},{stage:3,text:"    }"},{stage:5,text:""},{stage:6,text:"    const deletedTail = this.tail;"},{stage:6,text:"    this.tail = this.tail.previous;"},{stage:6,text:"    this.tail.next = null;"},{stage:5,text:""},{stage:5,text:"    return deletedTail;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},S={problemID:15,problemName:"Implement **deleteHead** in a *DoublyLinkedList* class.",problemText:"Write a **deleteHead** method in a *DoublyLinkedList* class that will remove and return the first `DoublyLinkedListNode` in the list (or `null` if the list is empty).",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"deleteHead from an empty list returns null",inherit:[1],code:"",evaluate:"dll.deleteHead();",expected:null},{id:3,name:"add item and delete item",inherit:[1],code:"dll.append(8);",evaluate:"dll.deleteHead().value;",expected:8},{id:4,name:"add item and delete item - check head;",inherit:[1],code:"dll.append(8);dll.deleteHead();",evaluate:"dll.head;",expected:null},{id:5,name:"add item and delete item",inherit:[1,4],code:"",evaluate:"dll.tail;",expected:null},{id:6,name:"add 3 items and delete one",inherit:[1],code:"dll.append(6).append(7).append(8);",evaluate:"dll.deleteHead().value;",expected:6},{id:7,name:"add 3 items and delete one - check head",inherit:[1,6],code:"dll.deleteHead();",evaluate:"dll.head.value;",expected:7},{id:8,name:"add 3 items and delete one - check tail",inherit:[1,6,7],code:"",evaluate:"dll.tail.value;",expected:8}],setupCode:"\n  DoublyLinkedList.prototype.append = function(value) {\n    const newNode = new DoublyLinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    newNode.previous = this.tail;\n    this.tail = newNode;\n    return this;\n  }\n  ",category:"Doubly Linked List",type:d,difficulty:h,maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  deleteHead() {"},{stage:2,text:"    if (!this.head) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:3,text:""},{stage:3,text:"    const deletedHead = this.head;"},{stage:3,text:""},{stage:4,text:"    if (this.head.next) {"},{stage:5,text:"      this.head = this.head.next;"},{stage:5,text:"      this.head.previous = null;"},{stage:4,text:"    } else {"},{stage:6,text:"      this.head = null;"},{stage:6,text:"      this.tail = null;"},{stage:4,text:"    }"},{stage:4,text:""},{stage:4,text:"    return deletedHead;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},R={problemID:16,problemName:"Implement **fromArray** in a *DoublyLinkedList* class.",problemText:"Given a *DoublyLinkedList* class with an **append** method, create a **fromArray** method that will take in an array of `values` as a parameter, populate corresponding `DoublyLinkedListNode`'s and return the list.",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"empty array creates empty list - check head",inherit:[1],code:"dll.fromArray([]);",evaluate:"dll.head;",expected:null},{id:3,name:"empty array creates empty list - check tail",inherit:[1,2],code:"",evaluate:"dll.tail;",expected:null},{id:4,name:"creates one-item list - check head",inherit:[1],code:"dll.fromArray([5]);",evaluate:"dll.head.value;",expected:5},{id:5,name:"creates one-item list - check tail",inherit:[1,4],code:"",evaluate:"dll.tail.value;",expected:5},{id:6,name:"creates three-item list - check head",inherit:[1],code:"dll.fromArray([6,7,8]);",evaluate:"dll.head.value;",expected:6},{id:7,name:"creates three-item list - check tail",inherit:[1,6],code:"",evaluate:"dll.tail.value;",expected:8},{id:8,name:"creates three-item list - check head next",inherit:[1,6],code:"",evaluate:"dll.head.next.value;",expected:7}],setupCode:"\n  DoublyLinkedList.prototype.append = function (value) {\n    const newNode = new DoublyLinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    newNode.previous = this.tail;\n    this.tail = newNode;\n    return this;\n  }\n  ",category:"Doubly Linked List",type:d,difficulty:c,maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED: append(value: any) DoublyLinkedList"},{stage:-1,text:""},{stage:1,text:"  fromArray(values) {"},{stage:3,text:"    values.forEach(value => this.append(value));"},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},O={problemID:17,problemName:"Implement **toArray** in a *DoublyLinkedList* class.",problemText:"Provide a class method **toArray** that converts *DoublyLinkedListNode* `value`'s in a *DoublyLinkedList* into array elements in matching order.",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"empty list makes empty array",inherit:[1],code:"",evaluate:"dll.toArray();",expected:JSON.stringify([])},{id:3,name:"one item list",inherit:[1],code:"dll.append(4);",evaluate:"dll.toArray();",expected:JSON.stringify([4])},{id:4,name:"three item list",inherit:[1],code:"dll.append(4).append(5).append(6);",evaluate:"dll.toArray();",expected:JSON.stringify([4,5,6])}],setupCode:"\n  DoublyLinkedList.prototype.append = function (value) {\n    const newNode = new DoublyLinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    newNode.previous = this.tail;\n    this.tail = newNode;\n    return this;\n  }\n  ",category:"Doubly Linked List",type:d,difficulty:c,maxExecutionTime:2,solution:{stages:[0,30,60,90,150],solutionLines:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  toArray() {"},{stage:2,text:"    const nodes = [];"},{stage:2,text:""},{stage:3,text:"    let currentNode = this.head;"},{stage:3,text:"    while (currentNode) {"},{stage:4,text:"      nodes.push(currentNode.value);"},{stage:4,text:"      currentNode = currentNode.next;"},{stage:3,text:"    }"},{stage:3,text:""},{stage:2,text:"    return nodes;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},B={problemID:18,problemName:"Reverse a *DoublyLinkedList* in-place.",problemText:"Provide a class method **reverse** that will reverse a *DoublyLinkedList* in place (not using a copy), and return the list.",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"reversing an empty list - still empty",inherit:[1],code:"",evaluate:"dll.reverse();",expected:'{"head":null,"tail":null}'},{id:3,name:"reversing a one item list - check head",inherit:[1],code:"dll.append(5);",evaluate:"dll.reverse().head.value;",expected:5},{id:4,name:"reversing a one item list - check head",inherit:[1,3],code:"",evaluate:"dll.reverse().tail.value;",expected:5},{id:5,name:"reversing a three item list - check head",inherit:[1],code:"dll.append(6).append(7).append(8);",evaluate:"dll.reverse().head.value;",expected:8},{id:6,name:"reversing a three item list - check head",inherit:[1,5],code:"",evaluate:"dll.reverse().tail.value;",expected:6},{id:7,name:"reversing a three item list - check head next",inherit:[1,5],code:"",evaluate:"dll.reverse().head.next.value;",expected:7}],setupCode:"\n  DoublyLinkedList.prototype.append = function(value) {\n    const newNode = new DoublyLinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    newNode.previous = this.tail;\n    this.tail = newNode;\n    return this;\n  }\n  ",category:"Doubly Linked List",type:d,difficulty:u,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,240],solutionLines:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  reverse() {"},{stage:2,text:"    let currNode = this.head;"},{stage:2,text:"    let prevNode = null;"},{stage:2,text:"    let nextNode = null;"},{stage:3,text:""},{stage:3,text:"    while (currNode) {"},{stage:4,text:"      nextNode = currNode.next;"},{stage:4,text:"      prevNode = currNode.previous;"},{stage:4,text:""},{stage:5,text:"      currNode.next = prevNode;"},{stage:5,text:"      currNode.previous = nextNode;"},{stage:5,text:""},{stage:6,text:"      prevNode = currNode;"},{stage:6,text:"      currNode = nextNode;"},{stage:3,text:"    }"},{stage:3,text:""},{stage:7,text:"    this.tail = this.head;"},{stage:7,text:"    this.head = prevNode;"},{stage:7,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},D={problemID:19,problemName:"Implement a recursive fibonacci function.",problemText:"Implement a function **fibonacciNth** which takes an integer parameter `n` and returns the nth indexed fibonnaci number in the sequence.  For example, n=0 would return 0, n=1 would return 1, n=2 would return 1, and n=3 would return 2. ([0,1,1,2,3,5,8,13... etc]).  Please solve **recursively**.",testCases:[{id:1,name:"0 case",inherit:[],code:"",evaluate:"fibonacciNth(0);",expected:0},{id:2,name:"1 case",inherit:[],code:"",evaluate:"fibonacciNth(1);",expected:1},{id:3,name:"2 case",inherit:[],code:"",evaluate:"fibonacciNth(2);",expected:1},{id:4,name:"3 case",inherit:[],code:"",evaluate:"fibonacciNth(3);",expected:2},{id:5,name:"4 case",inherit:[],code:"",evaluate:"fibonacciNth(4);",expected:3},{id:6,name:"5 case",inherit:[],code:"",evaluate:"fibonacciNth(5);",expected:5},{id:7,name:"6 case",inherit:[],code:"",evaluate:"fibonacciNth(6);",expected:8},{id:8,name:"7 case",inherit:[],code:"",evaluate:"fibonacciNth(7);",expected:13},{id:9,name:"8 case",inherit:[],code:"",evaluate:"fibonacciNth(8);",expected:21}],setupCode:"",category:"Fibonacci",type:"algorithm",difficulty:c,maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:1,text:"const fibonacciNth = n => {"},{stage:2,text:"  if (n === 0 || n === 1) return n;"},{stage:3,text:"  return fibonacciNth(n - 1) + fibonacciNth(n - 2);"},{stage:1,text:"};"},{stage:0,text:""}]}},j={problemID:20,problemName:"Implement an iterative fibonacci function.",problemText:"Implement a function `fibonacciNth` which takes an integer parameter `n` and returns the nth indexed fibonnaci number in the sequence.  For example, n=0 would return 0, n=1 would return 1, n=2 would return 1, and n=3 would return 2. ([0,1,1,2,3,5,8,13... etc]).  Please solve **iteratively**.",testCases:[{id:1,name:"0 case",inherit:[],code:"",evaluate:"fibonacciNth(0);",expected:0},{id:2,name:"1 case",inherit:[],code:"",evaluate:"fibonacciNth(1);",expected:1},{id:3,name:"2 case",inherit:[],code:"",evaluate:"fibonacciNth(2);",expected:1},{id:4,name:"3 case",inherit:[],code:"",evaluate:"fibonacciNth(3);",expected:2},{id:5,name:"4 case",inherit:[],code:"",evaluate:"fibonacciNth(4);",expected:3},{id:6,name:"5 case",inherit:[],code:"",evaluate:"fibonacciNth(5);",expected:5},{id:7,name:"6 case",inherit:[],code:"",evaluate:"fibonacciNth(6);",expected:8},{id:8,name:"7 case",inherit:[],code:"",evaluate:"fibonacciNth(7);",expected:13},{id:9,name:"8 case",inherit:[],code:"",evaluate:"fibonacciNth(8);",expected:21}],setupCode:"",category:"Fibonacci",type:"algorithm",difficulty:h,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,210],solutionLines:[{stage:1,text:"function fibonacciNth(n) {"},{stage:2,text:"  let currentValue = 1;"},{stage:2,text:"  let previousValue = 0;"},{stage:2,text:""},{stage:3,text:"  if (n <= 1) {"},{stage:3,text:"    return n;"},{stage:3,text:"  }"},{stage:3,text:""},{stage:4,text:"  let iteration = 2;"},{stage:4,text:""},{stage:5,text:"  while (iteration <= n) {"},{stage:6,text:"    currentValue += previousValue;"},{stage:6,text:"    previousValue = currentValue - previousValue;"},{stage:6,text:"    iteration++;"},{stage:5,text:"  }"},{stage:5,text:""},{stage:4,text:"  return currentValue;"},{stage:1,text:"}"},{stage:0,text:""}]}},H={problemID:21,problemName:"Implement a *Queue* using a *Linked List*",problemText:"\nGiven a *Queue* class, implement the following methods: \n    \n - **isEmpty** (which returns a Boolean value indicating if there are any items in the queue)\n - **peek** (which returns - but does not remove - the value at the head of the queue)\n - **enqueue** (which adds a value to the end of the queue - does not return anything)\n - **dequeue** (which removes and returns the value at the head of the queue).  \n    \nBase the implementation on the given *LinkedList* base data structure.  Return `null` for **peek** and **dequeue** if the queue is empty.",testCases:[{id:1,name:"compiles",inherit:[],code:"const queue=new Queue();",evaluate:"Boolean(queue);",expected:!0},{id:2,name:"peek on an empty queue returns null",inherit:[1],code:"",evaluate:"queue.peek();",expected:null},{id:3,name:"dequeue on an empty queue returns null",inherit:[1],code:"",evaluate:"queue.dequeue();",expected:null},{id:4,name:"peek returns enqueued item",inherit:[1],code:"queue.enqueue(5);",evaluate:"queue.peek();",expected:5},{id:5,name:"peek, queue, dequeue work together properly",inherit:[1],code:"queue.enqueue(5);queue.enqueue(7);queue.dequeue();",evaluate:"queue.peek();",expected:7},{id:6,name:"peek returns enqueued item (3)",inherit:[1],code:"queue.enqueue(5);queue.enqueue(6);queue.enqueue(7);",evaluate:"queue.peek();",expected:5},{id:7,name:"dequeue multiple enqueued items",inherit:[1],code:"queue.enqueue(5);queue.enqueue(6);queue.enqueue(7);queue.dequeue();queue.dequeue();",evaluate:"queue.peek();",expected:7},{id:8,name:"isEmpty returns true for empty queue",inherit:[1],code:"",evaluate:"queue.isEmpty();",expected:!0},{id:9,name:"isEmpty returns false for queue with an item",inherit:[1],code:"queue.enqueue(5);",evaluate:"queue.isEmpty();",expected:!1},{id:10,name:"dequeue returns value, not node",inherit:[1],code:"queue.enqueue(5);",evaluate:"queue.dequeue();",expected:5}],setupCode:"\n  \n  class LinkedListNode {\n    constructor(value, next = null) {\n      this.value = value;\n      this.next = next;\n    }\n  }\n  \n  class LinkedList {\n    constructor() {\n      this.head = null;\n      this.tail = null;\n    }\n    \n    append(value) {\n      const newNode = new LinkedListNode(value);\n      if (!this.head) {\n        this.head = newNode;\n        this.tail = newNode;\n        return this;\n      }\n      this.tail.next = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    \n    deleteHead() {\n      if (!this.head) {\n        return null;\n      }\n      const deletedHead = this.head;\n      if (this.head.next) {\n        this.head = this.head.next;\n      } else {\n        this.head = null;\n        this.tail = null;\n      }\n      return deletedHead;\n    }\n  }\n  ",category:"Queue",type:d,difficulty:h,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,240],solutionLines:[{stage:-1,text:"//  class LinkedListNode {"},{stage:-1,text:"//    constructor(value, next = null) {"},{stage:-1,text:"//      this.value = value;"},{stage:-1,text:"//      this.next = next;"},{stage:-1,text:"//    }"},{stage:-1,text:"//  }"},{stage:-1,text:"//"},{stage:-1,text:"//  class LinkedList {"},{stage:-1,text:"//    constructor() {"},{stage:-1,text:"//      this.head = null;"},{stage:-1,text:"//      this.tail = null;"},{stage:-1,text:"//    }"},{stage:-1,text:"//"},{stage:-1,text:"//    append(value: any) LinkedList"},{stage:-1,text:"//    deleteHead() LinkedListNode"},{stage:-1,text:"//"},{stage:-1,text:"//  }"},{stage:-1,text:"//"},{stage:-1,text:"// All code above is implicitly included in your environment"},{stage:0,text:""},{stage:0,text:""},{stage:0,text:"class Queue {"},{stage:1,text:"  constructor() {"},{stage:2,text:"    this.linkedList = new LinkedList();"},{stage:1,text:"  }"},{stage:0,text:""},{stage:3,text:"  isEmpty() {"},{stage:5,text:"    return !this.linkedList.head;"},{stage:3,text:"  }"},{stage:0,text:""},{stage:3,text:"  peek() {"},{stage:6,text:"    if (this.isEmpty()) {"},{stage:6,text:"      return null;"},{stage:6,text:"    }"},{stage:6,text:"    return this.linkedList.head.value;"},{stage:3,text:"  }"},{stage:0,text:""},{stage:4,text:"  enqueue(value) {"},{stage:5,text:"    this.linkedList.append(value);"},{stage:4,text:"  }"},{stage:0,text:""},{stage:4,text:"  dequeue() {"},{stage:7,text:"    if (this.isEmpty()) {"},{stage:7,text:"      return null;"},{stage:7,text:"    }"},{stage:7,text:"    return this.linkedList.deleteHead().value;"},{stage:4,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},V={problemID:22,problemName:"Implement a *Queue* from scratch using an *Array*",problemText:"\nGiven a *Queue* class, implement the following methods: \n    \n - **isEmpty** which returns a Boolean value indicating if there are any items in the queue.\n - **peek** which returns - but does not remove - the `value` at the head of the queue.\n - **enqueue** which adds a `value` to the end of the queue - does not return anything.\n - **dequeue** which removes and returns the `value` at the head of the queue.  \n    \nBase the implementation on an *Array* base data structure.  Return `null` for **peek** and **dequeue** if the queue is empty.",testCases:[{id:1,name:"compiles",inherit:[],code:"const queue=new Queue();",evaluate:"Boolean(queue);",expected:!0},{id:2,name:"peek on an empty queue returns null",inherit:[1],code:"",evaluate:"queue.peek();",expected:null},{id:3,name:"dequeue on an empty queue returns null",inherit:[1],code:"",evaluate:"queue.dequeue();",expected:null},{id:4,name:"peek returns enqueued item",inherit:[1],code:"queue.enqueue(5);",evaluate:"queue.peek();",expected:5},{id:5,name:"peek, queue, dequeue work together properly",inherit:[1],code:"queue.enqueue(5);queue.enqueue(7);queue.dequeue();",evaluate:"queue.peek();",expected:7},{id:6,name:"peek returns enqueued item (3)",inherit:[1],code:"queue.enqueue(5);queue.enqueue(6);queue.enqueue(7);",evaluate:"queue.peek();",expected:5},{id:7,name:"dequeue multiple enqueued items",inherit:[1],code:"queue.enqueue(5);queue.enqueue(6);queue.enqueue(7);queue.dequeue();queue.dequeue();",evaluate:"queue.peek();",expected:7},{id:8,name:"isEmpty returns true for empty queue",inherit:[1],code:"",evaluate:"queue.isEmpty();",expected:!0},{id:9,name:"isEmpty returns false for queue with an item",inherit:[1],code:"queue.enqueue(5);",evaluate:"queue.isEmpty();",expected:!1}],setupCode:"",category:"Queue",type:d,difficulty:c,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,240],solutionLines:[{stage:0,text:"class Queue {"},{stage:1,text:"  constructor() {"},{stage:2,text:"    this.items = [];"},{stage:1,text:"  }"},{stage:0,text:""},{stage:3,text:"  isEmpty() {"},{stage:5,text:"    return !this.items.length;"},{stage:3,text:"  }"},{stage:0,text:""},{stage:3,text:"  peek() {"},{stage:5,text:"    if (this.isEmpty()) {"},{stage:5,text:"      return null;"},{stage:5,text:"    }"},{stage:6,text:"    return this.items[0];"},{stage:3,text:"  }"},{stage:0,text:""},{stage:4,text:"  enqueue(value) {"},{stage:6,text:"    this.items.push(value);"},{stage:4,text:"  }"},{stage:0,text:""},{stage:4,text:"  dequeue() {"},{stage:7,text:"    if (this.isEmpty()) {"},{stage:7,text:"      return null;"},{stage:7,text:"    }"},{stage:7,text:"    return this.items.shift();"},{stage:4,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},A={problemID:23,problemName:"Implement a *Stack* using a *Linked List*",problemText:"Given a *Stack* class, implement the following methods: \n\n   - **isEmpty**: returns a boolean value indicating if there are any values in the stack.\n   - **peek**: returns - but does not remove - the value at the top of the stack.\n   - **push**: adds a value to the top of the stack - does not return anything.\n   - **pop**: removes and returns the value at the top of the stack.\n   \nBase the implementation on the given *LinkedList* base data structure.  Return `null` for **peek** and **pop** if the stack is empty.",testCases:[{id:1,name:"compiles",inherit:[],code:"const stack=new Stack();",evaluate:"Boolean(stack);",expected:!0},{id:2,name:"peek on empty stack is null",inherit:[1],code:"",evaluate:"stack.peek();",expected:null},{id:3,name:"pop on empty stack is null",inherit:[1],code:"",evaluate:"stack.pop();",expected:null},{id:4,name:"isEmpty on empty stack is true",inherit:[1],code:"",evaluate:"stack.isEmpty();",expected:!0},{id:5,name:"isEmpty on stack with an item is false",inherit:[1],code:"stack.push(5);",evaluate:"stack.isEmpty();",expected:!1},{id:6,name:"peek on stack with an item returns that value",inherit:[1,5],code:"",evaluate:"stack.peek();",expected:5},{id:7,name:"peek on stack with two items returns correct value",inherit:[1,5],code:"stack.push(9);",evaluate:"stack.peek();",expected:9},{id:8,name:"peek does not remove items",inherit:[1,5,7],code:"",evaluate:"stack.peek();stack.peek();",expected:9},{id:9,name:"pop removes and returns correct item in stack (1)",inherit:[1,5,7],code:"",evaluate:"stack.pop();",expected:9},{id:10,name:"pop removes and returns correct item in stack (2)",inherit:[1,5,7],code:"",evaluate:"stack.pop();stack.pop();",expected:5}],setupCode:"\n  class LinkedListNode {\n    constructor(value, next = null) {\n      this.value = value;\n      this.next = next;\n    }\n  }\n  \n  class LinkedList {\n    constructor() {\n      this.head = null;\n      this.tail = null;\n    }\n    \n    prepend(value) {\n      const newNode = new LinkedListNode(value, this.head);\n      this.head = newNode;\n      if (!this.tail) {\n        this.tail = newNode;\n      }\n      return this;\n    }\n    \n    deleteHead() {\n      if (!this.head) {\n        return null;\n      }\n      const deletedHead = this.head;\n      if (this.head.next) {\n        this.head = this.head.next;\n      } else {\n        this.head = null;\n        this.tail = null;\n      }\n      return deletedHead;\n    }\n  }\n  ",category:"Stack",type:d,difficulty:h,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,240],solutionLines:[{stage:-1,text:"//  class LinkedList {"},{stage:-1,text:"//    prepend(value: any) LinkedList"},{stage:-1,text:"//    deleteHead() LinkedListNode"},{stage:-1,text:"//  }"},{stage:-1,text:"//  class LinkedListNode {"},{stage:-1,text:"//    constructor(value, next = null) {"},{stage:-1,text:"//      this.value = value;"},{stage:-1,text:"//      this.next = next;"},{stage:-1,text:"//    }"},{stage:-1,text:"//  }"},{stage:-1,text:"//"},{stage:-1,text:"// All code above is implicitly included in your environment"},{stage:0,text:""},{stage:0,text:"class Stack {"},{stage:2,text:"  constructor() {"},{stage:2,text:"    this.linkedList = new LinkedList();"},{stage:2,text:"  }"},{stage:0,text:""},{stage:3,text:"  isEmpty() {"},{stage:5,text:"    return !this.linkedList.head;"},{stage:3,text:"  }"},{stage:0,text:""},{stage:3,text:"  peek() {"},{stage:5,text:"    if (this.isEmpty()) {"},{stage:5,text:"      return null;"},{stage:5,text:"    }"},{stage:6,text:"    return this.linkedList.head.value;"},{stage:3,text:"  }"},{stage:0,text:""},{stage:4,text:"  push(value) {"},{stage:6,text:"    this.linkedList.prepend(value);"},{stage:4,text:"  }"},{stage:0,text:""},{stage:4,text:"  pop() {"},{stage:7,text:"    const removedHead = this.linkedList.deleteHead();"},{stage:7,text:"    return removedHead ? removedHead.value : null;"},{stage:4,text:"  }"},{stage:1,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},M={problemID:24,problemName:"Implement a *Stack* using an *Array*",problemText:"Given a *Stack* class, implement the following methods: **isEmpty** (which returns a boolean indicating if there are any values in the stack), **peek** (which returns - but does not remove - the value at the top of the stack), **push** (which adds a value to the top of the stack - does not return anything), and **pop** (which removes and returns the value at the top of the stack).  Base the implementation on an *Array* data structure.  Return `null` for **peek** and **pop** if the stack is empty.",testCases:[{id:1,name:"compiles",inherit:[],code:"const stack=new Stack();",evaluate:"Boolean(stack);",expected:!0},{id:2,name:"peek on empty stack is null",inherit:[1],code:"",evaluate:"stack.peek();",expected:null},{id:3,name:"pop on empty stack is null",inherit:[1],code:"",evaluate:"stack.pop();",expected:null},{id:4,name:"isEmpty on empty stack is true",inherit:[1],code:"",evaluate:"stack.isEmpty();",expected:!0},{id:5,name:"isEmpty on stack with an item is false",inherit:[1],code:"stack.push(5);",evaluate:"stack.isEmpty();",expected:!1},{id:6,name:"peek on stack with an item returns that value",inherit:[1,5],code:"",evaluate:"stack.peek();",expected:5},{id:7,name:"peek on stack with two items returns correct value",inherit:[1,5],code:"stack.push(9);",evaluate:"stack.peek();",expected:9},{id:8,name:"peek does not remove items",inherit:[1,5,7],code:"",evaluate:"stack.peek();stack.peek();",expected:9},{id:9,name:"pop removes and returns correct item in stack (1)",inherit:[1,5,7],code:"",evaluate:"stack.pop();",expected:9},{id:10,name:"pop removes and returns correct item in stack (2)",inherit:[1,5,7],code:"",evaluate:"stack.pop();stack.pop();",expected:5}],setupCode:"",category:"Stack",type:d,difficulty:c,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,210],solutionLines:[{stage:0,text:"class Stack {"},{stage:1,text:"  constructor() {"},{stage:1,text:"    this.items = [];"},{stage:1,text:"  }"},{stage:0,text:""},{stage:2,text:"  isEmpty() {"},{stage:4,text:"    return !this.items.length;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:2,text:"  peek() {"},{stage:4,text:"    if (this.isEmpty()) {"},{stage:4,text:"      return null;"},{stage:4,text:"    }"},{stage:5,text:"    return this.items[this.items.length - 1];"},{stage:2,text:"  }"},{stage:0,text:""},{stage:3,text:"  push(value) {"},{stage:5,text:"    this.items.push(value);"},{stage:3,text:"  }"},{stage:0,text:""},{stage:3,text:"  pop() {"},{stage:6,text:"    if (this.isEmpty()) {"},{stage:6,text:"      return null;"},{stage:6,text:"    }"},{stage:6,text:"    return this.items.pop();"},{stage:3,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},K={problemID:25,problemName:"Implement **set** in a *HashTable* class.",problemText:"Given a *HashTable* class and a *LinkedList* class, implement a **set(key, value)** method in the *HashTable* class that will add or modify a `value` in the hash table for a given `key`.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ht=new HashTable();",evaluate:"Boolean(ht);",expected:!0},{id:2,name:"adds a new value",inherit:[1],code:"ht.set('key1', 5);",evaluate:"ht.get('key1');",expected:5},{id:3,name:"updates an existing value",inherit:[1,2],code:"ht.set('key1', 7);",evaluate:"ht.get('key1');",expected:7}],setupCode:"\n  class LinkedListNode {\n    constructor(key, value, next = null) {\n      this.key = key;\n      this.value = value;\n      this.next = next;\n    }\n  }\n  class LinkedList {\n    constructor() {\n      this.head = null;\n      this.tail = null;\n    }\n    append(key, value) {\n      const newNode = new LinkedListNode(key, value);\n      if (!this.head) {\n        this.head = newNode;\n        this.tail = newNode;\n        return this;\n      }\n      this.tail.next = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    findKey(key) {\n      if (!this.head) {\n        return null;\n      }\n      let current = this.head;\n      while (current) {\n        if (current.key === key) {\n          return current;\n        }\n        current = current.next;\n      }\n      return null;\n    }\n  }\n  HashTable.prototype.hash = function(key) {\n    const hash = Array.from(key).reduce(\n      (hashAccumulator, keySymbol) => hashAccumulator + keySymbol.charCodeAt(0), 0);\n      return hash % this.buckets.length;\n  };\n  HashTable.prototype.get = function(key) {\n    const bucketLinkedList = this.buckets[this.hash(key)];\n    const node = bucketLinkedList.findKey(key);\n    return node ? node.value : undefined;\n  };\n  ",category:"Hash-Table",type:d,difficulty:h,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:-1,text:"// class LinkedList {"},{stage:-1,text:"//   append(key: string, value: any) LinkedList"},{stage:-1,text:"//   findKey(key: string) LinkedListNode"},{stage:-1,text:"// }"},{stage:-1,text:"//"},{stage:-1,text:"//  class LinkedListNode {"},{stage:-1,text:"//    constructor(value, next = null) {"},{stage:-1,text:"//      this.value = value;"},{stage:-1,text:"//      this.next = next;"},{stage:-1,text:"//    }"},{stage:-1,text:"//  }"},{stage:-1,text:"//"},{stage:-1,text:"// All code above is implicitly included in your environment"},{stage:0,text:""},{stage:0,text:"class HashTable {"},{stage:0,text:"  constructor(hashTableSize = 32) {"},{stage:0,text:"    this.buckets = Array(hashTableSize)"},{stage:0,text:"      .fill(null)"},{stage:0,text:"      .map(() => new LinkedList());"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED:  hash(key: string) int"},{stage:-1,text:""},{stage:1,text:"  set(key, value) {"},{stage:2,text:"    const keyHash = this.hash(key);"},{stage:2,text:"    const bucketLinkedList = this.buckets[keyHash];"},{stage:3,text:"    const node = bucketLinkedList.findKey(key);"},{stage:3,text:""},{stage:4,text:"    if (!node) {"},{stage:5,text:"      bucketLinkedList.append(key, value);"},{stage:4,text:"    } else {"},{stage:5,text:"      node.value = value;"},{stage:4,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},q={problemID:26,problemName:"Implement **get** in a *HashTable* class.",problemText:"Given a *HashTable* class and an associated *LinkedList* class, implement a **get** method in the *HashTable* class that will retrieve a `value` from the hash table for a given `key`, or `undefined` if the `key` does not exist.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ht=new HashTable();",evaluate:"Boolean(ht);",expected:!0},{id:2,name:"get a key that doesnt exist",inherit:[1],code:"",evaluate:"ht.get('key1');",expected:void 0},{id:3,name:"get a key",inherit:[1],code:"ht.set('key1', 99);",evaluate:"ht.get('key1');",expected:99}],setupCode:"\n  class LinkedListNode {\n    constructor(key, value, next = null) {\n      this.key = key;\n      this.value = value;\n      this.next = next;\n    }\n  }\n  class LinkedList {\n    constructor() {\n      this.head = null;\n      this.tail = null;\n    }\n    append(key, value) {\n      const newNode = new LinkedListNode(key, value);\n      if (!this.head) {\n        this.head = newNode;\n        this.tail = newNode;\n        return this;\n      }\n      this.tail.next = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    findKey(key) {\n      if (!this.head) {\n        return null;\n      }\n      let current = this.head;\n      while (current) {\n        if (current.key === key) {\n          return current;\n        }\n        current = current.next;\n      }\n      return null;\n    }\n  }\n  HashTable.prototype.hash = function(key) {\n    const hash = Array.from(key).reduce(\n      (hashAccumulator, keySymbol) => hashAccumulator + keySymbol.charCodeAt(0), 0);\n      return hash % this.buckets.length;\n  };\n  HashTable.prototype.set = function(key, value) {\n    const keyHash = this.hash(key);\n    const bucketLinkedList = this.buckets[keyHash];\n    const node = bucketLinkedList.findKey(key);\n    if (!node) {\n      bucketLinkedList.append(key, value);\n    } else {\n      node.value = value;\n    }\n  };\n  ",category:"Hash-Table",type:d,difficulty:c,maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:-1,text:"// class LinkedList {"},{stage:-1,text:"//   findKey(key: string) LinkedListNode"},{stage:-1,text:"// }"},{stage:-1,text:"//"},{stage:-1,text:"// class LinkedListNode {"},{stage:-1,text:"//   constructor(value, next = null) {"},{stage:-1,text:"//     this.value = value;"},{stage:-1,text:"//     this.next = next;"},{stage:-1,text:"//   }"},{stage:-1,text:"// }"},{stage:-1,text:"//"},{stage:-1,text:"// All code above is implicitly included in your environment"},{stage:0,text:""},{stage:0,text:"class HashTable {"},{stage:0,text:"  constructor(hashTableSize = 32) {"},{stage:0,text:"    this.buckets = Array(hashTableSize)"},{stage:0,text:"      .fill(null)"},{stage:0,text:"      .map(() => new LinkedList());"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED:  hash(key: string) int"},{stage:-1,text:""},{stage:1,text:"  get(key) {"},{stage:2,text:"    const bucketLinkedList = this.buckets[this.hash(key)];"},{stage:3,text:"    const node = bucketLinkedList.findKey(key);"},{stage:3,text:"    return node ? node.value : undefined;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},P={problemID:27,problemName:"Implement **delete** in a *HashTable* class.",problemText:"Given a *HashTable* class and an associated *LinkedList* class, implement a **delete** method in the *HashTable* class that will delete the entry for a given `key`.\n  \n  The method must return the value of the deleted item, or `null` if an item matching the `key` was not found.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ht=new HashTable();",evaluate:"Boolean(ht);",expected:!0},{id:2,name:"deleting a key that does not exist returns null",inherit:[1],code:"",evaluate:"ht.delete('key1');",expected:null},{id:3,name:"deleting a key that does exist",inherit:[1],code:"ht.set('key1', 77);",evaluate:"ht.delete('key1');",expected:77}],setupCode:"\n  class LinkedListNode {\n    constructor(key, value, next = null) {\n      this.key = key;\n      this.value = value;\n      this.next = next;\n    }\n  }\n  class LinkedList {\n    constructor() {\n      this.head = null;\n      this.tail = null;\n    }\n    append(key, value) {\n      const newNode = new LinkedListNode(key, value);\n      if (!this.head) {\n        this.head = newNode;\n        this.tail = newNode;\n        return this;\n      }\n      this.tail.next = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    findKey(key) {\n      if (!this.head) {\n        return null;\n      }\n      let current = this.head;\n      while (current) {\n        if (current.key === key) {\n          return current;\n        }\n        current = current.next;\n      }\n      return null;\n    }\n    deleteKey(key) {\n      if (!this.head) {\n        return null;\n      }\n      if (key === this.head.key) {\n        const deletedHead = this.head;\n        if (this.head.next) {\n          this.head = this.head.next;\n        } else {\n          this.head = null;\n          this.tail = null;\n        }\n        return deletedHead;\n      } else if (key === this.tail.key) {\n        const deletedTail = this.tail;\n        let currentNode = this.head;\n        while (currentNode.next) {\n          if (!currentNode.next.next) {\n            currentNode.next = null;\n          } else {\n            currentNode = currentNode.next;\n          }\n        }\n        this.tail = currentNode;\n        return deletedTail;\n      } else {\n        let currentNode = this.head;\n        while (currentNode.next) {\n          if (currentNode.next.key === key) {\n            const deletedNode = currentNode.next;\n            currentNode.next = deletedNode.next;\n            return deletedNode;\n          }\n          currentNode = currentNode.next;\n        }\n        return null;\n      }\n    }\n  }\n  HashTable.prototype.hash = function(key) {\n    const hash = Array.from(key).reduce(\n      (hashAccumulator, keySymbol) => hashAccumulator + keySymbol.charCodeAt(0), 0);\n      return hash % this.buckets.length;\n  };\n  HashTable.prototype.set = function(key, value) {\n    const keyHash = this.hash(key);\n    const bucketLinkedList = this.buckets[keyHash];\n    const node = bucketLinkedList.findKey(key);\n    if (!node) {\n      bucketLinkedList.append(key, value);\n    } else {\n      node.value = value;\n    }\n  };\n  HashTable.prototype.get = function(key) {\n    const bucketLinkedList = this.buckets[this.hash(key)];\n    const node = bucketLinkedList.findKey(key);\n    return node ? node.value : undefined;\n  };\n  ",category:"Hash-Table",type:d,difficulty:h,maxExecutionTime:2,solution:{stages:[0,30,60,90,150],solutionLines:[{stage:-1,text:"// class LinkedList {"},{stage:-1,text:"//   deleteKey(key: string) LinkedListNode"},{stage:-1,text:"// }"},{stage:-1,text:"//  class LinkedListNode {"},{stage:-1,text:"//    constructor(value, next = null) {"},{stage:-1,text:"//      this.value = value;"},{stage:-1,text:"//      this.next = next;"},{stage:-1,text:"//    }"},{stage:-1,text:"//  }"},{stage:-1,text:"//"},{stage:-1,text:"// All code above is implicitly included in your environment"},{stage:0,text:""},{stage:0,text:"class HashTable {"},{stage:0,text:"  constructor(hashTableSize = 32) {"},{stage:0,text:"    this.buckets = Array(hashTableSize)"},{stage:0,text:"      .fill(null)"},{stage:0,text:"      .map(() => new LinkedList());"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED:  hash(key: string) int"},{stage:-1,text:""},{stage:1,text:"  delete(key) {"},{stage:2,text:"    const keyHash = this.hash(key);"},{stage:2,text:"    const bucketLinkedList = this.buckets[keyHash];"},{stage:3,text:"    const deletedNode = bucketLinkedList.deleteKey(key);"},{stage:4,text:"    if (deletedNode) {"},{stage:4,text:"      return deletedNode.value;"},{stage:4,text:"    }"},{stage:3,text:"    return null;"},{stage:1,text:"  }"},{stage:0,text:"}"},{stage:0,text:""}]}},J={problemID:28,problemName:"Implement child index functions for a *MinHeap* class.",problemText:"Implement the following methods for the *MinHeap* data structure:  \n   - **getLeftChildIndex** (parentIndex: integer) => integer  \n   - **getRightChildIndex** (parentIndex: integer) => integer  \n   - **hasLeftChild** (parentIndex: integer) => boolean  \n   - **hasRightChild** (parentIndex: integer) => boolean  \n   - **leftChild** (parentIndex: integer) => heap value  \n   - **rightChild** (parentIndex: integer) => heap value\n",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"getLeftChildIndex - test 0",inherit:[1],code:"",evaluate:"minheap.getLeftChildIndex(0);",expected:1},{id:2,name:"getLeftChildIndex - test 1",inherit:[1],code:"",evaluate:"minheap.getLeftChildIndex(5);",expected:11},{id:3,name:"getRightChildIndex - test 0",inherit:[1],code:"",evaluate:"minheap.getRightChildIndex(0);",expected:2},{id:4,name:"getRightChildIndex - test 1",inherit:[1],code:"",evaluate:"minheap.getRightChildIndex(12);",expected:26},{id:5,name:"hasLeftChild - true",inherit:[1],code:"minheap.heapContainer.length = 10;",evaluate:"minheap.hasLeftChild(4);",expected:!0},{id:6,name:"hasLeftChild - false",inherit:[1],code:"minheap.heapContainer.length = 9;",evaluate:"minheap.hasLeftChild(4);",expected:!1},{id:7,name:"hasRightChild - true",inherit:[1],code:"minheap.heapContainer.length = 11;",evaluate:"minheap.hasRightChild(4);",expected:!0},{id:8,name:"hasRightChild - false",inherit:[1],code:"minheap.heapContainer.length = 10;",evaluate:"minheap.hasRightChild(4);",expected:!1},{id:9,name:"leftChild",inherit:[1],code:"minheap.heapContainer = [1,4,5,8,10,12,16];",evaluate:"minheap.leftChild(0);",expected:4},{id:10,name:"leftChild",inherit:[1,9],code:"",evaluate:"minheap.leftChild(2);",expected:12},{id:11,name:"rightChild",inherit:[1,9],code:"",evaluate:"minheap.rightChild(0);",expected:5},{id:12,name:"rightChild",inherit:[1,9],code:"",evaluate:"minheap.rightChild(2);",expected:16}],setupCode:"",category:x,type:d,difficulty:h,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,240],solutionLines:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  getLeftChildIndex(parentIndex) {"},{stage:2,text:"    return 2 * parentIndex + 1;"},{stage:1,text:"  }"},{stage:2,text:""},{stage:1,text:"  getRightChildIndex(parentIndex) {"},{stage:3,text:"    return 2 * parentIndex + 2;"},{stage:1,text:"  }"},{stage:3,text:""},{stage:1,text:"  hasLeftChild(parentIndex) {"},{stage:4,text:"    return this.getLeftChildIndex(parentIndex) < this.heapContainer.length;"},{stage:1,text:"  }"},{stage:4,text:""},{stage:1,text:"  hasRightChild(parentIndex) {"},{stage:5,text:"    return this.getRightChildIndex(parentIndex) < this.heapContainer.length;"},{stage:1,text:"  }"},{stage:5,text:""},{stage:1,text:"  leftChild(parentIndex) {"},{stage:6,text:"    return this.heapContainer[this.getLeftChildIndex(parentIndex)];"},{stage:1,text:"  }"},{stage:6,text:""},{stage:1,text:"  rightChild(parentIndex) {"},{stage:7,text:"    return this.heapContainer[this.getRightChildIndex(parentIndex)];"},{stage:1,text:"  }"},{stage:0,text:"}"},{stage:0,text:""}]}},G={problemID:29,problemName:"Implement parent index functions for a *MinHeap* class.",problemText:"Implement the following methods for the *MinHeap* data structure:  \n   - **getParentIndex** (childIndex: integer) => integer  \n   - **hasParent** (childIndex: integer) => boolean  \n   - **parent** (childIndex: integer) => heap value  \n",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"getParentIndex - 1",inherit:[1],code:"",evaluate:"minheap.getParentIndex(1);",expected:0},{id:3,name:"getParentIndex - 2",inherit:[1],code:"",evaluate:"minheap.getParentIndex(2);",expected:0},{id:4,name:"getParentIndex - 3",inherit:[1],code:"",evaluate:"minheap.getParentIndex(5);",expected:2},{id:5,name:"getParentIndex - 4",inherit:[1],code:"",evaluate:"minheap.getParentIndex(6);",expected:2},{id:6,name:"getParentIndex - 5",inherit:[1],code:"",evaluate:"minheap.getParentIndex(7);",expected:3},{id:7,name:"hasParent - 1",inherit:[1],code:"",evaluate:"minheap.hasParent(0);",expected:!1},{id:8,name:"hasParent - 2",inherit:[1],code:"",evaluate:"minheap.hasParent(1);",expected:!0},{id:9,name:"parent - 1",inherit:[1],code:"minheap.heapContainer = [1,4,5,8,10,12,16];",evaluate:"minheap.parent(1);",expected:1},{id:10,name:"parent - 2",inherit:[1,9],code:"",evaluate:"minheap.parent(2);",expected:1},{id:11,name:"parent - 3",inherit:[1,9],code:"",evaluate:"minheap.parent(3);",expected:4},{id:12,name:"parent - 4",inherit:[1,9],code:"",evaluate:"minheap.parent(4);",expected:4},{id:13,name:"parent - 5",inherit:[1,9],code:"",evaluate:"minheap.parent(5);",expected:5},{id:14,name:"parent - 6",inherit:[1,9],code:"",evaluate:"minheap.parent(6);",expected:5}],setupCode:"",category:x,type:d,difficulty:h,maxExecutionTime:2,solution:{stages:[0,30,60,90,150],solutionLines:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  getParentIndex(childIndex) {"},{stage:2,text:"    return Math.floor((childIndex - 1) / 2);"},{stage:1,text:"  }"},{stage:2,text:""},{stage:1,text:"  hasParent(childIndex) {"},{stage:3,text:"    return this.getParentIndex(childIndex) >= 0;"},{stage:1,text:"  }"},{stage:3,text:""},{stage:1,text:"  parent(childIndex) {"},{stage:4,text:"    return this.heapContainer[this.getParentIndex(childIndex)];"},{stage:1,text:"  }"},{stage:4,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},W={problemID:30,problemName:"Implement the **peek** method for a *MinHeap* class.",problemText:"Implement a **peek** method that will return the value of the first (next-up) item in a *MinHeap*.  Return `null` instead if there are no items in the heap.",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"null if no values in heap",inherit:[1],code:"minheap.heapContainer = [];",evaluate:"minheap.peek();",expected:null},{id:3,name:"first value - 1",inherit:[1],code:"minheap.heapContainer = [5];",evaluate:"minheap.peek();",expected:5},{id:4,name:"first value - 2",inherit:[1],code:"minheap.heapContainer = [3,7];",evaluate:"minheap.peek();",expected:3}],setupCode:"",category:x,type:d,difficulty:c,maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  peek() {"},{stage:2,text:"    if (this.heapContainer.length === 0) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:3,text:"    return this.heapContainer[0];"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},F={problemID:31,problemName:"Implement the **find** method for a *MinHeap* class.",problemText:"Implement a **find** method for a *MinHeap* that accepts a parameter `item` and returns an array of indices where matching items are found in the *MinHeap*.",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"empty heap",inherit:[1],code:"",evaluate:"minheap.find(5);",expected:JSON.stringify([])},{id:3,name:"one item heap, no match",inherit:[1],code:"minheap.heapContainer = [4];",evaluate:"minheap.find(5);",expected:JSON.stringify([])},{id:4,name:"one item heap, match",inherit:[1],code:"minheap.heapContainer = [4];",evaluate:"minheap.find(4);",expected:JSON.stringify([0])},{id:5,name:"multi-item heap, no match",inherit:[1],code:"minheap.heapContainer = [4,6,8,10,12];",evaluate:"minheap.find(7);",expected:JSON.stringify([])},{id:6,name:"multi-item heap, one match",inherit:[1],code:"minheap.heapContainer = [4,6,8,10,12];",evaluate:"minheap.find(8);",expected:JSON.stringify([2])},{id:7,name:"multi-item heap, multiple matches",inherit:[1],code:"minheap.heapContainer = [4,6,8,8,8,10,12];",evaluate:"minheap.find(8);",expected:JSON.stringify([2,3,4])}],setupCode:"",category:x,type:d,difficulty:h,maxExecutionTime:2,solution:{stages:[0,30,60,90,150],solutionLines:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  find(item) {"},{stage:2,text:"    const foundItemIndices = [];"},{stage:3,text:"    for (let itemIndex = 0; itemIndex < this.heapContainer.length; itemIndex += 1) {"},{stage:4,text:"      if (item === this.heapContainer[itemIndex]) {"},{stage:4,text:"        foundItemIndices.push(itemIndex);"},{stage:4,text:"      }"},{stage:3,text:"    }"},{stage:2,text:"    return foundItemIndices;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},U={problemID:32,problemName:"Implement **poll** for a *MinHeap* class.",problemText:"Implement a **poll** method for a *MinHeap* to remove and return the item at the top of the heap.  If the heap is empty, return `null`.",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"empty list",inherit:[1],code:"",evaluate:"minheap.poll();",expected:null},{id:3,name:"list, return top item",inherit:[1],code:"minheap.heapContainer = [1,2,4,6,3,5,6,10,8,7];",evaluate:"minheap.poll();",expected:1},{id:4,name:"list, correct 2nd item",inherit:[1,3],code:"minheap.poll();",evaluate:"minheap.poll();",expected:2},{id:5,name:"list, correct 3rd item",inherit:[1,3,4],code:"minheap.poll();",evaluate:"minheap.poll();",expected:3},{id:6,name:"list, correct 4th item",inherit:[1,3,4,5],code:"minheap.poll();",evaluate:"minheap.poll();",expected:4},{id:7,name:"list, correct 5th item",inherit:[1,3,4,5,6],code:"minheap.poll();",evaluate:"minheap.poll();",expected:5}],setupCode:"\n  MinHeap.prototype.getLeftChildIndex = function(parentIndex) {\n    return 2 * parentIndex + 1;\n  };\n  MinHeap.prototype.getRightChildIndex = function(parentIndex) {\n    return 2 * parentIndex + 2;\n  };\n  MinHeap.prototype.hasLeftChild = function(parentIndex) {\n    return this.getLeftChildIndex(parentIndex) < this.heapContainer.length;\n  };\n  MinHeap.prototype.hasRightChild = function(parentIndex) {\n    return this.getRightChildIndex(parentIndex) < this.heapContainer.length;\n  };\n  MinHeap.prototype.leftChild = function(parentIndex) {\n    return this.heapContainer[this.getLeftChildIndex(parentIndex)];\n  };\n  MinHeap.prototype.rightChild = function(parentIndex) {\n    return this.heapContainer[this.getRightChildIndex(parentIndex)];\n  };\n  MinHeap.prototype.heapifyDown = function (customStartIndex = 0) {\n    let currentIndex = customStartIndex;\n    let nextIndex = null;\n    while (this.hasLeftChild(currentIndex)) {\n      if (\n        this.hasRightChild(currentIndex) &&\n        this.rightChild(currentIndex) <= this.leftChild(currentIndex)\n      ) {\n        nextIndex = this.getRightChildIndex(currentIndex);\n      } else {\n        nextIndex = this.getLeftChildIndex(currentIndex);\n      }\n      if (this.heapContainer[currentIndex] <= this.heapContainer[nextIndex]) {\n        break;\n      }\n      this.swap(currentIndex, nextIndex);\n      currentIndex = nextIndex;\n    }\n  };\n  MinHeap.prototype.swap = function (indexOne, indexTwo) {\n    const tmp = this.heapContainer[indexTwo];\n    this.heapContainer[indexTwo] = this.heapContainer[indexOne];\n    this.heapContainer[indexOne] = tmp;\n  };\n  ",category:x,type:d,difficulty:h,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED:  heapifyDown(startIndex: int = 0)"},{stage:0,text:""},{stage:1,text:"  poll() {"},{stage:2,text:"    if (this.heapContainer.length === 0) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:3,text:""},{stage:3,text:"    if (this.heapContainer.length === 1) {"},{stage:3,text:"      return this.heapContainer.pop();"},{stage:3,text:"    }"},{stage:4,text:""},{stage:4,text:"    const item = this.heapContainer[0];"},{stage:4,text:""},{stage:5,text:"    this.heapContainer[0] = this.heapContainer.pop();"},{stage:5,text:"    this.heapifyDown();"},{stage:4,text:"    return item;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},z={problemID:33,problemName:"Implement **add** for a *MinHeap* class.",problemText:"Implement an **add** method for a *MinHeap* to receive an `item` (integer) and add it to the heap.  The method should then return the heap.",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"add item to empty heap",inherit:[1],code:"minheap.add(5);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([5])},{id:3,name:"add 2nd item to heap",inherit:[1,2],code:"minheap.add(6);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([5,6])},{id:4,name:"add 3rd item to heap",inherit:[1,2,3],code:"minheap.add(3);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([3,6,5])},{id:5,name:"add 4th item to heap",inherit:[1,2,3,4],code:"minheap.add(8);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([3,6,5,8])},{id:6,name:"add 5th item to heap",inherit:[1,2,3,4,5],code:"minheap.add(1);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,3,5,8,6])},{id:7,name:"add 6th item to heap",inherit:[1,2,3,4,5,6],code:"minheap.add(4);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,3,4,8,6,5])},{id:8,name:"add 7th item to heap",inherit:[1,2,3,4,5,6,7],code:"minheap.add(2);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,3,2,8,6,5,4])},{id:9,name:"method should return itself",inherit:[1,2,3,4,5,6,7],code:"",evaluate:"minheap.add(2) === minheap",expected:!0}],setupCode:"\n  MinHeap.prototype.getParentIndex = function (childIndex) {\n    return Math.floor((childIndex - 1) / 2);\n  };\n  MinHeap.prototype.hasParent = function (childIndex) {\n    return this.getParentIndex(childIndex) >= 0;\n  };\n  MinHeap.prototype.parent = function (childIndex) {\n    return this.heapContainer[this.getParentIndex(childIndex)];\n  };\n  MinHeap.prototype.heapifyUp = function (customStartIndex) {\n    let currentIndex = customStartIndex || this.heapContainer.length - 1;\n    while (\n      this.hasParent(currentIndex) &&\n      this.parent(currentIndex) > this.heapContainer[currentIndex]\n    ) {\n      this.swap(currentIndex, this.getParentIndex(currentIndex));\n      currentIndex = this.getParentIndex(currentIndex);\n    }\n  };\n  MinHeap.prototype.swap = function (indexOne, indexTwo) {\n    const tmp = this.heapContainer[indexTwo];\n    this.heapContainer[indexTwo] = this.heapContainer[indexOne];\n    this.heapContainer[indexOne] = tmp;\n  };\n  ",category:x,type:d,difficulty:c,maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED:  heapifyUp()"},{stage:0,text:""},{stage:1,text:"  add(item) {"},{stage:2,text:"    this.heapContainer.push(item);"},{stage:3,text:"    this.heapifyUp();"},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},_={problemID:34,problemName:"Implement **remove** for a *MinHeap* class.",problemText:"Implement a **remove** method for a *MinHeap* to receive an `item` (integer) and remove all instances of that item from the heap.  The method should then return the heap.\n  \n  (note: remove duplicate items from back to front)",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"remove from empty heap, remains empty heap",inherit:[1],code:"",evaluate:"minheap.remove(5);JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([])},{id:3,name:"remove from empty heap, returns empty heap",inherit:[1],code:"",evaluate:"minheap.remove(5) === minheap;",expected:!0},{id:4,name:"remove one from one item heap, heap becomes empty",inherit:[1],code:"minheap.heapContainer = [5];minheap.remove(5);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([])},{id:5,name:"remove one from two item heap, one item remains",inherit:[1],code:"minheap.heapContainer = [5,6];minheap.remove(5);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([6])},{id:6,name:"remove value from two item heap where value is duplicated",inherit:[1],code:"minheap.heapContainer = [5,5];minheap.remove(5);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([])},{id:7,name:"complex example",inherit:[1],code:"minheap.heapContainer = [1,2,4,6,3,5,6,10,8,7];minheap.remove(5).remove(6);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,2,4,10,3,7,8])}],setupCode:"\n  MinHeap.prototype.getParentIndex = function (childIndex) {\n    return Math.floor((childIndex - 1) / 2);\n  };\n  MinHeap.prototype.hasParent = function (childIndex) {\n    return this.getParentIndex(childIndex) >= 0;\n  };\n  MinHeap.prototype.parent = function (childIndex) {\n    return this.heapContainer[this.getParentIndex(childIndex)];\n  };\n  MinHeap.prototype.getLeftChildIndex = function(parentIndex) {\n    return 2 * parentIndex + 1;\n  };\n  MinHeap.prototype.getRightChildIndex = function(parentIndex) {\n    return 2 * parentIndex + 2;\n  };\n  MinHeap.prototype.hasLeftChild = function(parentIndex) {\n    return this.getLeftChildIndex(parentIndex) < this.heapContainer.length;\n  };\n  MinHeap.prototype.hasRightChild = function(parentIndex) {\n    return this.getRightChildIndex(parentIndex) < this.heapContainer.length;\n  };\n  MinHeap.prototype.leftChild = function(parentIndex) {\n    return this.heapContainer[this.getLeftChildIndex(parentIndex)];\n  };\n  MinHeap.prototype.rightChild = function(parentIndex) {\n    return this.heapContainer[this.getRightChildIndex(parentIndex)];\n  };\n  MinHeap.prototype.find = function (item) {\n    const foundItemIndices = [];\n    for (let itemIndex = 0; itemIndex < this.heapContainer.length; itemIndex += 1) {\n      if (item === this.heapContainer[itemIndex]) {\n        foundItemIndices.push(itemIndex);\n      }\n    }\n    return foundItemIndices;\n  };\n  MinHeap.prototype.heapifyUp = function (customStartIndex) {\n    let currentIndex = customStartIndex || this.heapContainer.length - 1;\n    while (\n      this.hasParent(currentIndex) &&\n      this.parent(currentIndex) > this.heapContainer[currentIndex]\n    ) {\n      this.swap(currentIndex, this.getParentIndex(currentIndex));\n      currentIndex = this.getParentIndex(currentIndex);\n    }\n  };\n  MinHeap.prototype.heapifyDown = function (customStartIndex = 0) {\n    let currentIndex = customStartIndex;\n    let nextIndex = null;\n    while (this.hasLeftChild(currentIndex)) {\n      if (\n        this.hasRightChild(currentIndex) &&\n        this.rightChild(currentIndex) <= this.leftChild(currentIndex)\n      ) {\n        nextIndex = this.getRightChildIndex(currentIndex);\n      } else {\n        nextIndex = this.getLeftChildIndex(currentIndex);\n      }\n      if (this.heapContainer[currentIndex] <= this.heapContainer[nextIndex]) {\n        break;\n      }\n      this.swap(currentIndex, nextIndex);\n      currentIndex = nextIndex;\n    }\n  };\n  MinHeap.prototype.swap = function (indexOne, indexTwo) {\n    const tmp = this.heapContainer[indexTwo];\n    this.heapContainer[indexTwo] = this.heapContainer[indexOne];\n    this.heapContainer[indexOne] = tmp;\n  };\n  ",category:x,type:d,difficulty:u,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,210,270],solutionLines:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED:  heapifyUp(index: int)"},{stage:-1,text:"// IMPLEMENTED:  heapifyDown(index: int)"},{stage:-1,text:"// IMPLEMENTED:  find(item: int) []index:int"},{stage:-1,text:"// IMPLEMENTED:  parent(index: int) item:int"},{stage:-1,text:"// IMPLEMENTED:  hasLeftChild(index: int) bool"},{stage:0,text:""},{stage:1,text:"  remove(item) {"},{stage:2,text:"    const numberOfItemsToRemove = this.find(item).length;"},{stage:2,text:""},{stage:3,text:"    for (let iteration = 0; iteration < numberOfItemsToRemove; iteration += 1) {"},{stage:4,text:"      const indexToRemove = this.find(item).pop();"},{stage:4,text:"      if (indexToRemove === this.heapContainer.length - 1) {"},{stage:5,text:"        this.heapContainer.pop();"},{stage:4,text:"      } else {"},{stage:5,text:"        this.heapContainer[indexToRemove] = this.heapContainer.pop();"},{stage:5,text:"        const parentItem = this.parent(indexToRemove);"},{stage:6,text:""},{stage:6,text:"        if ("},{stage:6,text:"          this.hasLeftChild(indexToRemove) &&"},{stage:6,text:"          (!parentItem || parentItem <= this.heapContainer[indexToRemove])"},{stage:6,text:"        ) {"},{stage:7,text:"          this.heapifyDown(indexToRemove);"},{stage:6,text:"        } else {"},{stage:8,text:"          this.heapifyUp(indexToRemove);"},{stage:6,text:"        }"},{stage:4,text:"      }"},{stage:3,text:"    }"},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},Q={problemID:35,problemName:"Implement **heapifyUp** for a *MinHeap* class.",problemText:"Implement a **heapifyUp** method for a *MinHeap* to take an array item at a specified `index` (the last index in the array by default) and move it up to the correct placement in the heap.",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"heapifyUp on one item heap, remains same",inherit:[1],code:"minheap.heapContainer = [5];minheap.heapifyUp();",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([5])},{id:3,name:"heapifyUp on two item heap",inherit:[1],code:"minheap.heapContainer = [5,4];minheap.heapifyUp(1);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([4,5])},{id:4,name:"heapifyUp on three item heap",inherit:[1],code:"minheap.heapContainer = [5,6,4];minheap.heapifyUp(2);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([4,6,5])},{id:5,name:"heapifyUp on four item heap",inherit:[1],code:"minheap.heapContainer = [4,6,5,3];minheap.heapifyUp(3);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([3,4,5,6])},{id:6,name:"heapifyUp on complex heap",inherit:[1],code:"minheap.heapContainer = [2,3,5,7,4,6,7,11,9,8,1];minheap.heapifyUp(10);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,2,5,7,3,6,7,11,9,8,4])},{id:7,name:"by default, works on last item in heap",inherit:[1],code:"minheap.heapContainer = [2,3,5,7,4,6,7,11,9,8,1];minheap.heapifyUp();",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,2,5,7,3,6,7,11,9,8,4])}],setupCode:"\n  MinHeap.prototype.getParentIndex = function (childIndex) {\n    return Math.floor((childIndex - 1) / 2);\n  };\n  MinHeap.prototype.hasParent = function (childIndex) {\n    return this.getParentIndex(childIndex) >= 0;\n  };\n  MinHeap.prototype.parent = function (childIndex) {\n    return this.heapContainer[this.getParentIndex(childIndex)];\n  };\n  MinHeap.prototype.swap = function (indexOne, indexTwo) {\n    const tmp = this.heapContainer[indexTwo];\n    this.heapContainer[indexTwo] = this.heapContainer[indexOne];\n    this.heapContainer[indexOne] = tmp;\n  };\n  ",category:x,type:d,difficulty:u,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED:  swap(index1: int, index2: int)"},{stage:-1,text:"// IMPLEMENTED:  getParentIndex(index: int) int"},{stage:-1,text:"// IMPLEMENTED:  hasParent(index: int) bool"},{stage:-1,text:"// IMPLEMENTED:  parent(index: int) int"},{stage:0,text:""},{stage:1,text:"  heapifyUp(customStartIndex) {"},{stage:2,text:"    let currentIndex = customStartIndex || this.heapContainer.length - 1;"},{stage:2,text:""},{stage:3,text:"    while ("},{stage:3,text:"      this.hasParent(currentIndex) &&"},{stage:3,text:"      (this.parent(currentIndex) > this.heapContainer[currentIndex])"},{stage:3,text:"    ) {"},{stage:4,text:"      this.swap(currentIndex, this.getParentIndex(currentIndex));"},{stage:5,text:"      currentIndex = this.getParentIndex(currentIndex);"},{stage:3,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},Y={problemID:36,problemName:"Implement **heapifyDown** for a *MinHeap* class.",problemText:"Implement a **heapifyDown** method for a *MinHeap* to take an array item at a specified `index` (the first item in the array by default) and move it down to the correct placement in the heap.",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"one item in heap, heap is same",inherit:[1],code:"minheap.heapContainer = [1];  minheap.heapifyDown();",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1])},{id:3,name:"two items in heap, no change",inherit:[1],code:"minheap.heapContainer = [1,2];  minheap.heapifyDown();",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,2])},{id:4,name:"two items in heap, reorder",inherit:[1],code:"minheap.heapContainer = [2,1];  minheap.heapifyDown();",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,2])},{id:5,name:"five items in heap, reorder",inherit:[1],code:"minheap.heapContainer = [5,1,2,3,4];  minheap.heapifyDown();",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,3,2,5,4])},{id:6,name:"five items in heap, specific index",inherit:[1],code:"minheap.heapContainer = [1,5,2,3,4];  minheap.heapifyDown(1);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,3,2,5,4])}],setupCode:"\n  MinHeap.prototype.getLeftChildIndex = function(parentIndex) {\n    return 2 * parentIndex + 1;\n  };\n  MinHeap.prototype.getRightChildIndex = function(parentIndex) {\n    return 2 * parentIndex + 2;\n  };\n  MinHeap.prototype.hasLeftChild = function(parentIndex) {\n    return this.getLeftChildIndex(parentIndex) < this.heapContainer.length;\n  };\n  MinHeap.prototype.hasRightChild = function(parentIndex) {\n    return this.getRightChildIndex(parentIndex) < this.heapContainer.length;\n  };\n  MinHeap.prototype.leftChild = function(parentIndex) {\n    return this.heapContainer[this.getLeftChildIndex(parentIndex)];\n  };\n  MinHeap.prototype.rightChild = function(parentIndex) {\n    return this.heapContainer[this.getRightChildIndex(parentIndex)];\n  };\n  MinHeap.prototype.swap = function (indexOne, indexTwo) {\n    const tmp = this.heapContainer[indexTwo];\n    this.heapContainer[indexTwo] = this.heapContainer[indexOne];\n    this.heapContainer[indexOne] = tmp;\n  };\n  ",category:x,type:d,difficulty:u,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,240],solutionLines:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED:  swap(index1: int, index2: int)"},{stage:-1,text:"// IMPLEMENTED:  getLeftChildIndex(index: int) int"},{stage:-1,text:"// IMPLEMENTED:  getRightChildIndex(index: int) int"},{stage:-1,text:"// IMPLEMENTED:  hasLeftChild(index: int) bool"},{stage:-1,text:"// IMPLEMENTED:  hasRightChild(index: int) bool"},{stage:-1,text:"// IMPLEMENTED:  getLeftChildIndex(index: int) int"},{stage:-1,text:"// IMPLEMENTED:  getrightChildIndex(index: int) int"},{stage:0,text:""},{stage:1,text:"  heapifyDown(customStartIndex = 0) {"},{stage:2,text:"    let currentIndex = customStartIndex;"},{stage:2,text:"    let nextIndex = null;"},{stage:2,text:""},{stage:3,text:"    while (this.hasLeftChild(currentIndex)) {"},{stage:4,text:"      if ("},{stage:4,text:"        this.hasRightChild(currentIndex) &&"},{stage:4,text:"        this.rightChild(currentIndex) <= this.leftChild(currentIndex)"},{stage:4,text:"      ) {"},{stage:5,text:"        nextIndex = this.getRightChildIndex(currentIndex);"},{stage:4,text:"      } else {"},{stage:5,text:"        nextIndex = this.getLeftChildIndex(currentIndex);"},{stage:4,text:"      }"},{stage:5,text:""},{stage:6,text:"      if (this.heapContainer[currentIndex] <= this.heapContainer[nextIndex]) {"},{stage:6,text:"        break;"},{stage:6,text:"      }"},{stage:6,text:""},{stage:7,text:"      this.swap(currentIndex, nextIndex);"},{stage:7,text:"      currentIndex = nextIndex;"},{stage:3,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},X={problemID:37,problemName:"Implement **insert** in a *BinarySearchTree* class.",problemText:"Write an **insert** method in a *BinarySearchTree* class that accepts a `value` (integer) and inserts it at the proper place in the tree.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"Insert value into empty tree.",inherit:[1],code:"tree.insert(5);",evaluate:"tree.root.value;",expected:5},{id:3,name:"Insert 2nd value.",inherit:[1,2],code:"tree.insert(7);",evaluate:"tree.root.right.value;",expected:7},{id:4,name:"Insert 3rd value.",inherit:[1,2,3],code:"tree.insert(6);",evaluate:"tree.root.right.left.value;",expected:6},{id:5,name:"Insert 4th value.",inherit:[1,2,3,4],code:"tree.insert(1);",evaluate:"tree.root.left.value;",expected:1},{id:6,name:"Insert 5th value.",inherit:[1,2,3,4,5],code:"tree.insert(2);",evaluate:"tree.root.left.right.value;",expected:2}],setupCode:"",category:"Binary Search Tree",type:d,difficulty:u,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,210,240,300],solutionLines:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  insert(value) {"},{stage:2,text:"    const thisNode = new BinarySearchTreeNode(value);"},{stage:3,text:"    if (!this.root) {"},{stage:4,text:"      this.root = thisNode;"},{stage:3,text:"    } else {"},{stage:4,text:"      let currentRoot = this.root;"},{stage:4,text:"      while (true) {"},{stage:5,text:"        if (currentRoot.value > value) {"},{stage:6,text:"          if (currentRoot.left != null) {"},{stage:7,text:"            currentRoot = currentRoot.left;"},{stage:6,text:"          } else {"},{stage:7,text:"            currentRoot.left = thisNode;"},{stage:7,text:"            break;"},{stage:6,text:"          }"},{stage:5,text:"        } else if (currentRoot.value < value) {"},{stage:8,text:"          if (currentRoot.right != null) {"},{stage:9,text:"            currentRoot = currentRoot.right;"},{stage:8,text:"          } else {"},{stage:9,text:"            currentRoot.right = thisNode;"},{stage:9,text:"            break;"},{stage:8,text:"          }"},{stage:5,text:"        } else {"},{stage:9,text:"          break;"},{stage:5,text:"        }"},{stage:4,text:"      }"},{stage:3,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},Z={problemID:38,problemName:"Implement **search** in a *BinarySearchTree* class.",problemText:"Write a **search** method in a *BinarySearchTree* class that accepts a `value` (integer) and returns a boolean `true` or `false` indicating whether that integer is found within the tree.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"search an empty tree returns false",inherit:[1],code:"",evaluate:"tree.search(5);",expected:!1},{id:3,name:"search a tree finds value",inherit:[1],code:"tree.insert(5);",evaluate:"tree.search(5);",expected:!0},{id:4,name:"search a tree does not find value",inherit:[1],code:"tree.insert(5);",evaluate:"tree.search(2);",expected:!1},{id:5,name:"complex tree, found (1)",inherit:[1],code:"tree.insert(5);tree.insert(7);tree.insert(6);tree.insert(1);tree.insert(2);",evaluate:"tree.search(6);",expected:!0},{id:6,name:"complex tree, found (2)",inherit:[1,5],code:"",evaluate:"tree.search(1);",expected:!0},{id:7,name:"complex tree, not found (1)",inherit:[1,5],code:"",evaluate:"tree.search(8);",expected:!1},{id:8,name:"complex tree, not found (2)",inherit:[1,5],code:"",evaluate:"tree.search(4);",expected:!1}],setupCode:"\n  BinarySearchTree.prototype.insert = function(value) {\n    const thisNode = new BinarySearchTreeNode(value);\n    if (!this.root) {\n      this.root = thisNode;\n    } else {\n      let currentRoot = this.root;\n      while (true) {\n        if (currentRoot.value > value) {\n          if (currentRoot.left != null) {\n            currentRoot = currentRoot.left;\n          } else {\n            currentRoot.left = thisNode;\n            break;\n          }\n        } else if (currentRoot.value < value) {\n          if (currentRoot.right != null) {\n            currentRoot = currentRoot.right;\n          } else {\n            currentRoot.right = thisNode;\n            break;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n  };\n  ",category:"Binary Search Tree",type:d,difficulty:h,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,210],solutionLines:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  search(value) {"},{stage:2,text:"    let currentRoot = this.root;"},{stage:2,text:"    let found = false;"},{stage:3,text:"    while (currentRoot) {"},{stage:4,text:"      if (currentRoot.value > value) {"},{stage:5,text:"        currentRoot = currentRoot.left;"},{stage:4,text:"      } else if (currentRoot.value < value) {"},{stage:5,text:"        currentRoot = currentRoot.right;"},{stage:4,text:"      } else {"},{stage:6,text:"        found = true;"},{stage:6,text:"        break;"},{stage:4,text:"      }"},{stage:3,text:"    }"},{stage:3,text:"    return found;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},$={problemID:39,problemName:"Implement **delete** in a *BinarySearchTree* class.",problemText:"Write a **delete** method in a *BinarySearchTree* class that accepts an integer `value` and deletes it from a tree, while maintaining a valid Binary Search Tree structure.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"delete on empty tree, no crash",inherit:[1],code:"tree.delete(5);",evaluate:"Boolean(tree);",expected:!0},{id:3,name:"insert an item into tree.  delete it. find it.",inherit:[1],code:"tree.insert(5);tree.delete(5);",evaluate:"tree.search(5);",expected:!1},{id:4,name:"insert two items into tree.  delete one. find the other.",inherit:[1],code:"tree.insert(5);tree.insert(6);tree.delete(5);",evaluate:"tree.search(6);",expected:!0},{id:5,name:"find the deleted of task #4.",inherit:[1,4],code:"",evaluate:"tree.search(5);",expected:!1}],setupCode:"\n  BinarySearchTree.prototype.insert = function(value) {\n    const thisNode = new BinarySearchTreeNode(value);\n    if (!this.root) {\n      this.root = thisNode;\n    } else {\n      let currentRoot = this.root;\n      while (true) {\n        if (currentRoot.value > value) {\n          if (currentRoot.left != null) {\n            currentRoot = currentRoot.left;\n          } else {\n            currentRoot.left = thisNode;\n            break;\n          }\n        } else if (currentRoot.value < value) {\n          if (currentRoot.right != null) {\n            currentRoot = currentRoot.right;\n          } else {\n            currentRoot.right = thisNode;\n            break;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n  };\n  BinarySearchTree.prototype.search = function(value) {\n    let currentRoot = this.root;\n    let found = false;\n    while (currentRoot) {\n      if (currentRoot.value > value) {\n        currentRoot = currentRoot.left;\n      } else if (currentRoot.value < value) {\n        currentRoot = currentRoot.right;\n      } else {\n        found = true;\n        break;\n      }\n    }\n    return found;\n  };\n  ",category:"Binary Search Tree",type:d,difficulty:u,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,210,240,270,330],solutionLines:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  delete(value) {"},{stage:2,text:"    this.root = deleteRecursively(this.root, value);"},{stage:2,text:""},{stage:2,text:"    function deleteRecursively(root, value) {"},{stage:3,text:"      if (!root) {"},{stage:4,text:"        return null;"},{stage:3,text:"      } else if (value < root.value) {"},{stage:4,text:"        root.left = deleteRecursively(root.left, value);"},{stage:3,text:"      } else if (value > root.value) {"},{stage:5,text:"        root.right = deleteRecursively(root.right, value);"},{stage:3,text:"      } else {"},{stage:6,text:"        if (!root.left && !root.right) {"},{stage:7,text:"          return null;"},{stage:6,text:"        } else if (!root.left) {"},{stage:7,text:"          root = root.right;"},{stage:7,text:"          return root;"},{stage:6,text:"        } else if (!root.right) {"},{stage:8,text:"          root = root.left;"},{stage:8,text:"          return root;"},{stage:6,text:"        } else {"},{stage:8,text:"          const temp = findMin(root.right);"},{stage:10,text:"          root.value = temp.value;"},{stage:10,text:"          root.right = deleteRecursively(root.right, temp.value);"},{stage:10,text:"          return root;"},{stage:6,text:"        }"},{stage:3,text:"      }"},{stage:5,text:"      return root;"},{stage:2,text:"    }"},{stage:9,text:""},{stage:8,text:"    function findMin(root) {"},{stage:9,text:"      while (root.left) {"},{stage:9,text:"        root = root.left;"},{stage:9,text:"      }"},{stage:9,text:"      return root;"},{stage:8,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},ee={problemID:40,problemName:"Implement **traversePreOrderIterative** in a *BinarySearchTree* class.",problemText:"Write a **traversePreOrderIterative** method in a *BinarySearchTree* Class that traverses a tree iteratively and runs the supplied `callback` function on each node value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"proper pre-order ranking",inherit:[1],code:"tree.insert(5);tree.insert(3);tree.insert(11);tree.insert(0);tree.insert(7);tree.insert(2);tree.traversePreOrderIterative();",evaluate:"JSON.stringify(tree.tempNodeList);",expected:JSON.stringify([5,3,0,2,11,7])}],setupCode:"\n  BinarySearchTree.prototype.tempNodeList = [];\n  BinarySearchTree.prototype.callback = function (value) {\n    BinarySearchTree.prototype.tempNodeList.push(value);\n  };\n  BinarySearchTree.prototype.clearTempNodeList = function (value) {\n    BinarySearchTree.prototype.tempNodeList = [];\n  };\n  BinarySearchTree.prototype.insert = function(value) {\n    const thisNode = new BinarySearchTreeNode(value);\n    if (!this.root) {\n      this.root = thisNode;\n    } else {\n      let currentRoot = this.root;\n      while (true) {\n        if (currentRoot.value > value) {\n          if (currentRoot.left != null) {\n            currentRoot = currentRoot.left;\n          } else {\n            currentRoot.left = thisNode;\n            break;\n          }\n        } else if (currentRoot.value < value) {\n          if (currentRoot.right != null) {\n            currentRoot = currentRoot.right;\n          } else {\n            currentRoot.right = thisNode;\n            break;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n  };\n  ",category:"Binary Search Tree",type:d,difficulty:u,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED  callback(value)"},{stage:-1,text:""},{stage:0,text:"  traversePreOrderIterative(node = this.root, callback = this.callback) {"},{stage:1,text:"    const nodeStack = [];"},{stage:1,text:"    nodeStack.push(node);"},{stage:1,text:""},{stage:2,text:"    while (nodeStack.length) {"},{stage:3,text:"      let next = nodeStack.pop();"},{stage:3,text:"      callback(next.value);"},{stage:4,text:"      if (next.right) {"},{stage:4,text:"        nodeStack.push(next.right);"},{stage:4,text:"      }"},{stage:5,text:"      if (next.left) {"},{stage:5,text:"        nodeStack.push(next.left);"},{stage:5,text:"      }"},{stage:2,text:"    }"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},te={problemID:41,problemName:"Implement **traversePreOrderRecursive** in a *BinarySearchTree* class.",problemText:"Write a **traversePreOrderRecursive** method in a *BinarySearchTree* class that traverses a tree recursively and runs the supplied `callback` function on each node value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"proper pre-order ranking",inherit:[1],code:"tree.insert(5);tree.insert(3);tree.insert(11);tree.insert(0);tree.insert(7);tree.insert(2);tree.traversePreOrderRecursive();",evaluate:"JSON.stringify(tree.tempNodeList);",expected:JSON.stringify([5,3,0,2,11,7])}],setupCode:"\n  BinarySearchTree.prototype.tempNodeList = [];\n  BinarySearchTree.prototype.callback = function (value) {\n    BinarySearchTree.prototype.tempNodeList.push(value);\n  };\n  BinarySearchTree.prototype.clearTempNodeList = function (value) {\n    BinarySearchTree.prototype.tempNodeList = [];\n  };\n  BinarySearchTree.prototype.insert = function(value) {\n    const thisNode = new BinarySearchTreeNode(value);\n    if (!this.root) {\n      this.root = thisNode;\n    } else {\n      let currentRoot = this.root;\n      while (true) {\n        if (currentRoot.value > value) {\n          if (currentRoot.left != null) {\n            currentRoot = currentRoot.left;\n          } else {\n            currentRoot.left = thisNode;\n            break;\n          }\n        } else if (currentRoot.value < value) {\n          if (currentRoot.right != null) {\n            currentRoot = currentRoot.right;\n          } else {\n            currentRoot.right = thisNode;\n            break;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n  };\n  ",category:"Binary Search Tree",type:d,difficulty:c,maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED  callback(value)"},{stage:-1,text:""},{stage:0,text:"  traversePreOrderRecursive(node = this.root, callback = this.callback) {"},{stage:1,text:"    if (!node) {"},{stage:1,text:"      return;"},{stage:0,text:"    }"},{stage:2,text:"    callback(node.value);"},{stage:3,text:"    this.traversePreOrderRecursive(node.left);"},{stage:3,text:"    this.traversePreOrderRecursive(node.right);"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},ae={problemID:42,problemName:"Implement **traverseInOrderIterative** in a *BinarySearchTree* class.",problemText:"Write a **traverseInOrderIterative** method in a *BinarySearchTree* class that traverses a tree iteratively and runs the supplied `callback` function on each node value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"proper in-order ranking",inherit:[1],code:"tree.insert(5);tree.insert(3);tree.insert(11);tree.insert(0);tree.insert(7);tree.insert(2);tree.traverseInOrderIterative();",evaluate:"JSON.stringify(tree.tempNodeList);",expected:JSON.stringify([0,2,3,5,7,11])}],setupCode:"\n  BinarySearchTree.prototype.tempNodeList = [];\n  BinarySearchTree.prototype.callback = function (value) {\n    BinarySearchTree.prototype.tempNodeList.push(value);\n  };\n  BinarySearchTree.prototype.clearTempNodeList = function (value) {\n    BinarySearchTree.prototype.tempNodeList = [];\n  };\n  BinarySearchTree.prototype.insert = function(value) {\n    const thisNode = new BinarySearchTreeNode(value);\n    if (!this.root) {\n      this.root = thisNode;\n    } else {\n      let currentRoot = this.root;\n      while (true) {\n        if (currentRoot.value > value) {\n          if (currentRoot.left != null) {\n            currentRoot = currentRoot.left;\n          } else {\n            currentRoot.left = thisNode;\n            break;\n          }\n        } else if (currentRoot.value < value) {\n          if (currentRoot.right != null) {\n            currentRoot = currentRoot.right;\n          } else {\n            currentRoot.right = thisNode;\n            break;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n  };\n  ",category:"Binary Search Tree",type:d,difficulty:u,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,240],solutionLines:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED  callback(value)"},{stage:-1,text:""},{stage:0,text:"  traverseInOrderIterative(node = this.root, callback = this.callback) {"},{stage:1,text:"    let stack = [];"},{stage:1,text:"    let done = false;"},{stage:1,text:""},{stage:2,text:"    while (!done) {"},{stage:3,text:"      if (node != null) {"},{stage:4,text:"        stack.push(node);"},{stage:4,text:"        node = node.left;"},{stage:3,text:"      } else {"},{stage:5,text:"        if (stack.length) {"},{stage:6,text:"          node = stack.pop();"},{stage:6,text:"          callback(node.value);"},{stage:7,text:"          node = node.right;"},{stage:5,text:"        } else {"},{stage:7,text:"          done = true;"},{stage:5,text:"        }"},{stage:3,text:"      }"},{stage:2,text:"    }"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},ne={problemID:43,problemName:"Implement **traverseInOrderRecursive** in a *BinarySearchTree* class.",problemText:"Write a **traverseInOrderRecursive** method in a *BinarySearchTree* class that traverses a tree recursively and runs the supplied `callback` function on each node value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"proper in-order ranking",inherit:[1],code:"tree.insert(5);tree.insert(3);tree.insert(11);tree.insert(0);tree.insert(7);tree.insert(2);tree.traverseInOrderRecursive();",evaluate:"JSON.stringify(tree.tempNodeList);",expected:JSON.stringify([0,2,3,5,7,11])}],setupCode:"\n  BinarySearchTree.prototype.tempNodeList = [];\n  BinarySearchTree.prototype.callback = function (value) {\n    BinarySearchTree.prototype.tempNodeList.push(value);\n  };\n  BinarySearchTree.prototype.clearTempNodeList = function (value) {\n    BinarySearchTree.prototype.tempNodeList = [];\n  };\n  BinarySearchTree.prototype.insert = function(value) {\n    const thisNode = new BinarySearchTreeNode(value);\n    if (!this.root) {\n      this.root = thisNode;\n    } else {\n      let currentRoot = this.root;\n      while (true) {\n        if (currentRoot.value > value) {\n          if (currentRoot.left != null) {\n            currentRoot = currentRoot.left;\n          } else {\n            currentRoot.left = thisNode;\n            break;\n          }\n        } else if (currentRoot.value < value) {\n          if (currentRoot.right != null) {\n            currentRoot = currentRoot.right;\n          } else {\n            currentRoot.right = thisNode;\n            break;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n  };\n  ",category:"Binary Search Tree",type:d,difficulty:c,maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED  callback(value)"},{stage:-1,text:""},{stage:0,text:"  traverseInOrderRecursive(node = this.root, callback = this.callback) {"},{stage:1,text:"    if (!node) {"},{stage:1,text:"      return;"},{stage:0,text:"    }"},{stage:2,text:"    this.traverseInOrderRecursive(node.left);"},{stage:2,text:"    callback(node.value);"},{stage:3,text:"    this.traverseInOrderRecursive(node.right);"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},se={problemID:44,problemName:"Implement **traversePostOrderIterative** in a *BinarySearchTree* class.",problemText:"Write a **traversePostOrderIterative** method in a *BinarySearchTree* class that traverses a tree iteratively and runs the supplied `callback` function on each node value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"proper post-order ranking",inherit:[1],code:"tree.insert(5);tree.insert(3);tree.insert(11);tree.insert(0);tree.insert(7);tree.insert(2);tree.traversePostOrderIterative();",evaluate:"JSON.stringify(tree.tempNodeList);",expected:JSON.stringify([2,0,3,7,11,5])}],setupCode:"\n  BinarySearchTree.prototype.tempNodeList = [];\n  BinarySearchTree.prototype.callback = function (value) {\n    BinarySearchTree.prototype.tempNodeList.push(value);\n  };\n  BinarySearchTree.prototype.clearTempNodeList = function (value) {\n    BinarySearchTree.prototype.tempNodeList = [];\n  };\n  BinarySearchTree.prototype.insert = function(value) {\n    const thisNode = new BinarySearchTreeNode(value);\n    if (!this.root) {\n      this.root = thisNode;\n    } else {\n      let currentRoot = this.root;\n      while (true) {\n        if (currentRoot.value > value) {\n          if (currentRoot.left != null) {\n            currentRoot = currentRoot.left;\n          } else {\n            currentRoot.left = thisNode;\n            break;\n          }\n        } else if (currentRoot.value < value) {\n          if (currentRoot.right != null) {\n            currentRoot = currentRoot.right;\n          } else {\n            currentRoot.right = thisNode;\n            break;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n  };\n  ",category:"Binary Search Tree",type:d,difficulty:u,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,240],solutionLines:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED  callback(value)"},{stage:-1,text:""},{stage:0,text:"  traversePostOrderIterative(node = this.root, callback = this.callback) {"},{stage:1,text:"    const s1 = [];"},{stage:1,text:"    const s2 = [];"},{stage:1,text:"    s1.push(node);"},{stage:1,text:""},{stage:2,text:"    while (s1.length) {"},{stage:3,text:"      const next = s1.pop();"},{stage:3,text:"      s2.push(next);"},{stage:3,text:""},{stage:4,text:"      if (next.left) {"},{stage:4,text:"        s1.push(next.left);"},{stage:4,text:"      }"},{stage:5,text:"      if (next.right) {"},{stage:5,text:"        s1.push(next.right);"},{stage:5,text:"      }"},{stage:2,text:"    }"},{stage:6,text:"    while (s2.length) {"},{stage:7,text:"      const next = s2.pop();"},{stage:7,text:"      callback(next.value);"},{stage:6,text:"    }"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},ie={problemID:45,problemName:"Implement **traversePostOrderRecursive** in a *BinarySearchTree* class.",problemText:"Write a **traversePostOrderRecursive** method in a *BinarySearchTree* class that traverses a tree recursively and runs the supplied `callback` function on each node value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"proper post-order ranking",inherit:[1],code:"tree.insert(5);tree.insert(3);tree.insert(11);tree.insert(0);tree.insert(7);tree.insert(2);tree.traversePostOrderRecursive();",evaluate:"JSON.stringify(tree.tempNodeList);",expected:JSON.stringify([2,0,3,7,11,5])}],setupCode:"\n  BinarySearchTree.prototype.tempNodeList = [];\n  BinarySearchTree.prototype.callback = function (value) {\n    BinarySearchTree.prototype.tempNodeList.push(value);\n  };\n  BinarySearchTree.prototype.clearTempNodeList = function (value) {\n    BinarySearchTree.prototype.tempNodeList = [];\n  };\n  BinarySearchTree.prototype.insert = function(value) {\n    const thisNode = new BinarySearchTreeNode(value);\n    if (!this.root) {\n      this.root = thisNode;\n    } else {\n      let currentRoot = this.root;\n      while (true) {\n        if (currentRoot.value > value) {\n          if (currentRoot.left != null) {\n            currentRoot = currentRoot.left;\n          } else {\n            currentRoot.left = thisNode;\n            break;\n          }\n        } else if (currentRoot.value < value) {\n          if (currentRoot.right != null) {\n            currentRoot = currentRoot.right;\n          } else {\n            currentRoot.right = thisNode;\n            break;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n  };\n  ",category:"Binary Search Tree",type:d,difficulty:c,maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED  callback(value)"},{stage:-1,text:""},{stage:0,text:"  traversePostOrderRecursive(node = this.root, callback = this.callback) {"},{stage:1,text:"    if (node.left) {"},{stage:1,text:"      this.traversePostOrderRecursive(node.left);"},{stage:1,text:"    }"},{stage:2,text:"    if (node.right) {"},{stage:2,text:"      this.traversePostOrderRecursive(node.right);"},{stage:2,text:"    }"},{stage:0,text:""},{stage:3,text:"    callback(node.value);"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},re={problemID:46,problemName:"Implement a **traverseLevelOrderBfs** method in a *BinarySearchTree* class.",problemText:"Write a **traverseLevelOrderBfs** method in a *BinarySearchTree* class that traverses a tree iteratively and runs the supplied `callback` function on each node value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"proper bfs",inherit:[1],code:"tree.insert(5);tree.insert(3);tree.insert(11);tree.insert(0);tree.insert(7);tree.insert(2);tree.traverseLevelOrderBfs();",evaluate:"JSON.stringify(tree.tempNodeList);",expected:JSON.stringify([5,3,11,0,7,2])}],setupCode:"\n  BinarySearchTree.prototype.tempNodeList = [];\n  BinarySearchTree.prototype.callback = function (value) {\n    BinarySearchTree.prototype.tempNodeList.push(value);\n  };\n  BinarySearchTree.prototype.clearTempNodeList = function (value) {\n    BinarySearchTree.prototype.tempNodeList = [];\n  };\n  BinarySearchTree.prototype.insert = function(value) {\n    const thisNode = new BinarySearchTreeNode(value);\n    if (!this.root) {\n      this.root = thisNode;\n    } else {\n      let currentRoot = this.root;\n      while (true) {\n        if (currentRoot.value > value) {\n          if (currentRoot.left != null) {\n            currentRoot = currentRoot.left;\n          } else {\n            currentRoot.left = thisNode;\n            break;\n          }\n        } else if (currentRoot.value < value) {\n          if (currentRoot.right != null) {\n            currentRoot = currentRoot.right;\n          } else {\n            currentRoot.right = thisNode;\n            break;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n  };\n  ",category:"Binary Search Tree",type:d,difficulty:h,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150],solutionLines:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  traverseLevelOrderBfs(node = this.root, callback = this.callback) {"},{stage:1,text:"    const queue = [];"},{stage:1,text:"    if (!node) {"},{stage:1,text:"      return;"},{stage:1,text:"    }"},{stage:2,text:"    queue.push(node);"},{stage:0,text:""},{stage:2,text:"    while (queue.length) {"},{stage:3,text:"      const temp = queue.shift();"},{stage:3,text:"      callback(temp.value);"},{stage:4,text:"      if (temp.left) {"},{stage:4,text:"        queue.push(temp.left);"},{stage:4,text:"      }"},{stage:5,text:"      if (temp.right) {"},{stage:5,text:"        queue.push(temp.right);"},{stage:5,text:"      }"},{stage:2,text:"    }"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},le={problemID:47,problemName:"Implement the **addVertex** method for a *Graph* class.",problemText:"Implement an **addVertex** method that accepts a string `vertexKey` key, with no return value.  \n  Implementation involves:\n   - Create a Vertex node, and add it to the `vertices` lookup.\n   - Create a blank object entry in the adjacencyList `adjList` if there is not an existing entry for that node.",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"add single vertex, check vertices inventory",inherit:[1],code:"graph.addVertex('A');",evaluate:"graph.vertices['A'].key;",expected:"A"},{id:3,name:"adds single vertex, check adjacency list",inherit:[1,2],code:"",evaluate:"JSON.stringify(graph.adjList['A']);",expected:JSON.stringify({})},{id:4,name:"if already exists, do not clear place in adjacency list",inherit:[1,2],code:"graph.addVertex('B');graph.addEdge('A','B');graph.addVertex('A');",evaluate:"JSON.stringify(graph.adjList['A']) !== JSON.stringify({});",expected:!0}],setupCode:"\n  Graph.prototype.addEdge = function(startVertexKey, endVertexKey, edgeWeight = 1) {\n    if (!this.vertices[startVertexKey]) {\n      this.addVertex(startVertexKey);\n    }\n    if (!this.vertices[endVertexKey]) {\n      this.addVertex(endVertexKey);\n    }\n    const edge = new Edge(edgeWeight);\n    this.adjList[startVertexKey][endVertexKey] = edge;\n    if (!this.isDirected) {\n      this.adjList[endVertexKey][startVertexKey] = edge;\n    }\n  };\n  ",category:g,type:d,difficulty:c,maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:'    this.vertices = {};  // { "vertexKey": Vertex }'},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  addVertex(vertexKey) {"},{stage:2,text:"    const vertex = new Vertex(vertexKey);"},{stage:2,text:"    this.vertices[vertexKey] = vertex;"},{stage:2,text:""},{stage:3,text:"    if (!this.adjList[vertexKey]) {"},{stage:3,text:"      this.adjList[vertexKey] = {};"},{stage:3,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},oe={problemID:48,problemName:"Implement the **addEdge** method for a *Graph* class.",problemText:"Implement an **addEdge** method that accepts a `startingVertex` key (string) and an `endingVertex` key (string) and an optional `edgeWeight` (int, defaults to 1), with no return value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"creates vertices if they do not exist - start",inherit:[1],code:"graph.addEdge('A', 'B', 2);",evaluate:"Boolean(graph.vertices['A']);",expected:!0},{id:3,name:"creates vertices if they do not exist - end",inherit:[1,2],code:"",evaluate:"Boolean(graph.vertices['B']);",expected:!0},{id:4,name:"sets the proper edge weight",inherit:[1,2],code:"",evaluate:"graph.adjList['A']['B'].weight;",expected:2},{id:5,name:"defaults to 1 if edge weight is not given",inherit:[1],code:"graph.addEdge('A', 'B');",evaluate:"graph.adjList['A']['B'].weight;",expected:1},{id:6,name:"creates reverse path if not a directed network",inherit:[],code:"const graph=new Graph(false);graph.addEdge('A', 'B', 2);",evaluate:"graph.adjList['B']['A'].weight;",expected:2}],setupCode:"\n  Graph.prototype.addVertex = function (key) {\n    const vertex = new Vertex(key);\n    this.vertices[key] = vertex;\n    if (!this.adjList[key]) {\n      this.adjList[key] = {};\n    }\n  };\n  ",category:g,type:d,difficulty:h,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED: addVertex(key: string) void"},{stage:-1,text:""},{stage:1,text:"  addEdge(startVertexKey, endVertexKey, edgeWeight = 1) {"},{stage:2,text:"    if (!this.vertices[startVertexKey]) {"},{stage:2,text:"      this.addVertex(startVertexKey);"},{stage:2,text:"    }"},{stage:2,text:""},{stage:3,text:"    if (!this.vertices[endVertexKey]) {"},{stage:3,text:"      this.addVertex(endVertexKey);"},{stage:3,text:"    }"},{stage:3,text:""},{stage:4,text:"    const edge = new Edge(edgeWeight);"},{stage:4,text:""},{stage:4,text:"    this.adjList[startVertexKey][endVertexKey] = edge;"},{stage:4,text:""},{stage:5,text:"    if (!this.isDirected) {"},{stage:5,text:"      this.adjList[endVertexKey][startVertexKey] = edge;"},{stage:5,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},de={problemID:49,problemName:"Implement the **deleteVertex** method for a *Graph* class.",problemText:"Implement a **deleteVertex** method that accepts a `vertexKey` (string), with no return value.  You must delete all items in the adjacency list which use that vertex.",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"add, then delete vertex",inherit:[1],code:"graph.addVertex('A');graph.deleteVertex('A');",evaluate:"Boolean(graph.vertices['A']);",expected:!1},{id:3,name:"add edge, make sure vertex is deleted from AdjList",inherit:[1],code:"graph.addEdge('A','B');graph.deleteVertex('A');",evaluate:"graph.adjList['A'] === undefined;",expected:!0},{id:4,name:"removed from reverse side of AdjList",inherit:[],code:"const graph=new Graph(false);graph.addEdge('A','B');graph.deleteVertex('A');",evaluate:"JSON.stringify(graph.adjList['B']);",expected:JSON.stringify({})}],setupCode:"\n  Graph.prototype.addVertex = function(key) {\n    const vertex = new Vertex(key);\n    this.vertices[key] = vertex;\n    if (!this.adjList[key]) {\n      this.adjList[key] = {};\n    }\n  };\n  Graph.prototype.addEdge = function(startVertexKey, endVertexKey, edgeWeight = 1) {\n    if (!this.vertices[startVertexKey]) {\n      this.addVertex(startVertexKey);\n    }\n    if (!this.vertices[endVertexKey]) {\n      this.addVertex(endVertexKey);\n    }\n    const edge = new Edge(edgeWeight);\n    this.adjList[startVertexKey][endVertexKey] = edge;\n    if (!this.isDirected) {\n      this.adjList[endVertexKey][startVertexKey] = edge;\n    }\n  };\n  ",category:g,type:d,difficulty:h,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  deleteVertex(vertexKey) {"},{stage:2,text:"    delete this.vertices[vertexKey];"},{stage:2,text:"    delete this.adjList[vertexKey];"},{stage:3,text:"    for (let key of Object.keys(this.adjList)) {"},{stage:4,text:"      for (let vk of Object.keys(this.adjList[key])) {"},{stage:5,text:"        if (vk === vertexKey) {"},{stage:5,text:"          delete this.adjList[key][vk];"},{stage:5,text:"        }"},{stage:4,text:"      }"},{stage:3,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},ce={problemID:50,problemName:"Implement the **deleteEdge** method for a *Graph* class.",problemText:"Implement a **deleteEdge** method that accepts a `startingVertex` key (string) and an `endingVertex` key (string), with no return value.  Account for directed and undirected graphs.",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"add edge, then delete. Check edge.",inherit:[1],code:"graph.addEdge('A', 'B');graph.deleteEdge('A', 'B');",evaluate:"Boolean(graph.adjList['A'] && graph.adjList['A']['B']);",expected:!1},{id:3,name:"add edge, then delete. Check reverse edge on undirected graph.",inherit:[],code:"const graph=new Graph(false);graph.addEdge('A', 'B');graph.deleteEdge('A', 'B');",evaluate:"Boolean(graph.adjList['B'] && graph.adjList['B']['A']);",expected:!1},{id:4,name:"trying to delete edge that does not exist should not throw error.",inherit:[],code:"const graph=new Graph();",evaluate:"graph.deleteEdge('A', 'B');",expected:void 0},{id:5,name:"trying to delete reverse edge that does not exist should not throw error.",inherit:[],code:"const graph=new Graph(false);",evaluate:"graph.deleteEdge('A', 'B');",expected:void 0}],setupCode:"\n  Graph.prototype.addVertex = function(key) {\n    const vertex = new Vertex(key);\n    this.vertices[key] = vertex;\n    if (!this.adjList[key]) {\n      this.adjList[key] = {};\n    }\n  };\n  Graph.prototype.addEdge = function(startVertexKey, endVertexKey, edgeWeight = 1) {\n    if (!this.vertices[startVertexKey]) {\n      this.addVertex(startVertexKey);\n    }\n    if (!this.vertices[endVertexKey]) {\n      this.addVertex(endVertexKey);\n    }\n    const edge = new Edge(edgeWeight);\n    this.adjList[startVertexKey][endVertexKey] = edge;\n    if (!this.isDirected) {\n      this.adjList[endVertexKey][startVertexKey] = edge;\n    }\n  };\n  ",category:g,type:d,difficulty:c,maxExecutionTime:2,solution:{stages:[0,30,60,120],solutionLines:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  deleteEdge(startVertexKey, endVertexKey) {"},{stage:2,text:"    if (this.adjList[startVertexKey]) {"},{stage:2,text:"      delete this.adjList[startVertexKey][endVertexKey];"},{stage:2,text:"    }"},{stage:2,text:""},{stage:3,text:"    if (!this.isDirected && this.adjList[endVertexKey]) {"},{stage:3,text:"      delete this.adjList[endVertexKey][startVertexKey];"},{stage:3,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},he={problemID:51,problemName:"Implement a recursive **dfs** (depth first search) method for a *Graph* class.",problemText:"Implement a **dfs** method that accepts a `startingVertex` key (string) and a `callback` function (supplied) to be run on each graph node.  **Use recursion!**",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"dfs network 1",inherit:[1],code:"graph.addEdge('42', '41');graph.addEdge('42', '50');graph.addEdge('41', '10');graph.addEdge('41', '40');graph.addEdge('50', '45');graph.addEdge('50', '75');graph.dfs('42');",evaluate:"JSON.stringify(graph.tempSet);",expected:JSON.stringify(["42","41","10","40","50","45","75"])},{id:3,name:"dfs network 2",inherit:[1],code:"graph.addEdge('A', 'B');graph.addEdge('B', 'C');graph.addEdge('B', 'E');graph.addEdge('C', 'D');graph.addEdge('D', 'G');graph.addEdge('D', 'F');graph.addEdge('G', 'H');graph.addEdge('F', 'J');graph.dfs('A');",evaluate:"JSON.stringify(graph.tempSet);",expected:JSON.stringify(["A","B","C","D","G","H","F","J","E"])}],setupCode:"\n  Graph.prototype.tempSet = [];\n  Graph.prototype.callback = function(key) {\n    Graph.prototype.tempSet.push(key);\n  };\n  Graph.prototype.addVertex = function(key) {\n    const vertex = new Vertex(key);\n    this.vertices[key] = vertex;\n    if (!this.adjList[key]) {\n      this.adjList[key] = {};\n    }\n  };\n  Graph.prototype.addEdge = function(startVertexKey, endVertexKey, edgeWeight = 1) {\n    if (!this.vertices[startVertexKey]) {\n      this.addVertex(startVertexKey);\n    }\n    if (!this.vertices[endVertexKey]) {\n      this.addVertex(endVertexKey);\n    }\n\n    const edge = new Edge(edgeWeight);\n\n    this.adjList[startVertexKey][endVertexKey] = edge;\n\n    if (!this.isDirected) {\n      this.adjList[endVertexKey][startVertexKey] = edge;\n    }\n  };\n  ",category:g,type:d,difficulty:u,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,210],solutionLines:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED: callback(vertex: Vertex) void"},{stage:-1,text:""},{stage:0,text:"  dfs(startVertexKey, callback = this.callback) {"},{stage:1,text:"    const visited = {};"},{stage:0,text:""},{stage:2,text:"    const traverseDfs = vertex => {"},{stage:3,text:"      visited[vertex] = true;"},{stage:3,text:"      callback(vertex);"},{stage:4,text:"      for (let adjacent of Object.keys(this.adjList[vertex] || [])) {"},{stage:5,text:"        if (!visited[adjacent]) {"},{stage:5,text:"          traverseDfs(adjacent);"},{stage:5,text:"        }"},{stage:4,text:"      }"},{stage:2,text:"    };"},{stage:6,text:""},{stage:6,text:"    traverseDfs(startVertexKey);"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},ue={problemID:56,problemName:"Implement an iterative **dfs** (depth first search) method for a *Graph* class.",problemText:"Implement a **dfs** method that accepts a `startingVertex` key (string) and a `callback` function (supplied) to be run on each graph node.  **Implement iteratively!**",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"dfs network 1",inherit:[1],code:"graph.addEdge('42', '41');graph.addEdge('42', '50');graph.addEdge('41', '10');graph.addEdge('41', '40');graph.addEdge('50', '45');graph.addEdge('50', '75');graph.dfs('42');",evaluate:"JSON.stringify(graph.tempSet);",expected:JSON.stringify(["42","50","75","45","41","40","10"])},{id:3,name:"dfs network 2",inherit:[1],code:"graph.addEdge('A', 'B');graph.addEdge('B', 'C');graph.addEdge('B', 'E');graph.addEdge('C', 'D');graph.addEdge('D', 'G');graph.addEdge('D', 'F');graph.addEdge('G', 'H');graph.addEdge('F', 'J');graph.dfs('A');",evaluate:"JSON.stringify(graph.tempSet);",expected:JSON.stringify(["A","B","E","C","D","F","J","G","H"])}],setupCode:"\n  Graph.prototype.tempSet = [];\n  Graph.prototype.callback = function(key) {\n    Graph.prototype.tempSet.push(key);\n  };\n  Graph.prototype.addVertex = function(key) {\n    const vertex = new Vertex(key);\n    this.vertices[key] = vertex;\n    if (!this.adjList[key]) {\n      this.adjList[key] = {};\n    }\n  };\n  Graph.prototype.addEdge = function(startVertexKey, endVertexKey, edgeWeight = 1) {\n    if (!this.vertices[startVertexKey]) {\n      this.addVertex(startVertexKey);\n    }\n    if (!this.vertices[endVertexKey]) {\n      this.addVertex(endVertexKey);\n    }\n\n    const edge = new Edge(edgeWeight);\n\n    this.adjList[startVertexKey][endVertexKey] = edge;\n\n    if (!this.isDirected) {\n      this.adjList[endVertexKey][startVertexKey] = edge;\n    }\n  };\n  ",category:g,type:d,difficulty:u,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED: callback(vertex: Vertex) void"},{stage:-1,text:""},{stage:0,text:"  dfs(startVertexKey, callback = this.callback) {"},{stage:1,text:"    const stack = [];"},{stage:1,text:"    const visited = {};"},{stage:1,text:"    stack.push(startVertexKey);"},{stage:0,text:""},{stage:2,text:"    while (stack.length) {"},{stage:3,text:"      const vertexKey = stack.pop();"},{stage:3,text:"      if (!visited[vertexKey]) {"},{stage:4,text:"        callback(vertexKey);"},{stage:4,text:"        visited[vertexKey] = true;"},{stage:5,text:"        for (let adjacent of Object.keys(this.adjList[vertexKey] || {})) {"},{stage:5,text:"          stack.push(adjacent);"},{stage:5,text:"        }"},{stage:3,text:"      }"},{stage:2,text:"    }"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},xe={1:p,2:m,3:y,4:f,5:v,6:k,7:b,8:L,9:N,10:w,11:E,12:I,13:C,14:T,15:S,16:R,17:O,18:B,19:D,20:j,21:H,22:V,23:A,24:M,25:K,26:q,27:P,28:J,29:G,30:W,31:F,32:U,33:z,34:_,35:Q,36:Y,37:X,38:Z,39:$,40:ee,41:te,42:ae,43:ne,44:se,45:ie,46:re,47:le,48:oe,49:de,50:ce,51:he,52:{problemID:52,problemName:"Implement a **bfs** (breadth first search) method for a *Graph* class.",problemText:"Implement a **bfs** method that accepts a `startingVertex` key (string) and a `callback` function (supplied) to be run on each graph node.",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"bfs network 1",inherit:[1],code:"graph.addEdge('42', '41');graph.addEdge('42', '50');graph.addEdge('41', '10');graph.addEdge('41', '40');graph.addEdge('50', '45');graph.addEdge('50', '75');graph.bfs('42');",evaluate:"JSON.stringify(graph.tempSet);",expected:JSON.stringify(["42","41","50","10","40","45","75"])},{id:3,name:"bfs network 2",inherit:[1],code:"graph.addEdge('A', 'B');graph.addEdge('B', 'C');graph.addEdge('B', 'E');graph.addEdge('C', 'D');graph.addEdge('D', 'G');graph.addEdge('D', 'F');graph.addEdge('G', 'H');graph.addEdge('F', 'J');graph.bfs('A');",evaluate:"JSON.stringify(graph.tempSet);",expected:JSON.stringify(["A","B","C","E","D","G","F","H","J"])}],setupCode:"\n  Graph.prototype.tempSet = [];\n  Graph.prototype.callback = function(key) {\n    Graph.prototype.tempSet.push(key);\n  };\n  Graph.prototype.addVertex = function(key) {\n    const vertex = new Vertex(key);\n    this.vertices[key] = vertex;\n    if (!this.adjList[key]) {\n      this.adjList[key] = {};\n    }\n  };\n  Graph.prototype.addEdge = function(startVertexKey, endVertexKey, edgeWeight = 1) {\n    if (!this.vertices[startVertexKey]) {\n      this.addVertex(startVertexKey);\n    }\n    if (!this.vertices[endVertexKey]) {\n      this.addVertex(endVertexKey);\n    }\n\n    const edge = new Edge(edgeWeight);\n\n    this.adjList[startVertexKey][endVertexKey] = edge;\n\n    if (!this.isDirected) {\n      this.adjList[endVertexKey][startVertexKey] = edge;\n    }\n  };\n  ",category:g,type:d,difficulty:u,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED: callback(vertex: Vertex) void"},{stage:-1,text:""},{stage:0,text:"  bfs(startVertexKey, callback = this.callback) {"},{stage:1,text:"    const queue = [];"},{stage:1,text:"    const visited = {};"},{stage:1,text:"    queue.push(startVertexKey);"},{stage:1,text:""},{stage:2,text:"    while (queue.length) {"},{stage:3,text:"      const vertexKey = queue.shift();"},{stage:3,text:"      if (!visited[vertexKey]) {"},{stage:4,text:"        callback(vertexKey);"},{stage:4,text:"        visited[vertexKey] = true;"},{stage:5,text:"        for (let adjacent of Object.keys(this.adjList[vertexKey] || {})) {"},{stage:5,text:"          queue.push(adjacent);"},{stage:5,text:"        }"},{stage:3,text:"      }"},{stage:2,text:"    }"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},53:{problemID:53,problemName:"Implement the **insert** method for a *Trie* class.",problemText:"Implement an **insert** method that takes a `word` (string) as a parameter, with no return value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const trie=new Trie();",evaluate:"Boolean(trie);",expected:!0},{id:2,name:"insert word, search true",inherit:[1],code:"trie.insert('daniel');",evaluate:"trie.search('daniel');",expected:!0},{id:3,name:"insert word, search half of that word.  return false",inherit:[1,2],code:"",evaluate:"trie.search('dan');",expected:!1}],setupCode:"\n  Trie.prototype.search = function(word) {\n    let current = this.root;\n    for (let i = 0; i < word.length; i++) {\n      const ch = word.charAt(i);\n      const node = current.children[ch];\n      if (node == null) {\n        return false;\n      }\n      current = node;\n    }\n    return current.endOfWord;\n  };\n  ",category:"Trie",type:d,difficulty:h,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,210],solutionLines:[{stage:0,text:"class TrieNode {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.children = {};"},{stage:0,text:"    this.endOfWord = false;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Trie {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = new TrieNode();"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  insert(word) {"},{stage:2,text:"    let current = this.root;"},{stage:2,text:"    for (let i = 0; i < word.length; i++) {"},{stage:3,text:"      const ch = word.charAt(i);"},{stage:3,text:"      let node = current.children[ch];"},{stage:4,text:"      if (node == null) {"},{stage:5,text:"        node = new TrieNode();"},{stage:5,text:"        current.children[ch] = node;"},{stage:4,text:"      }"},{stage:6,text:"      current = node;"},{stage:2,text:"    }"},{stage:6,text:"    current.endOfWord = true;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},54:{problemID:54,problemName:"Implement the **search** method for a *Trie* class.",problemText:"Implement a **search** method that takes in a `word` (string) and returns a boolean `true` or `false` depending on if it can be found in the Trie.",testCases:[{id:1,name:"compiles",inherit:[],code:"const trie=new Trie();",evaluate:"Boolean(trie);",expected:!0},{id:2,name:"nothing in trie should return false on search",inherit:[1],code:"",evaluate:"trie.search('');",expected:!1},{id:3,name:"insert word, search true",inherit:[1],code:"trie.insert('daniel');",evaluate:"trie.search('daniel');",expected:!0},{id:4,name:"insert word, search half of that word.  return false",inherit:[1,3],code:"",evaluate:"trie.search('dan');",expected:!1}],setupCode:"\n  Trie.prototype.insert = function(word) {\n    let current = this.root;\n    for (let i = 0; i < word.length; i++) {\n      const ch = word.charAt(i);\n      let node = current.children[ch];\n      if (node == null) {\n        node = new TrieNode();\n        current.children[ch] = node;\n      }\n      current = node;\n    }\n    current.endOfWord = true;\n  };\n  ",category:"Trie",type:d,difficulty:h,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:0,text:"class TrieNode {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.children = {};"},{stage:0,text:"    this.endOfWord = false;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Trie {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = new TrieNode();"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  search(word) {"},{stage:2,text:"    let current = this.root;"},{stage:2,text:"    for (let i = 0; i < word.length; i++) {"},{stage:3,text:"      const ch = word.charAt(i);"},{stage:3,text:"      const node = current.children[ch];"},{stage:4,text:"      if (node == null) {"},{stage:4,text:"        return false;"},{stage:4,text:"      }"},{stage:5,text:"      current = node;"},{stage:2,text:"    }"},{stage:5,text:"    return current.endOfWord;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},55:{problemID:55,problemName:"Implement the **delete** method for a *Trie* class.",problemText:"Implement a **delete** method that takes in a `word` (string) and removes it from the Trie.",testCases:[{id:1,name:"compiles",inherit:[],code:"const trie=new Trie();",evaluate:"Boolean(trie);",expected:!0},{id:2,name:"insert, delete.  search is false.",inherit:[1],code:"trie.insert('daniel');trie.insert('david');trie.delete('daniel');",evaluate:"trie.search('daniel');",expected:!1},{id:3,name:"insert, delete.  search for non-deleted is true.",inherit:[1,2],code:"",evaluate:"trie.search('david');",expected:!0},{id:4,name:"delete remaining word.  search should be false.",inherit:[1,2],code:"trie.delete('david');",evaluate:"trie.search('david');",expected:!1}],setupCode:"\n  Trie.prototype.insert = function(word) {\n    let current = this.root;\n    for (let i = 0; i < word.length; i++) {\n      const ch = word.charAt(i);\n      let node = current.children[ch];\n      if (node == null) {\n        node = new TrieNode();\n        current.children[ch] = node;\n      }\n      current = node;\n    }\n    current.endOfWord = true;\n  };\n  Trie.prototype.search = function(word) {\n    let current = this.root;\n    for (let i = 0; i < word.length; i++) {\n      const ch = word.charAt(i);\n      const node = current.children[ch];\n      if (node == null) {\n        return false;\n      }\n      current = node;\n    }\n    return current.endOfWord;\n  };\n  ",category:"Trie",type:d,difficulty:u,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,210,240,300],solutionLines:[{stage:0,text:"class TrieNode {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.children = {};"},{stage:0,text:"    this.endOfWord = false;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Trie {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = new TrieNode();"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  delete(word) {"},{stage:2,text:"    deleteRecursively(this.root, word, 0);"},{stage:2,text:""},{stage:2,text:"    function deleteRecursively(current, word, index) {"},{stage:3,text:"      if (index === word.length) {"},{stage:4,text:"        if (!current.endOfWord) {"},{stage:4,text:"          return false;"},{stage:4,text:"        }"},{stage:5,text:"        current.endOfWord = false;"},{stage:5,text:"        return Object.keys(current.children).length === 0;"},{stage:3,text:"      }"},{stage:6,text:"      const ch = word.charAt(index);"},{stage:6,text:"      const node = current.children[ch];"},{stage:7,text:"      if (node == null) {"},{stage:7,text:"        return false;"},{stage:7,text:"      }"},{stage:8,text:"      const shouldDelete = deleteRecursively(node, word, index + 1);"},{stage:8,text:"      if (shouldDelete) {"},{stage:9,text:"        delete current.children[ch];"},{stage:9,text:"        return Object.keys(current.children).length === 0;"},{stage:8,text:"      }"},{stage:9,text:"      return false;"},{stage:2,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},56:ue,57:{problemID:57,problemName:"Implement a **detectCycle** method for a *Graph* class.",problemText:"Implement a **detectCycle** method that returns either `true` or `false` depending upon whether or not the graph contains a cycle.",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"detectCycle 1 - false",inherit:[1],code:"graph.addEdge('42', '41');graph.addEdge('42', '50');graph.addEdge('41', '10');graph.addEdge('41', '40');graph.addEdge('50', '45');graph.addEdge('50', '75');",evaluate:"graph.detectCycle();",expected:!1},{id:3,name:"detectCycle 2 - false",inherit:[1],code:"graph.addEdge('A', 'B');graph.addEdge('B', 'C');graph.addEdge('B', 'E');graph.addEdge('C', 'D');graph.addEdge('D', 'G');graph.addEdge('D', 'F');graph.addEdge('G', 'H');graph.addEdge('F', 'J');",evaluate:"graph.detectCycle();",expected:!1},{id:4,name:"detectCycle 3 - true",inherit:[1],code:"graph.addEdge('A', 'B');graph.addEdge('B', 'C');graph.addEdge('C', 'A');",evaluate:"graph.detectCycle();",expected:!0}],setupCode:"\n  Graph.prototype.tempSet = [];\n  Graph.prototype.callback = function(key) {\n    Graph.prototype.tempSet.push(key);\n  };\n  Graph.prototype.addVertex = function(key) {\n    const vertex = new Vertex(key);\n    this.vertices[key] = vertex;\n    if (!this.adjList[key]) {\n      this.adjList[key] = {};\n    }\n  };\n  Graph.prototype.addEdge = function(startVertexKey, endVertexKey, edgeWeight = 1) {\n    if (!this.vertices[startVertexKey]) {\n      this.addVertex(startVertexKey);\n    }\n    if (!this.vertices[endVertexKey]) {\n      this.addVertex(endVertexKey);\n    }\n\n    const edge = new Edge(edgeWeight);\n\n    this.adjList[startVertexKey][endVertexKey] = edge;\n\n    if (!this.isDirected) {\n      this.adjList[endVertexKey][startVertexKey] = edge;\n    }\n  };\n  ",category:g,type:d,difficulty:u,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,210,240,300],solutionLines:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  detectCycle() {"},{stage:1,text:"    let visited = {};"},{stage:1,text:"    let recNodes = {};"},{stage:0,text:""},{stage:3,text:"    for (let key of Object.keys(this.adjList)) {"},{stage:4,text:"      if (this.detectCycleRec(key, visited, recNodes)) {"},{stage:5,text:"        return true;"},{stage:4,text:"      }"},{stage:3,text:"    }"},{stage:5,text:"    return false;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:2,text:"  detectCycleRec(key, visited, recNodes) {"},{stage:3,text:"    if (!visited[key]) {"},{stage:4,text:"      visited[key] = true;"},{stage:4,text:"      recNodes[key] = true;"},{stage:0,text:""},{stage:7,text:"      for (let adjacentKey of Object.keys(this.adjList[key])) {"},{stage:8,text:"        if (!visited[adjacentKey] && this.detectCycleRec(adjacentKey, visited, recNodes)) {"},{stage:9,text:"          return true;"},{stage:8,text:"        } else if (recNodes[adjacentKey]) {"},{stage:9,text:"          return true;"},{stage:8,text:"        }"},{stage:7,text:"      }"},{stage:3,text:"    }"},{stage:0,text:""},{stage:6,text:"    recNodes[key] = false;"},{stage:6,text:"    return false;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},58:{problemID:58,problemName:"Implement a **checkPath** method for a *Graph* class.",problemText:"Implement a **checkPath** method that takes a `source` key and a `destination` key and returns either `true` or `false` depending upon whether or not the graph contains a path from one to the other.",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"path to itself always true",inherit:[1],code:"graph.addEdge('42', '41');graph.addEdge('42', '50');graph.addEdge('41', '10');graph.addEdge('41', '40');graph.addEdge('50', '45');graph.addEdge('50', '75');",evaluate:"graph.checkPath('42', '42');",expected:!0},{id:3,name:"path q1 - true",inherit:[1,2],code:"",evaluate:"graph.checkPath('42', '10');",expected:!0},{id:4,name:"path q2 - true",inherit:[1,2],code:"",evaluate:"graph.checkPath('42', '40');",expected:!0},{id:5,name:"path q3 - true",inherit:[1,2],code:"",evaluate:"graph.checkPath('42', '75');",expected:!0},{id:6,name:"path q4 - false",inherit:[1,2],code:"",evaluate:"graph.checkPath('42', '88');",expected:!1},{id:7,name:"path q5 - false",inherit:[1,2],code:"",evaluate:"graph.checkPath('50', '41');",expected:!1}],setupCode:"\n  Graph.prototype.tempSet = [];\n  Graph.prototype.callback = function(key) {\n    Graph.prototype.tempSet.push(key);\n  };\n  Graph.prototype.addVertex = function(key) {\n    const vertex = new Vertex(key);\n    this.vertices[key] = vertex;\n    if (!this.adjList[key]) {\n      this.adjList[key] = {};\n    }\n  };\n  Graph.prototype.addEdge = function(startVertexKey, endVertexKey, edgeWeight = 1) {\n    if (!this.vertices[startVertexKey]) {\n      this.addVertex(startVertexKey);\n    }\n    if (!this.vertices[endVertexKey]) {\n      this.addVertex(endVertexKey);\n    }\n\n    const edge = new Edge(edgeWeight);\n\n    this.adjList[startVertexKey][endVertexKey] = edge;\n\n    if (!this.isDirected) {\n      this.adjList[endVertexKey][startVertexKey] = edge;\n    }\n  };\n  ",category:g,type:d,difficulty:u,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,210,240,300],solutionLines:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  checkPath(source, destination) {"},{stage:1,text:"    if (source === destination) {"},{stage:1,text:"      return true;"},{stage:1,text:"    }"},{stage:0,text:""},{stage:2,text:"    const visited = {};"},{stage:2,text:"    const stack = [];"},{stage:3,text:"    stack.push(source);"},{stage:3,text:"    visited[source] = true;"},{stage:0,text:""},{stage:4,text:"    while (stack.length) {"},{stage:5,text:"      let currentKey = stack.pop();"},{stage:0,text:""},{stage:5,text:"      for (let adjacentKey of Object.keys(this.adjList[currentKey])) {"},{stage:6,text:"        if (!visited[adjacentKey]) {"},{stage:7,text:"          if (adjacentKey === destination) {"},{stage:7,text:"            return true;"},{stage:7,text:"          }"},{stage:8,text:"          stack.push(adjacentKey);"},{stage:8,text:"          visited[adjacentKey] = true;"},{stage:6,text:"        }"},{stage:5,text:"      }"},{stage:4,text:"    }"},{stage:0,text:""},{stage:9,text:"    return false;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},59:{problemID:59,problemName:"Implement a **shortestPath** method for a *Graph* class.",problemText:"Implement a **shortestPath** method that takes a `source` key and a `destination` key and returns the shortest possible distance (integer) from one to the other.  Assume all edge lengths are 1.  Return `-1` if no path exists.",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"path to itself is 0",inherit:[1],code:"graph.addEdge('42', '41');graph.addEdge('42', '50');graph.addEdge('41', '10');graph.addEdge('41', '40');graph.addEdge('50', '45');graph.addEdge('50', '75');graph.addEdge('75', '100');",evaluate:"graph.shortestPath('42', '42');",expected:0},{id:3,name:"path query 1",inherit:[1,2],code:"",evaluate:"graph.shortestPath('42', '10');",expected:2},{id:4,name:"path query 2",inherit:[1,2],code:"",evaluate:"graph.shortestPath('42', '40');",expected:2},{id:5,name:"path query 3",inherit:[1,2],code:"",evaluate:"graph.shortestPath('42', '100');",expected:3},{id:6,name:"no path returns -1",inherit:[1,2],code:"",evaluate:"graph.shortestPath('42', '1000');",expected:-1}],setupCode:"\n  Graph.prototype.tempSet = [];\n  Graph.prototype.callback = function(key) {\n    Graph.prototype.tempSet.push(key);\n  };\n  Graph.prototype.addVertex = function(key) {\n    const vertex = new Vertex(key);\n    this.vertices[key] = vertex;\n    if (!this.adjList[key]) {\n      this.adjList[key] = {};\n    }\n  };\n  Graph.prototype.addEdge = function(startVertexKey, endVertexKey, edgeWeight = 1) {\n    if (!this.vertices[startVertexKey]) {\n      this.addVertex(startVertexKey);\n    }\n    if (!this.vertices[endVertexKey]) {\n      this.addVertex(endVertexKey);\n    }\n\n    const edge = new Edge(edgeWeight);\n\n    this.adjList[startVertexKey][endVertexKey] = edge;\n\n    if (!this.isDirected) {\n      this.adjList[endVertexKey][startVertexKey] = edge;\n    }\n  };\n  ",category:g,type:d,difficulty:u,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,210,270],solutionLines:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  shortestPath(source, destination) {"},{stage:1,text:"    if (source == destination) {"},{stage:1,text:"      return 0;"},{stage:1,text:"    }"},{stage:0,text:""},{stage:2,text:"    let visited = {};"},{stage:2,text:"    let distance = {};"},{stage:2,text:"    distance[source] = 0;"},{stage:0,text:""},{stage:3,text:"    let queue = [];"},{stage:3,text:"    queue.push(source);"},{stage:0,text:""},{stage:4,text:"    while (queue.length) {"},{stage:5,text:"      const currentKey = queue.shift();"},{stage:0,text:""},{stage:5,text:"      for (let adjacentKey of Object.keys(this.adjList[currentKey])) {"},{stage:6,text:"        if (!visited[adjacentKey]) {"},{stage:8,text:"          queue.push(adjacentKey);"},{stage:8,text:"          visited[currentKey] = true;"},{stage:8,text:"          distance[adjacentKey] = distance[currentKey] + 1;"},{stage:6,text:"        }"},{stage:7,text:"        if (adjacentKey == destination) {"},{stage:7,text:"          return distance[destination];"},{stage:7,text:"        }"},{stage:5,text:"      }"},{stage:4,text:"    }"},{stage:0,text:""},{stage:7,text:"    return -1;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]}},60:{problemID:60,problemName:"Implement a recursive binary search function.",problemText:"Implement a function **binarySearchRecursive** which takes an array of sorted, unique integers `array`, and a single integer `n` and returns the index where that integer is found in the array, or `-1` if not found.\n  Please solve **recursively**.",testCases:[{id:1,name:"case 1",inherit:[],code:"const arr = [1, 2, 3, 5, 7, 8, 9, 11, 13, 15, 17, 18, 21, 24, 27, 31, 34, 38, 42, 46, 50];",evaluate:"binarySearchRecursive(arr, 8);",expected:5},{id:2,name:"case 2",inherit:[1],code:"",evaluate:"binarySearchRecursive(arr, 13);",expected:8},{id:3,name:"case 3",inherit:[1],code:"",evaluate:"binarySearchRecursive(arr, 18);",expected:11},{id:4,name:"case 4",inherit:[1],code:"",evaluate:"binarySearchRecursive(arr, 42);",expected:18},{id:5,name:"case 5",inherit:[1],code:"",evaluate:"binarySearchRecursive(arr, 6);",expected:-1}],setupCode:"",category:"Binary Search",type:"algorithm",difficulty:h,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,240],solutionLines:[{stage:0,text:""},{stage:0,text:"function binarySearchRecursive(array, n, startIndex, endIndex) {"},{stage:1,text:"  if (!startIndex) {"},{stage:1,text:"    startIndex = 0;"},{stage:1,text:"  }"},{stage:2,text:"  if (!endIndex) {"},{stage:2,text:"    endIndex = array.length - 1;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:3,text:"  let middleIndex = Math.floor((startIndex + endIndex) / 2);"},{stage:4,text:"  if (endIndex <= startIndex && array[middleIndex] !== n) {"},{stage:5,text:"    return -1;"},{stage:4,text:"  } else if (array[middleIndex] === n) {"},{stage:5,text:"    return middleIndex;"},{stage:4,text:"  } else if (array[middleIndex] < n) {"},{stage:6,text:"    return binarySearchRecursive(array, n, middleIndex + 1, endIndex);"},{stage:4,text:"  } else {"},{stage:7,text:"    return binarySearchRecursive(array, n, startIndex, middleIndex - 1);"},{stage:4,text:"  }"},{stage:0,text:"}"},{stage:0,text:""}]}},61:{problemID:61,problemName:"Implement an iterative binary search function.",problemText:"Implement a function **binarySearchIterative** which takes an array of sorted, unique integers `array`, and a single integer `n` and returns the index where that integer is found in the array, or `-1` if not found.\n  Please solve **iteratively**.",testCases:[{id:1,name:"case 1",inherit:[],code:"const arr = [1, 2, 3, 5, 7, 8, 9, 11, 13, 15, 17, 18, 21, 24, 27, 31, 34, 38, 42, 46, 50];",evaluate:"binarySearchIterative(arr, 8);",expected:5},{id:2,name:"case 2",inherit:[1],code:"",evaluate:"binarySearchIterative(arr, 13);",expected:8},{id:3,name:"case 3",inherit:[1],code:"",evaluate:"binarySearchIterative(arr, 18);",expected:11},{id:4,name:"case 4",inherit:[1],code:"",evaluate:"binarySearchIterative(arr, 42);",expected:18},{id:5,name:"case 5",inherit:[1],code:"",evaluate:"binarySearchIterative(arr, 6);",expected:-1}],setupCode:"",category:"Binary Search",type:"algorithm",difficulty:h,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,240],solutionLines:[{stage:0,text:""},{stage:0,text:"function binarySearchIterative(sortedArray, n) {"},{stage:1,text:"  let startIndex = 0;"},{stage:1,text:"  let endIndex = sortedArray.length - 1;"},{stage:0,text:""},{stage:2,text:"  while (startIndex <= endIndex) {"},{stage:3,text:"    let middleIndex = Math.floor((startIndex + endIndex) / 2);"},{stage:0,text:""},{stage:5,text:"    if (sortedArray[middleIndex] === n) {"},{stage:6,text:"      return middleIndex;"},{stage:5,text:"    } else if (sortedArray[middleIndex] < n) {"},{stage:7,text:"      startIndex = middleIndex + 1;"},{stage:5,text:"    } else {"},{stage:7,text:"      endIndex = middleIndex - 1;"},{stage:5,text:"    }"},{stage:2,text:"  }"},{stage:0,text:""},{stage:4,text:"  return -1;"},{stage:0,text:"}"},{stage:0,text:""}]}},62:{problemID:62,problemName:"Implement the quicksort algorithm.",problemText:"Implement a function **quickSort** which takes an array of unsorted integers, sorts them in place using the Quicksort algorithm and returns the array.",testCases:[{id:1,name:"case 1",inherit:[],code:"const arr = [];",evaluate:"quickSort(arr);",expected:JSON.stringify([])},{id:2,name:"case 2",inherit:[],code:"const arr = [5, 8, 1, 9, 3, 8, 2, 0, 2, 34, 2, 456, 342, 26, 75, 23];",evaluate:"quickSort(arr);",expected:JSON.stringify([0,1,2,2,2,3,5,8,8,9,23,26,34,75,342,456])},{id:3,name:"case 3",inherit:[],code:"const arr = [75, 98, 19, 99, 34, 48, 42, 40, 12, 134, 21, 1456, 3421, 1126, 1175, 2311];",evaluate:"quickSort(arr);",expected:JSON.stringify([12,19,21,34,40,42,48,75,98,99,134,1126,1175,1456,2311,3421])}],setupCode:"",category:"Sorting",type:"algorithm",difficulty:u,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,210,240,270,300,330,360,390,420,480],solutionLines:[{stage:0,text:""},{stage:0,text:"function quickSort(items) {"},{stage:0,text:""},{stage:1,text:"  return quickSortHelper(items, 0, items.length - 1);"},{stage:0,text:"}"},{stage:0,text:""},{stage:2,text:"function quickSortHelper(items, left, right) {"},{stage:3,text:"  if (items.length > 1) {"},{stage:4,text:"    const index = partition(items, left, right);"},{stage:0,text:""},{stage:5,text:"    if (left < index - 1) {"},{stage:6,text:"      quickSortHelper(items, left, index - 1);"},{stage:5,text:"    }"},{stage:0,text:""},{stage:5,text:"    if (index < right) {"},{stage:6,text:"      quickSortHelper(items, index, right);"},{stage:5,text:"    }"},{stage:3,text:"  }"},{stage:0,text:""},{stage:4,text:"  return items;"},{stage:2,text:"}"},{stage:0,text:""},{stage:7,text:"function partition(array, left, right) {"},{stage:8,text:"  const pivot = array[Math.floor((right + left) / 2)];"},{stage:9,text:"  while (left <= right) {"},{stage:10,text:"    while (pivot > array[left]) {"},{stage:11,text:"      left++;"},{stage:10,text:"    }"},{stage:10,text:"    while (pivot < array[right]) {"},{stage:11,text:"      right--;"},{stage:10,text:"    }"},{stage:0,text:""},{stage:12,text:"    if (left <= right) {"},{stage:13,text:"      const temp = array[left];"},{stage:13,text:"      array[left] = array[right];"},{stage:13,text:"      array[right] = temp;"},{stage:14,text:"      left++;"},{stage:14,text:"      right--;"},{stage:12,text:"    }"},{stage:9,text:"  }"},{stage:0,text:""},{stage:15,text:"  return left;"},{stage:7,text:"}"},{stage:0,text:""}]}},63:{problemID:63,problemName:"Implement the mergesort algorithm.",problemText:"Implement a function **mergeSort** which takes an array of unsorted integers, sorts them in place using the Mergesort algorithm and returns the array.",testCases:[{id:1,name:"case 1",inherit:[],code:"const arr = [];",evaluate:"mergeSort(arr);",expected:JSON.stringify([])},{id:2,name:"case 2",inherit:[],code:"const arr = [5, 8, 1, 9, 3, 8, 2, 0, 2, 34, 2, 456, 342, 26, 75, 23];",evaluate:"mergeSort(arr);",expected:JSON.stringify([0,1,2,2,2,3,5,8,8,9,23,26,34,75,342,456])},{id:3,name:"case 3",inherit:[],code:"const arr = [75, 98, 19, 99, 34, 48, 42, 40, 12, 134, 21, 1456, 3421, 1126, 1175, 2311];",evaluate:"mergeSort(arr);",expected:JSON.stringify([12,19,21,34,40,42,48,75,98,99,134,1126,1175,1456,2311,3421])}],setupCode:"",category:"Sorting",type:"algorithm",difficulty:u,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,210,240,270,300,360],solutionLines:[{stage:0,text:""},{stage:0,text:"function mergeSort(array) {"},{stage:1,text:"  if (array.length <= 1) {"},{stage:1,text:"    return array;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:2,text:"  const midpoint = Math.floor(array.length / 2);"},{stage:2,text:"  const leftArray = array.slice(0, midpoint);"},{stage:2,text:"  const rightArray = array.slice(midpoint);"},{stage:0,text:""},{stage:3,text:"  return merge(mergeSort(leftArray), mergeSort(rightArray));"},{stage:0,text:"}"},{stage:0,text:""},{stage:4,text:"function merge(leftArr, rightArr) {"},{stage:5,text:"  const results = [];"},{stage:5,text:"  let leftIndex = 0;"},{stage:5,text:"  let rightIndex = 0;"},{stage:0,text:""},{stage:6,text:"  while (leftIndex < leftArr.length && rightIndex < rightArr.length) {"},{stage:7,text:"    if (leftArr[leftIndex] < rightArr[rightIndex]) {"},{stage:8,text:"      results.push(leftArr[leftIndex]);"},{stage:8,text:"      leftIndex = leftIndex + 1;"},{stage:7,text:"    } else {"},{stage:9,text:"      results.push(rightArr[rightIndex]);"},{stage:9,text:"      rightIndex = rightIndex + 1;"},{stage:7,text:"    }"},{stage:6,text:"  }"},{stage:0,text:""},{stage:10,text:"  const leftRemains = leftArr.slice(leftIndex);"},{stage:10,text:"  const rightRemains = rightArr.slice(rightIndex);"},{stage:0,text:""},{stage:11,text:"  return results.concat(leftRemains).concat(rightRemains);"},{stage:4,text:"}"},{stage:0,text:""}]}},64:{problemID:64,problemName:"Solve Two Sum.",problemText:"Given an array of integers `array`, and an integer `target`, return the indices of two numbers in the `array` that sum to `target`.\n  Assume one solution.  Return indices in a two element array.  Solution can be returned in any order.\n  Return `null` if no solution could be found.",testCases:[{id:1,name:"case 1",inherit:[],code:"",evaluate:"twoSum([3, 6, 17, 12], 9);",expected:JSON.stringify([0,1])},{id:2,name:"case 2",inherit:[],code:"",evaluate:"twoSum([3, 4, 5], 9);",expected:JSON.stringify([1,2])},{id:3,name:"case 3",inherit:[],code:"",evaluate:"twoSum([2, 2], 4)",expected:JSON.stringify([0,1])},{id:4,name:"not found",inherit:[],code:"",evaluate:"twoSum([1, 3], 7) === null;",expected:!0}],setupCode:"",category:"General",type:"algorithm",difficulty:c,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,180],solutionLines:[{stage:0,text:""},{stage:0,text:"function twoSum(array, target) {"},{stage:1,text:"  let hash = {};"},{stage:0,text:""},{stage:2,text:"  for (let [index, num] of array.entries()) {"},{stage:3,text:"    const difference = target - num;"},{stage:4,text:"    if (hash[difference] !== undefined) {"},{stage:5,text:"      return [hash[difference], index];"},{stage:4,text:"    }"},{stage:5,text:"    hash[num] = index;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:1,text:"  return null;"},{stage:0,text:"}"},{stage:0,text:""}]}},65:{problemID:65,problemName:"Solve Minimum Rectangle.",problemText:"Find the area of the smallest rectangle formed by a given array of `points`.  To qualify as a rectangle, it must have sides parallel to the X and Y axis.\n  Return `0` if no solution could be found.",testCases:[{id:1,name:"no solution found",inherit:[],code:"",evaluate:"minimumRectangle([[3, 6]]);",expected:0},{id:2,name:"case 1",inherit:[],code:"",evaluate:"minimumRectangle([[2,2],[2,4],[4,2],[4,4],[3,3]]);",expected:4},{id:3,name:"case 2",inherit:[],code:"",evaluate:"minimumRectangle([[2,2],[2,4],[4,2],[4,4],[5,2],[5,4]]);",expected:2}],setupCode:"",category:"General",type:"algorithm",difficulty:u,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,210,240,270,300,360],solutionLines:[{stage:0,text:""},{stage:0,text:"function minimumRectangle(points) {"},{stage:1,text:"  const map = {};"},{stage:0,text:""},{stage:2,text:"  for (const [x, y] of points) {"},{stage:3,text:"    if (!map[x]) {"},{stage:3,text:"      map[x] = [];"},{stage:3,text:"    }"},{stage:4,text:"    map[x].push(y);"},{stage:2,text:"  }"},{stage:0,text:""},{stage:5,text:"  let min = Infinity;"},{stage:0,text:""},{stage:6,text:"  for (const [x1, y1] of points) {"},{stage:7,text:"    for (const [x2, y2] of points) {"},{stage:8,text:"      if (x1 === x2 || y1 === y2) {"},{stage:8,text:"        continue;"},{stage:8,text:"      }"},{stage:0,text:""},{stage:9,text:"      if (map[x1].includes(y2) && map[x2].includes(y1)) {"},{stage:10,text:"        min = Math.min(min, Math.abs(x1 - x2) * Math.abs(y1 - y2));"},{stage:9,text:"      }"},{stage:7,text:"    }"},{stage:6,text:"  }"},{stage:0,text:""},{stage:11,text:"  return min === Infinity ? 0 : min;"},{stage:0,text:"}"},{stage:0,text:""}]}},66:{problemID:66,problemName:"Implement an *LRUCache* class.",problemText:"Implement **get** and **put** methods for an *LRUCache* class which uses an internal *DoublyLinkList* class to store the data.  \n   - The **get** method will return a value for a given `key`, or will return `-1` if that `key` is not found in the cache.\n   - The **put** method will either modify or add a node to the top of the cache, and evict a node from the bottom of the cache if the cache exceeds capacity.\n  ",testCases:[{id:1,name:"compiles",inherit:[],code:"const cache = new LRUCache(3);",evaluate:"Boolean(cache);",expected:!0},{id:2,name:"evicts propertly",inherit:[1],code:"cache.put('a', 1);cache.put('b', 2);cache.put('c', 3);cache.put('d', 4);",evaluate:"cache.list();",expected:JSON.stringify([{key:"d",data:4},{key:"c",data:3},{key:"b",data:2}])},{id:3,name:"get returns correct item",inherit:[1,2],code:"",evaluate:"cache.get('c');",expected:3},{id:4,name:"get moves item to top of list",inherit:[1,2],code:"cache.get('c');",evaluate:"cache.list()",expected:JSON.stringify([{key:"c",data:3},{key:"d",data:4},{key:"b",data:2}])},{id:5,name:"get returns -1 when not in cache",inherit:[1],code:"cache.put('a', 1);",evaluate:"cache.get('c');",expected:-1}],setupCode:"\n  LRUCache.prototype.list = function () {\n    let arr = [];\n    let node = this.ll.head.next;\n    while (node && node.next) {\n      arr.push({ key: node.key, data: node.data });\n      node = node.next;\n    }\n    return arr;\n  };\n  ",category:"Cache",type:"algorithm",difficulty:h,maxExecutionTime:2,solution:{stages:[0,30,60,90,120,150,180,210,240,270,300,330,360,390,420,450,510],solutionLines:[{stage:0,text:""},{stage:0,text:"class Node {"},{stage:0,text:"  constructor(key, data) {"},{stage:0,text:"    this.data = data;"},{stage:0,text:"    this.key = key;"},{stage:0,text:"    this.prev = null;"},{stage:0,text:"    this.next = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = new Node('head', 0);"},{stage:0,text:"    this.tail = new Node('tail', 0);"},{stage:0,text:"    this.head.next = this.tail;"},{stage:0,text:"    this.tail.prev = this.head;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:3,text:"  detach(node) {"},{stage:4,text:"    const prev = node.prev;"},{stage:4,text:"    const next = node.next;"},{stage:4,text:"    prev.next = next;"},{stage:4,text:"    next.prev = prev;"},{stage:3,text:"  }"},{stage:0,text:""},{stage:6,text:"  addToFront(node) {"},{stage:7,text:"    const head = this.head;"},{stage:7,text:"    const hnext = head.next;"},{stage:8,text:"    head.next = node;"},{stage:8,text:"    node.next = hnext;"},{stage:8,text:"    node.prev = head;"},{stage:8,text:"    hnext.prev = node;"},{stage:6,text:"  }"},{stage:0,text:""},{stage:12,text:"  removeLast() {"},{stage:13,text:"    const del = this.tail.prev;"},{stage:13,text:"    const prev = del.prev;"},{stage:13,text:"    prev.next = this.tail;"},{stage:13,text:"    this.tail.prev = prev;"},{stage:12,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LRUCache {"},{stage:0,text:"  constructor(capacity) {"},{stage:0,text:"    if (!capacity) {"},{stage:0,text:"      throw new Error('Declare LRUCache with an integer capacity > 0.');"},{stage:0,text:"    }"},{stage:0,text:"    this.capacity = capacity;"},{stage:0,text:"    this.count = 0;"},{stage:0,text:"    this.hash = {};"},{stage:0,text:"    this.ll = new DoublyLinkedList();"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  get(key) {"},{stage:1,text:"    const node = this.hash[key];"},{stage:1,text:"    if (node === undefined) {"},{stage:1,text:"      return -1;"},{stage:1,text:"    }"},{stage:2,text:"    this.ll.detach(node);"},{stage:5,text:"    this.ll.addToFront(node);"},{stage:5,text:"    return node.data;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  put(key, value) {"},{stage:9,text:"    let node = this.hash[key];"},{stage:9,text:"    if (!node) {"},{stage:10,text:"      this.count++;"},{stage:10,text:"      if (this.count > this.capacity) {"},{stage:11,text:"        this.ll.removeLast();"},{stage:11,text:"        this.count--;"},{stage:10,text:"      }"},{stage:14,text:"      node = new Node(key, value);"},{stage:14,text:"      this.hash[key] = node;"},{stage:9,text:"    } else {"},{stage:15,text:"      node.data = value;"},{stage:15,text:"      this.ll.detach(node);"},{stage:9,text:"    }"},{stage:16,text:"    this.ll.addToFront(node);"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""}]}}},ge=0;Object.keys(xe).forEach((function(e){var t=xe[e].solution.solutionLines,a=0;t.forEach((function(e){e.stage>0&&a++})),a>ge&&(ge=a),xe[e].effort=a}));var pe=ge,me=xe,ye=Array.from(new Set(Object.keys(xe).map((function(e){return xe[e].category})))).sort(),fe=a(63),ve=a.n(fe),ke=a(87),be=a(94),Le=a.n(be),Ne=a(117),we=a(98),Ee=a(6),Ie=a(47),Ce=Object(Ie.c)({name:"game",initialState:{value:"",value2:"",results:[],revealButtonPressed:!1,isBusyTesting:!1,activeIndex:0,totalSeconds:0,isRunning:!1,open:!1,noteCode:"",tableSort:"id",sessionHistory:[]},reducers:{setValue:function(e,t){t.type;var a=t.payload;e.value=a},setValue2:function(e,t){t.type;var a=t.payload;e.value2=a},setResults:function(e,t){t.type;var a=t.payload;e.results=a},setRevealButtonPressed:function(e,t){t.type;var a=t.payload;e.revealButtonPressed=a},setIsBusyTesting:function(e,t){t.type;var a=t.payload;e.setIsBusyTesting=a},setActiveIndex:function(e,t){t.type;var a=t.payload;e.activeIndex=a},setTotalSeconds:function(e,t){t.type;var a=t.payload;e.totalSeconds=a},setOpen:function(e,t){t.type;var a=t.payload;e.open=a},setNoteCode:function(e,t){t.type;var a=t.payload;e.noteCode=a},updateTableSort:function(e,t){t.type;var a=t.payload;e.tableSort=a},setSessionHistory:function(e,t){t.type;var a=t.payload;e.sessionHistory=a},incrementTotalSeconds:function(e,t){t.type,t.payload;e.totalSeconds=e.totalSeconds+1},setIsRunning:function(e,t){t.type;var a=t.payload;e.isRunning=a},startRunningTests:function(e,t){t.type,t.payload;e.results=[],e.activeIndex=1,e.isBusyTesting=!0},concludeRunningTests:function(e,t){t.type;var a=t.payload,n=a.r,s=a.entry;e.results=n,e.isBusyTesting=!1,n.every((function(e){return e.ok}))&&!e.revealButtonPressed&&(e.isRunning=!1,e.sessionHistory.push(s),e.revealButtonPressed=!0)},clickNextToResults:function(e,t){t.type,t.payload;e.totalSeconds=0,e.isRunning=!1,e.revealButtonPressed=!1,e.activeIndex=0,e.value="",e.results=[]},clickSkipToResults:function(e,t){t.type;var a=t.payload;e.revealButtonPressed||e.sessionHistory.push({id:a,seconds:null}),e.totalSeconds=0,e.isRunning=!1,e.revealButtonPressed=!1,e.activeIndex=0,e.value="",e.results=[]},clickNext:function(e,t){t.type,t.payload;e.totalSeconds=0,e.isRunning=!0,e.revealButtonPressed=!1,e.activeIndex=0,e.value="",e.results=[]},clickSkip:function(e,t){t.type;var a=t.payload;e.revealButtonPressed||e.sessionHistory.push({id:a,seconds:null}),e.totalSeconds=0,e.isRunning=!0,e.revealButtonPressed=!1,e.activeIndex=0,e.value="",e.results=[]},revealAnswer:function(e,t){t.type;var a=t.payload,n=a.id,s=a.data;e.revealButtonPressed=!0,e.isRunning=!1,e.sessionHistory.push({id:n,seconds:null}),e.value2=s.solution.solutionLines.map((function(e){return e.text})).join("\n")}}}),Te=Ce.actions,Se=Te.setValue,Re=Te.setValue2,Oe=(Te.setResults,Te.setRevealButtonPressed),Be=(Te.setIsBusyTesting,Te.setActiveIndex),De=(Te.setTotalSeconds,Te.setOpen),je=Te.setNoteCode,He=Te.updateTableSort,Ve=Te.setSessionHistory,Ae=Te.incrementTotalSeconds,Me=Te.setIsRunning,Ke=Te.startRunningTests,qe=Te.concludeRunningTests,Pe=Te.clickNextToResults,Je=Te.clickSkipToResults,Ge=Te.clickNext,We=Te.clickSkip,Fe=Te.revealAnswer,Ue=Ce.reducer,ze=a(135),_e=a(136);function Qe(){return new Worker(a.p+"static/js/worker.cdb86241.worker.js")}function Ye(e){try{var t=localStorage.getItem("personalBests"),a=JSON.parse(t);if(!a)throw new Error("Need to populate initial data.");var n=a[e.id];(!n||e.seconds<n)&&(a[e.id]=e.seconds,localStorage.setItem("personalBests",JSON.stringify(a)))}catch(i){var s={};s[e.id]=e.seconds,localStorage.setItem("personalBests",JSON.stringify(s))}}function Xe(){try{var e=localStorage.getItem("personalBests"),t=JSON.parse(e);if(!t)throw new Error("Need to populate initial data.");return t}catch(n){var a={};return localStorage.setItem("personalBests",JSON.stringify(a)),a}}function Ze(e,t,a,n,s){var i,r=";",l=Object(o.a)(t);try{var d=function(){var t=i.value,a=e.find((function(e){return e.id===t}));a?r+=a.code:console.error("Could not find testCase id: ".concat(t))};for(l.s();!(i=l.n()).done;)d()}catch(c){l.e(c)}finally{l.f()}return{test:r+a+n,text:"/* Test Code */\n\n\n".concat(r).concat(a,"\n\n\n/* Evaluation Code */\n\n\n").concat(n,"\n\n\n/* Implicit Code Below */\n\n\n").concat(s)}}function $e(e){if(!e)return"00:00:00";var t=function(e){var t=0,a=0;e>3600&&(t=Math.floor(e/3600),e%=3600);e>60&&(a=Math.floor(e/60),e%=60);return{hours:t,minutes:a,seconds:e}}(e),a=t.hours,n=t.minutes,s=t.seconds;return"".concat(String(a).padStart(2,"0"),":").concat(String(n).padStart(2,"0"),":").concat(String(s).padStart(2,"0"))}function et(e,t,a,n){var s=Xe()[t.problemID],i="green";return s&&e>s&&(i="blue"),(e>t.solution.stages[t.solution.stages.length-1]||a)&&(i="red"),n&&(i="green"),i}var tt=Object(Ie.b)("",function(){var e=Object(ke.a)(ve.a.mark((function e(t,a){var n,s,i,r;return ve.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return n=a.getState(),s=n.game.value,i=me[t],a.dispatch(Ke()),r=i.testCases.map(function(){var e=Object(ke.a)(ve.a.mark((function e(t){var a,n,r,l,o,d,c,h,u;return ve.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return a=new Qe,n=_e.b(a),r="",l=n.evaluate(s+i.setupCode+Ze(i.testCases,t.inherit,t.code,t.evaluate,"").test).catch((function(e){r=e.message})),o=new Promise((function(e,t){setTimeout(t,1e3*i.maxExecutionTime,new Error("Timeout"))})).catch((function(e){r=e.message})),e.next=7,Promise.race([l,o]);case 7:return d=e.sent,n[_e.a](),a.terminate(),c="",c="object"===typeof d&&null!=d?JSON.stringify(d):d,h=t.expected===c&&!r,u="string"!==typeof c?JSON.stringify(c):c,e.abrupt("return",Object(ze.a)(Object(ze.a)({},t),{},{actual:u,error:r,ok:h}));case 15:case"end":return e.stop()}}),e)})));return function(t){return e.apply(this,arguments)}}()),e.next=7,Promise.all(r).then((function(e){var s={id:t,seconds:n.game.totalSeconds};a.dispatch(qe({r:e,entry:s})),Ye(s)}));case 7:case"end":return e.stop()}}),e)})));return function(t,a){return e.apply(this,arguments)}}()),at=a(20);var nt=function(){var e=Object(Ee.b)(),t=Object(Ee.c)((function(e){return e.game.value})),a=n.useRef(),s=n.useRef({}),i=Object(at.g)().id;return s.current.id=i,n.createElement("div",{style:{padding:"1vh 1vw",width:"48.5vw",backgroundColor:"ivory",borderRadius:"5px"}},n.createElement(Le.a,{ref:a,placeholder:"Enter text here...",mode:"javascript",theme:"dawn",name:"editor1",onChange:function(t){e(Se(t)),a.current.editor.resize()},value:t,width:"47vw",height:"59vh",showGutter:!0,highlightActiveLine:!0,wrapEnabled:!0,setOptions:{enableBasicAutocompletion:!0,enableLiveAutocompletion:!0,showLineNumbers:!0,tabSize:2},commands:[{name:"prettier",bindKey:{win:"Ctrl-S",mac:"Cmd-S"},exec:function(t){try{var a=Ne.a.format(t.session.getValue(),{parser:"babel",plugins:[we.a]});e(Se(a))}catch(n){console.log("There was an error in compilation.")}}},{name:"run tests",bindKey:{win:"Ctrl-M",mac:"Cmd-M"},exec:function(){var t=Object(ke.a)(ve.a.mark((function t(){return ve.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.prev=0,t.next=3,e(tt(s.current.id));case 3:t.next=8;break;case 5:t.prev=5,t.t0=t.catch(0),console.log("Encountered an error when attempting to run tests.");case 8:case"end":return t.stop()}}),t,null,[[0,5]])})));return function(){return t.apply(this,arguments)}}()}]}))};var st=function(){var e=Object(Ee.c)((function(e){return e.game.value2})),t=n.useRef();return n.createElement("div",{style:{padding:"1vh 1vw",width:"48.5vw",backgroundColor:"ivory",borderRadius:"5px"}},n.createElement(Le.a,{ref:t,placeholder:"No suggestions...",mode:"javascript",theme:"github",width:"47vw",height:"59vh",name:"editor2",readOnly:!0,showGutter:!0,onChange:function(){t.current.editor.resize()},value:e,highlightActiveLine:!1,wrapEnabled:!0,setOptions:{showLineNumbers:!0,tabSize:2}}))},it=a(655),rt=a(10),lt=a(654),ot=a(84),dt=a(653),ct=a(656),ht=a(139),ut=a.n(ht),xt=a(157),gt=a.n(xt);a(205);ut.a.registerLanguage("javascript",gt.a);var pt=function(){var e=Object(Ee.b)(),t=Object(Ee.c)((function(e){return e.game.open})),a=Object(Ee.c)((function(e){return e.game.noteCode}));return n.createElement(dt.a,{onClose:function(){return e(De(!1))},onOpen:function(){return e(De(!0))},open:t},n.createElement(dt.a.Header,null,"Test Code"),n.createElement(dt.a.Content,null,n.createElement("div",{style:{whiteSpace:"pre",border:"1px dotted cornflowerblue",backgroundColor:"lavender",borderRadius:"5px",padding:"1em",fontFamily:"monospace"},dangerouslySetInnerHTML:{__html:ut.a.highlight("javascript",a).value}})),n.createElement(dt.a.Actions,null,n.createElement(ct.a,{style:{width:"138px"},onClick:function(){return e(De(!1))}},"Close")))};var mt=function(){var e=Object(Ee.b)(),t=Object(Ee.c)((function(e){return e.game.results})),a=Object(Ee.c)((function(e){return e.game.tableSort})),s=Object(at.g)().id,i=Object(rt.a)(t).sort((function(e,t){if("id"===a)return e.id-t.id;if("fail"===a)return(e.ok?e.id+1e4:e.id)-(t.ok?t.id+1e4:t.id);if("success"===a)return(e.ok?e.id:e.id+1e4)-(t.ok?t.id:t.id+1e4);throw new Error("Invalid sort choice: ".concat(a))}));if(!i.length)return null;var r=me[s];return n.createElement("div",null,n.createElement(pt,null),n.createElement(lt.a,{celled:!0,compact:"very",className:"run-results"},n.createElement(lt.a.Header,null,n.createElement(lt.a.Row,null,n.createElement(lt.a.HeaderCell,{style:{textAlign:"center"}},"ID"),n.createElement(lt.a.HeaderCell,{style:{textAlign:"center"}},"Code"),n.createElement(lt.a.HeaderCell,null,"Description"),n.createElement(lt.a.HeaderCell,null,"Expected"),n.createElement(lt.a.HeaderCell,null,"Actual"),n.createElement(lt.a.HeaderCell,null,"Error"),n.createElement(lt.a.HeaderCell,{onClick:function(){if("id"===a)e(He("fail"));else if("fail"===a)e(He("success"));else{if("success"!==a)throw new Error("Invalid sort choice: ".concat(a));e(He("id"))}},style:{textAlign:"center",cursor:"pointer"}},"Status"))),n.createElement(lt.a.Body,null,i.map((function(t){return n.createElement(lt.a.Row,{key:t.id,style:{backgroundColor:t.ok?"rgba(0, 255, 0, 0.3)":"rgba(255, 0, 0, 0.3)"}},n.createElement(lt.a.Cell,{style:{textAlign:"center"}},t.id),n.createElement(lt.a.Cell,{style:{textAlign:"center"}},n.createElement(ot.a,{className:"hover-note",name:"sticky note outline",role:"button",onClick:function(){var a=Ze(r.testCases,t.inherit,t.code,t.evaluate,r.setupCode).text,n=Ne.a.format(a,{parser:"babel",plugins:[we.a]});e(je(n)),e(De(!0))}})),n.createElement(lt.a.Cell,null,t.name),n.createElement(lt.a.Cell,null,"string"!==typeof t.expected?JSON.stringify(t.expected):t.expected),n.createElement(lt.a.Cell,null,t.actual),n.createElement(lt.a.Cell,null,t.error),n.createElement(lt.a.Cell,{style:{textAlign:"center"}},t.ok?n.createElement(ot.a,{color:"green",name:"checkmark"}):n.createElement(ot.a,{color:"red",name:"checkmark"})))})))))},yt=a(37),ft=a.n(yt),vt=new ft.a.Converter;var kt=function(){var e=Object(Ee.b)(),t=Object(Ee.c)((function(e){return e.game.isBusyTesting})),a=Object(Ee.c)((function(e){return e.game.activeIndex})),s=Object(Ee.c)((function(e){return e.game.results})),i=Object(at.g)().id,r=me[i];if(!r)return[];var l=s.length;return n.createElement(it.a,{fluid:!0,raised:!0,style:{height:"calc(32vh - 40px)"}},n.createElement("p",{style:{padding:"10px 0 0 10px"}},n.createElement("span",{className:0===a?"pane-base chosen-pane":"pane-base",onClick:function(){return e(Be(0))}},"Problem")," ","|"," ",n.createElement("span",{className:1===a?"pane-base chosen-pane":"pane-base",onClick:function(){return e(Be(1))}},"Test Results"),n.createElement("span",{style:{float:"right"}}," ",n.createElement("span",{style:{fontVariant:"small-caps"}},r.type," / ",r.category),n.createElement("span",{style:{backgroundColor:"azure",color:"black",display:"inline-block",border:"1px solid darkslategrey",borderRadius:"50%",width:"1.5em",height:"1.5em",lineHeight:"1.25em",verticalAlign:"center",boxShadow:"1px 1px 2px lightslategrey",cursor:"default",marginRight:"1em",marginLeft:"1em",textAlign:"center"},title:r.difficulty},r.difficulty.slice(0,1)))),n.createElement(it.a.Content,{style:{height:"calc(32vh - 70px)",overflowY:"scroll"}},0===a?n.createElement("div",{dangerouslySetInnerHTML:{__html:vt.makeHtml(r.problemText)}}):null,1===a?t?n.createElement("p",null,"Testing in Progress..."):l?n.createElement(mt,{id:i}):n.createElement("p",null,"Tests have not been run yet for this problem."):null))};var bt=function(){var e=Object(Ee.b)(),t=Object(Ee.c)((function(e){return e.game.value})),a=Object(Ee.c)((function(e){return e.game.value2})),s=Object(Ee.c)((function(e){return e.game.revealButtonPressed})),i=Object(Ee.c)((function(e){return e.game.totalSeconds})),r=Object(at.g)().id,d=me[r];return n.useEffect((function(){if(d){if(!t){var n=[];d.solution.solutionLines.forEach((function(e){0===e.stage&&n.push(e.text)})),e(Se(n.join("\n")))}!s&&i>d.solution.stages[d.solution.stages.length-1]&&(e(Oe(!0)),e(Me(!1)));var r,c=0,h=Object(o.a)(d.solution.stages.entries());try{for(h.s();!(r=h.n()).done;){var u=Object(l.a)(r.value,2),x=u[0],g=u[1];i>=g&&(c=x)}}catch(m){h.e(m)}finally{h.f()}s&&(c=1/0);var p=d.solution.solutionLines.map((function(e){return e.stage<=c?e.text:"  //"})).join("\n");JSON.stringify(a)!==JSON.stringify(p)&&e(Re(p))}}),[d,s,i,t,a,e]),d?n.createElement(n.Fragment,null,n.createElement("div",{style:{padding:"1vh 1vw"}},n.createElement("div",{style:{height:"calc(35vh - 40px)",padding:"1vh 0 1vh 0vw"}},n.createElement(kt,null)),n.createElement("div",{className:"editor-area columns"},n.createElement("div",{className:"editor-area column"},n.createElement(nt,null)),n.createElement("div",{className:"column"},n.createElement(st,null))))):n.createElement("p",null,"Problem Not Found")},Lt=ye.map((function(e){return{name:e,isSelected:!0}})),Nt=Object(Ie.c)({name:"filter",initialState:{selections:[],results:[],showModal:!1,activeProblemText:"",categories:Lt,dsChecked:!0,algChecked:!0,minEffort:0,maxEffort:pe,begChecked:!0,intChecked:!0,advChecked:!0},reducers:{setSelections:function(e,t){t.type;var a=t.payload;e.selections=a},shiftSelection:function(e,t){t.type,t.payload;e.selections=e.selections.slice(1)},setResults:function(e,t){t.type;var a=t.payload;e.results=a},setShowModal:function(e,t){t.type;var a=t.payload;e.showModal=a},setActiveProblemText:function(e,t){t.type;var a=t.payload;e.activeProblemText=a},setCategories:function(e,t){t.type;var a=t.payload;e.categories=a},setDsChecked:function(e,t){t.type;var a=t.payload;e.dsChecked=a},setAlgChecked:function(e,t){t.type;var a=t.payload;e.algChecked=a},setEffortSlider:function(e,t){t.type;var a=t.payload;e.minEffort=a[0],e.maxEffort=a[1]},pressReset:function(e,t){t.type,t.payload;e.categories=Lt,e.minEffort=0,e.maxEffort=pe,e.dsChecked=!0,e.algChecked=!0,e.begChecked=!0,e.intChecked=!0,e.advChecked=!0},setBegChecked:function(e,t){t.type;var a=t.payload;e.begChecked=a},setIntChecked:function(e,t){t.type;var a=t.payload;e.intChecked=a},setAdvChecked:function(e,t){t.type;var a=t.payload;e.advChecked=a}}}),wt=Nt.actions,Et=wt.setSelections,It=wt.setResults,Ct=wt.setShowModal,Tt=wt.setActiveProblemText,St=wt.setCategories,Rt=wt.setDsChecked,Ot=wt.setAlgChecked,Bt=wt.pressReset,Dt=wt.setEffortSlider,jt=wt.shiftSelection,Ht=wt.setBegChecked,Vt=wt.setIntChecked,At=wt.setAdvChecked,Mt=Nt.reducer,Kt=new ft.a.Converter;var qt=function(){var e=Object(Ee.b)(),t=Object(Ee.c)((function(e){return e.game.sessionHistory})),a=Xe();return n.createElement("div",{style:{paddingBottom:"30px"}},n.createElement("h2",{style:{margin:"0 auto",padding:"30px 0",textAlign:"center"}},"Session Statistics"),n.createElement(lt.a,{style:{margin:"auto",width:"80vw",maxWidth:"1200px",letterSpacing:"1px"}},n.createElement(lt.a.Header,null,n.createElement(lt.a.Row,null,n.createElement(lt.a.HeaderCell,null,"ID"),n.createElement(lt.a.HeaderCell,null,"Name"),n.createElement(lt.a.HeaderCell,{style:{textAlign:"center"}},"Result"),n.createElement(lt.a.HeaderCell,{style:{textAlign:"center"}},"Best"))),n.createElement(lt.a.Body,null,t.map((function(t,s){var i=$e(t.seconds),r=$e(a[t.id]);return n.createElement(lt.a.Row,{key:s,style:{backgroundColor:i===r?"rgba(0,255,0,0.2)":"rgba(255,0,0,0.2)"}},n.createElement(lt.a.Cell,null,t.id),n.createElement(lt.a.Cell,null,n.createElement("div",{style:{display:"inline"},className:"hover-link",onClick:function(){return a=me[t.id].problemText,e(Tt(a)),void e(Ct(!0));var a},dangerouslySetInnerHTML:{__html:Kt.makeHtml(me[t.id].problemName)}})),n.createElement(lt.a.Cell,{style:{textAlign:"center"}},i),n.createElement(lt.a.Cell,{style:{textAlign:"center"}},r))})))),t.length?n.createElement("div",{style:{width:"100%",padding:"40px 0"}},n.createElement(ct.a,{style:{width:"138px",display:"block",margin:"auto"},onClick:function(){e(Ve([]))}},"Clear Stats")):n.createElement("p",{style:{padding:"10px",margin:"auto",width:"80vw"}},"The session history is empty."))},Pt=new ft.a.Converter;var Jt=function(){var e=Object(Ee.b)(),t=n.useState(0),a=Object(l.a)(t,2),s=a[0],i=a[1],r=Xe();return console.log({personalBests:r}),n.createElement("div",{style:{paddingBottom:"30px"}},n.createElement("h2",{style:{margin:"0 auto",padding:"30px 0",textAlign:"center"}},"Historic Statistics"),n.createElement(lt.a,{style:{margin:"auto",width:"80vw",maxWidth:"1200px",letterSpacing:"1px"}},n.createElement(lt.a.Header,null,n.createElement(lt.a.Row,null,n.createElement(lt.a.HeaderCell,null,"ID"),n.createElement(lt.a.HeaderCell,null,"Name"),n.createElement(lt.a.HeaderCell,{style:{textAlign:"center"}},"Best"))),n.createElement(lt.a.Body,null,Object.keys(me).map((function(t,a){var s=$e(r[t]);return"00:00:00"===s?null:n.createElement(lt.a.Row,{key:a,style:{backgroundColor:"lavender"}},n.createElement(lt.a.Cell,null,t),n.createElement(lt.a.Cell,null,n.createElement("div",{style:{display:"inline"},className:"hover-link",onClick:function(){return a=me[t].problemText,e(Tt(a)),void e(Ct(!0));var a},dangerouslySetInnerHTML:{__html:Pt.makeHtml(me[t].problemName)}})),n.createElement(lt.a.Cell,{style:{textAlign:"center"}},s))})))),Object.keys(r).length?n.createElement("div",{style:{width:"100%",padding:"40px 0"}},n.createElement(ct.a,{style:{width:"138px",display:"block",margin:"auto"},onClick:function(){!function(){var e={};localStorage.setItem("personalBests",JSON.stringify(e))}(),i(s+1)}},"Clear Stats")):n.createElement("p",{style:{padding:"10px",margin:"auto",width:"80vw"}},"The history is empty."))},Gt=a(652),Wt=a(651);var Ft=function(e){var t,a=e.page,s=Object(Ee.b)(),i=Object(Ee.c)((function(e){return e.game.isBusyTesting})),r=Object(Ee.c)((function(e){return e.game.revealButtonPressed})),l=Object(Ee.c)((function(e){return e.game.results})),d=Object(Ee.c)((function(e){return e.game.totalSeconds})),c=Object(Ee.c)((function(e){return e.filter.selections})),h=Object(at.f)(),u=Object(at.g)().id,x=me[u],g=0,p=Object(o.a)(l);try{for(p.s();!(t=p.n()).done;){t.value.ok&&g++}}catch(v){p.e(v)}finally{p.f()}var m=(x&&x.testCases&&x.testCases.length)===g,y=Boolean(c&&c.length>0),f=l.length>0&&l.every((function(e){return e.ok}));return n.createElement(Gt.a,null,"/"!==a?n.createElement(Gt.a.Item,null,n.createElement(ct.a.Group,null,n.createElement(Wt.a,{content:"Home",trigger:n.createElement(ct.a,{icon:!0,onClick:function(){h.push("/")}},n.createElement(ot.a,{name:"home"}))}))):null,n.createElement(Gt.a.Item,null,n.createElement("span",{style:{fontWeight:"bolder",fontSize:"20px",fontVariant:"small-caps"}},"Puzzler")),"/"===a?n.createElement(Gt.a.Item,null,n.createElement(ct.a.Group,null,n.createElement(Wt.a,{content:"Reset Filters",trigger:n.createElement(ct.a,{icon:!0,onClick:function(){s(Bt())}},n.createElement(ot.a,{name:"undo"}))}))):null,"/:id"===a?n.createElement(n.Fragment,null,n.createElement(Gt.a.Item,null,n.createElement(ct.a.Group,null,n.createElement(Wt.a,{content:"Run Tests (ctrl-m)",trigger:n.createElement(ct.a,{icon:!0,onClick:function(){i||r||s(tt(u))},disabled:i||r},n.createElement(ot.a,{name:"rocket",className:i?"animate-icon":""}))}),n.createElement(Wt.a,{content:"Proceed to Next Problem",trigger:n.createElement(ct.a,{icon:!0,onClick:function(){if(m)if(y){var e=c[0];s(Ge(u)),s(jt()),h.push("/".concat(e))}else s(Pe(u)),h.push("/sessionStats")},disabled:!m},n.createElement(ot.a,{name:"step forward"}))}))),n.createElement(Gt.a.Item,null,n.createElement("span",{style:{color:et(d,x,r,f)}},$e(d)),function(e,t){return t?n.createElement("span",{style:{color:"green",fontWeight:"bold"}},"- PASSED!"):e?n.createElement("span",{style:{color:"red"}},"- Stopped"):null}(r,f)),y?null:n.createElement(Gt.a.Item,null,n.createElement("span",{style:{fontWeight:"bold",color:"orange"}},"Last Problem")),n.createElement(Gt.a.Item,null,n.createElement(ct.a.Group,null,n.createElement(Wt.a,{content:"Reveal Solution",trigger:n.createElement(ct.a,{icon:!0,onClick:function(){r||f||s(Fe({id:u,data:x}))},disabled:r||f},n.createElement(ot.a,{name:"eye"}))}))),n.createElement(Gt.a.Item,null,n.createElement(ct.a.Group,null,n.createElement(Wt.a,{content:"Skip this Problem",trigger:n.createElement(ct.a,{icon:!0,onClick:function(){if(!f)if(y){var e=c[0];s(We(u)),s(jt()),h.push("/".concat(e))}else s(Je(u)),h.push("/sessionStats")},disabled:f},n.createElement(ot.a,{name:"fast forward"}))})))):null,n.createElement(Gt.a.Item,{position:"right"},"/sessionStats"!==a?n.createElement(Wt.a,{content:"See Session Stats",trigger:n.createElement(ct.a,{icon:!0,style:{marginRight:"10px"},onClick:function(){u&&s(Je(u)),h.push("/sessionStats")}},n.createElement(ot.a,{name:"file alternate outline"}))}):null,"/historicStats"!==a?n.createElement(Wt.a,{content:"See Historic Stats",trigger:n.createElement(ct.a,{icon:!0,onClick:function(){u&&s(Je(u)),h.push("/historicStats")}},n.createElement(ot.a,{name:"history"}))}):null))},Ut=a(650),zt=new ft.a.Converter;var _t=function(){var e=Object(Ee.b)(),t=Object(Ee.c)((function(e){return e.filter.selections})),a=Object(Ee.c)((function(e){return e.filter.results})),s=function(a){e(Et([].concat(Object(rt.a)(t),[a])))},i=a.filter((function(e){return!t.includes(e)}));return n.createElement(it.a,{style:{width:"100%",height:"100%"}},n.createElement(it.a.Content,{header:"Filter Results"}),n.createElement(Ut.a,{style:{padding:"0",margin:"0"}}),n.createElement("div",{style:{overflowY:"scroll"}},n.createElement("div",{style:{padding:"1em",height:"63px"}},n.createElement("div",{style:{display:"inline",height:"36px",lineHeight:"36px",float:"left"}},"Found ",i.length," results."),n.createElement(ct.a,{onClick:function(){return function(){var e=i[Math.floor(Math.random()*i.length)];s(e)}()},disabled:Boolean(!i.length),icon:!0,labelPosition:"right",style:{display:"inline",float:"right"}},"Add Random",n.createElement(ot.a,{name:"right arrow"}))),n.createElement("div",{style:{padding:"0 1em 1em 1em",clear:"both"}},n.createElement(lt.a,{celled:!0,compact:"very"},n.createElement(lt.a.Header,null,n.createElement(lt.a.Row,null,n.createElement(lt.a.HeaderCell,null,"Name"),n.createElement(lt.a.HeaderCell,{style:{textAlign:"center"}},"Difficulty"),n.createElement(lt.a.HeaderCell,{style:{textAlign:"center"}},"Effort"),n.createElement(lt.a.HeaderCell,{style:{textAlign:"center"}},"Category"),n.createElement(lt.a.HeaderCell,{style:{textAlign:"center"}},"Action"))),n.createElement(lt.a.Body,null,i.length?i.map((function(a){var i=me[a],r=t.includes(i.problemID);return n.createElement(lt.a.Row,{key:i.problemID,className:r?"existing-selection":""},n.createElement(lt.a.Cell,null,n.createElement("div",{style:{display:"inline"},className:"hover-link",onClick:function(){return t=i.problemText,e(Tt(t)),void e(Ct(!0));var t},dangerouslySetInnerHTML:{__html:zt.makeHtml("**".concat(i.problemID,"**:  ")+i.problemName)}})),n.createElement(lt.a.Cell,{style:{textAlign:"center"}},n.createElement("span",{style:{backgroundColor:"azure",color:"black",display:"inline-block",border:"1px solid darkslategrey",borderRadius:"50%",width:"1.5em",height:"1.5em",lineHeight:"1.25em",verticalAlign:"center",boxShadow:"1px 1px 2px lightslategrey",cursor:"default"},title:i.difficulty},i.difficulty.slice(0,1))),n.createElement(lt.a.Cell,{style:{textAlign:"center"}},i.effort),n.createElement(lt.a.Cell,{style:{textAlign:"center"}},i.category),n.createElement(lt.a.Cell,{style:{textAlign:"center"}},r?n.createElement(ct.a,{icon:!0,onClick:function(){return a=i.problemID,void e(Et(t.filter((function(e){return e!==a}))));var a}},n.createElement(ot.a,{className:"hover-circle-off",name:"minus"})):n.createElement(ct.a,{icon:!0,onClick:function(){return s(i.problemID)}},n.createElement(ot.a,{className:"hover-circle-on",name:"add"}))))})):n.createElement(lt.a.Row,{key:0},n.createElement(lt.a.Cell,{colSpan:"4"},"No Results")))))))},Qt=new ft.a.Converter;var Yt=function(){var e=Object(at.f)(),t=Object(at.g)().id,a=Object(Ee.b)(),s=Object(Ee.c)((function(e){return e.filter.selections}));return n.createElement(it.a,{style:{width:"100%",height:"100%"}},n.createElement(it.a.Content,{header:"Selections"}),n.createElement(Ut.a,{style:{padding:"0",margin:"0"}}),n.createElement("div",{style:{overflowY:"scroll"}},n.createElement("div",{style:{padding:"1em",height:"63px"}},n.createElement(ct.a,{disabled:Boolean(!s.length),style:{float:"left"},onClick:function(){a(Et([]))}},"Clear All"),n.createElement(ct.a,{style:{float:"right"},onClick:function(){var n=s[0];a(Ge(t)),a(jt()),e.push("/".concat(n))},disabled:Boolean(!s.length),primary:!0},"START")),n.createElement(Ut.a,{style:{padding:"0",margin:"0"}}),n.createElement("div",{style:{padding:"1em 1em 0 1em"}},s.length," Problem(s) Selected."),n.createElement("div",{style:{padding:"1em"}},n.createElement(lt.a,{celled:!0,compact:"very"},n.createElement(lt.a.Header,null,n.createElement(lt.a.Row,null,n.createElement(lt.a.HeaderCell,null,"Name"),n.createElement(lt.a.HeaderCell,{style:{textAlign:"center"}},"Difficulty"),n.createElement(lt.a.HeaderCell,{style:{textAlign:"center"}},"Effort"),n.createElement(lt.a.HeaderCell,{style:{textAlign:"center"}},"Category"),n.createElement(lt.a.HeaderCell,{style:{textAlign:"center"}},"Action"))),n.createElement(lt.a.Body,null,s.length?s.map((function(e){var t=me[e];return n.createElement(lt.a.Row,{key:t.problemID},n.createElement(lt.a.Cell,null,n.createElement("div",{style:{display:"inline"},className:"hover-link",onClick:function(){return e=t.problemText,a(Tt(e)),void a(Ct(!0));var e},dangerouslySetInnerHTML:{__html:Qt.makeHtml("**".concat(t.problemID,"**:  ")+t.problemName)}})),n.createElement(lt.a.Cell,{style:{textAlign:"center"}},n.createElement("span",{style:{backgroundColor:"azure",color:"black",display:"inline-block",border:"1px solid darkslategrey",borderRadius:"50%",width:"1.5em",height:"1.5em",lineHeight:"1.25em",verticalAlign:"center",boxShadow:"1px 1px 2px lightslategrey",cursor:"default"},title:t.difficulty},t.difficulty.slice(0,1))),n.createElement(lt.a.Cell,{style:{textAlign:"center"}},t.effort),n.createElement(lt.a.Cell,{style:{textAlign:"center"}},t.category),n.createElement(lt.a.Cell,{style:{textAlign:"center"}},n.createElement(ct.a,{icon:!0,onClick:function(){return e=t.problemID,void a(Et(s.filter((function(t){return t!==e}))));var e}},n.createElement(ot.a,{className:"hover-circle-off",name:"minus"}))))})):n.createElement(lt.a.Row,{key:0},n.createElement(lt.a.Cell,{colSpan:"4"},"No Selections")))))))},Xt=a(659);function Zt(){var e=Object(Ee.b)(),t=Object(Ee.c)((function(e){return e.filter.categories})),a=t.every((function(e){return!0===e.isSelected})),s=t.every((function(e){return!1===e.isSelected}));return n.createElement(it.a,{style:{width:"100%",height:"100%"}},n.createElement(it.a.Content,{header:"Categories"}),n.createElement(Ut.a,{style:{padding:"0",margin:"0"}}),n.createElement("div",{style:{width:"100%",height:"100%",overflowY:"scroll"}},n.createElement("div",{style:{padding:"1em"}},n.createElement(Wt.a,{content:"Select All",trigger:n.createElement(ct.a,{icon:"add",disabled:a,onClick:function(){e(St(t.map((function(e){return{name:e.name,isSelected:!0}}))))}})}),n.createElement(Wt.a,{content:"Clear All",trigger:n.createElement(ct.a,{icon:"remove",disabled:s,onClick:function(){e(St(t.map((function(e){return{name:e.name,isSelected:!1}}))))}})})),n.createElement(Ut.a,{style:{padding:"0",margin:"0"}}),n.createElement("div",{style:{padding:"1em"}},t.map((function(a){return n.createElement(Xt.a,{style:{display:"block",padding:"5px 5px"},key:a.name,label:a.name,onChange:function(){!function(a){var n=t.map((function(e){return e.name===a?{name:e.name,isSelected:!e.isSelected}:e}));e(St(n))}(a.name)},checked:a.isSelected})})))))}var $t=a(160),ea=a.n($t);var ta=function(){var e=Object(Ee.b)(),t=Object(Ee.c)((function(e){return e.filter.dsChecked})),a=Object(Ee.c)((function(e){return e.filter.algChecked})),s=Object(Ee.c)((function(e){return e.filter.minEffort})),i=Object(Ee.c)((function(e){return e.filter.maxEffort})),r=Object(Ee.c)((function(e){return e.filter.begChecked})),l=Object(Ee.c)((function(e){return e.filter.intChecked})),o=Object(Ee.c)((function(e){return e.filter.advChecked}));return n.createElement(it.a,{style:{width:"100%",height:"100%",overflowY:"scroll"}},n.createElement(it.a.Content,{header:"Options"}),n.createElement(it.a.Content,{style:{width:"100%",height:"100%",padding:"1em 2em .5em 2em"}},n.createElement("div",{style:{display:"block",width:"100%",height:"50%"}},n.createElement("div",{style:{display:"block",width:"50%",float:"left"}},n.createElement(Xt.a,{style:{display:"block",padding:"5px 0"},label:"Beginner",onChange:function(){e(Ht(!r))},checked:r}),n.createElement(Xt.a,{style:{display:"block",padding:"5px 0"},label:"Intermediate",onChange:function(){e(Vt(!l))},checked:l}),n.createElement(Xt.a,{style:{display:"block",padding:"5px 0"},label:"Advanced",onChange:function(){e(At(!o))},checked:o})),n.createElement("div",{style:{display:"block",width:"50%",float:"right"}},n.createElement(Xt.a,{style:{display:"block",padding:"5px 0"},label:"Data Structures",onChange:function(){e(Rt(!t))},checked:t}),n.createElement(Xt.a,{style:{display:"block",padding:"5px 0"},label:"Algorithms",onChange:function(){e(Ot(!a))},checked:a}))),n.createElement("div",{style:{display:"block",width:"100%",height:"50%"}},n.createElement("p",{style:{fontWeight:"bold",width:"100%",textAlign:"center"}},"Estimated Effort (lines)"),n.createElement(ea.a,{className:"slider-view",selectedMinValue:s,selectedMaxValue:i,onSliderValuesChange:function(t,a){e(Dt([t,a]))},sliderMinValue:0,sliderMaxValue:pe}))))};var aa=function(){var e=Object(Ee.b)(),t=Object(Ee.c)((function(e){return e.filter.categories})),a=Object(Ee.c)((function(e){return e.filter.dsChecked})),s=Object(Ee.c)((function(e){return e.filter.algChecked})),i=Object(Ee.c)((function(e){return e.filter.minEffort})),r=Object(Ee.c)((function(e){return e.filter.maxEffort})),l=Object(Ee.c)((function(e){return e.filter.begChecked})),o=Object(Ee.c)((function(e){return e.filter.intChecked})),d=Object(Ee.c)((function(e){return e.filter.advChecked})),x=n.useCallback((function(){var n=t.filter((function(e){return e.isSelected})).map((function(e){return e.name})),x=Object.keys(me).map((function(e){return Number(e)})).filter((function(e){var t=me[String(e)];return!!n.includes(t.category)&&(!(t.difficulty===c&&!l)&&(!(t.difficulty===h&&!o)&&(!(t.difficulty===u&&!d)&&(!(t.effort<i||t.effort>r)&&(!("data-structure"===t.type&&!a)&&!("algorithm"===t.type&&!s))))))}));e(It(x))}),[s,t,a,r,i,l,o,d,e]);return n.useEffect((function(){x()}),[x]),n.createElement("div",{style:{width:"100%",height:"100%",overflowY:"hidden",overflowX:"hidden"}},n.createElement(it.a.Content,null,n.createElement("div",{style:{position:"absolute",top:"0",left:"0",height:"calc(47vh - 40px)",width:"18vw"}},n.createElement(Zt,{categories:t})),n.createElement("div",{style:{position:"absolute",top:"0",left:"19vw",height:"calc(47vh - 40px)",width:"36vw"}},n.createElement(ta,null))))};function na(){return n.createElement(n.Fragment,null,n.createElement("div",{style:{position:"absolute",top:"calc(40px + 3vh)",left:"2vw",height:"calc(48vh - 40px)",width:"55vw"}},n.createElement(aa,null)),n.createElement("div",{style:{position:"absolute",top:"calc(40px + 3vh)",left:"58vw",height:"calc(94vh - 40px)",width:"40vw"}},n.createElement(Yt,null)),n.createElement("div",{style:{position:"absolute",top:"52vh",left:"2vw",height:"45vh",width:"55vw"}},n.createElement(_t,null)))}var sa=new ft.a.Converter;var ia=function(){var e=Object(Ee.b)(),t=Object(Ee.c)((function(e){return e.filter.showModal})),a=Object(Ee.c)((function(e){return e.filter.activeProblemText}));return n.createElement(dt.a,{onClose:function(){return e(Ct(!1))},onOpen:function(){return e(Ct(!0))},open:t},n.createElement(dt.a.Header,null,"Problem Text"),n.createElement(dt.a.Content,null,n.createElement("div",{dangerouslySetInnerHTML:{__html:sa.makeHtml(a)}})),n.createElement(dt.a.Actions,null,n.createElement(ct.a,{style:{width:"138px"},onClick:function(){return e(Ct(!1))}},"Close")))},ra=null;var la=function(){var e=Object(Ee.b)(),t=Object(Ee.c)((function(e){return e.game.isRunning}));return n.useEffect((function(){t?ra=window.setInterval((function(){e(Ae())}),1e3):ra&&window.clearInterval(ra)}),[t,e]),n.createElement(n.Fragment,null,n.createElement(ia,null),n.createElement(at.c,null,n.createElement(at.a,{exact:!0,path:"/"},n.createElement(Ft,{page:"/"}),n.createElement(na,null)),n.createElement(at.a,{exact:!0,path:"/sessionStats"},n.createElement(Ft,{page:"/sessionStats"}),n.createElement(qt,null)),n.createElement(at.a,{exact:!0,path:"/historicStats"},n.createElement(Ft,{page:"/historicStats"}),n.createElement(Jt,null)),n.createElement(at.a,{exact:!0,path:"/:id"},n.createElement(Ft,{page:"/:id"}),n.createElement(bt,null))))},oa=(a(85),a(210),a(211),a(212),a(213),a(214),a(629),a(630),a(45)),da=a(161),ca=a.n(da),ha=a(162),ua=a(51),xa=a(25),ga=Object(xa.c)({game:Ue,filter:Mt}),pa={key:"root",version:1,storage:ca.a},ma=Object(ua.g)(pa,ga),ya=Object(Ie.a)({reducer:ma,middleware:Object(Ie.d)({serializableCheck:{ignoredActions:[ua.a,ua.f,ua.b,ua.c,ua.d,ua.e]}})}),fa=Object(ua.h)(ya);r.a.render(s.a.createElement(Ee.a,{store:ya},s.a.createElement(ha.a,{loading:null,persistor:fa},s.a.createElement(oa.a,null,s.a.createElement(la,null)))),document.getElementById("root"))}},[[172,1,2]]]);
//# sourceMappingURL=main.5239e675.chunk.js.map