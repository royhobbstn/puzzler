(this.webpackJsonppuzzler=this.webpackJsonppuzzler||[]).push([[0],{166:function(e,t,a){e.exports=a(625)},622:function(e,t,a){},625:function(e,t,a){"use strict";a.r(t);var n,s=a(0),r=a.n(s),i=a(44),o=a.n(i),l=a(6),g=a(10),x="Data Structure",d="Algorithm",c="Linked List",u="Heap",h="Binary Tree",p="Graph",m="Breadth First Search",f="Depth First Search",v="General",w="Fast Slow Pointers",b="Subsets",y=(n={},Object(g.a)(n,x,"DS"),Object(g.a)(n,d,"Alg"),Object(g.a)(n,"Design","Dsgn"),Object(g.a)(n,"Beginner","B"),Object(g.a)(n,"Intermediate","I"),Object(g.a)(n,"Advanced","A"),Object(g.a)(n,"Expert","E"),Object(g.a)(n,c,"LL"),Object(g.a)(n,"Doubly Linked List","DLL"),Object(g.a)(n,"Queue","Q"),Object(g.a)(n,"Stack","St"),Object(g.a)(n,"Hash Table","HTbl"),Object(g.a)(n,u,"Heap"),Object(g.a)(n,h,"BT"),Object(g.a)(n,"Binary Search Tree","BST"),Object(g.a)(n,p,"Gr"),Object(g.a)(n,"Trie","Trie"),Object(g.a)(n,"Cache","C"),Object(g.a)(n,"Dynamic Programming","DP"),Object(g.a)(n,v,"Gen"),Object(g.a)(n,"Fibonacci","Fib"),Object(g.a)(n,"Binary Search","BS"),Object(g.a)(n,"Sorting","Sort"),Object(g.a)(n,"Recursion","Rec"),Object(g.a)(n,"Sliding Window","SlWi"),Object(g.a)(n,"Bitwise","Bit"),Object(g.a)(n,"Cyclic Sort","Cycl"),Object(g.a)(n,w,"FSPt"),Object(g.a)(n,"Merge Intervals","MI"),Object(g.a)(n,"Two Pointers","TP"),Object(g.a)(n,f,"DFS"),Object(g.a)(n,m,"BFS"),Object(g.a)(n,b,"Sub"),Object(g.a)(n,"K-Way-Merge","KWM"),Object(g.a)(n,"Topological Sort","TS"),Object(g.a)(n,"Amazon","Amazon"),Object(g.a)(n,"Facebook","Facebook"),Object(g.a)(n,"Cruise","Cruise"),Object(g.a)(n,"Temp","Temp"),n),k=["Beginner","Intermediate","Advanced","Expert"],N=[d,x,"Design"],I=[c,"Doubly Linked List","Queue","Stack","Hash Table",u,h,"Binary Search Tree",p,"Trie","Cache","Dynamic Programming",v,"Fibonacci","Binary Search","Sorting","Recursion","Sliding Window","Bitwise","Cyclic Sort",w,"Merge Intervals","Two Pointers",f,m,b,"K-Way-Merge","Topological Sort","Temp"],C={problemID:1,problemName:"Implement **prepend** in a *LinkedList* class.",problemText:"Write a **prepend** method in a *LinkedList* class that accepts an arbitrary `value` parameter, creates a new Node, and inserts it at the front of the list.  The method should return the original list.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"empty list, head value",inherit:[1],code:"ll.prepend(5);",evaluate:"ll.head.value;",expected:5},{id:3,name:"empty list, tail value",inherit:[1],code:"ll.prepend(6);",evaluate:"ll.tail.value;",expected:6},{id:4,name:"insert two nodes",inherit:[1,2],code:"ll.prepend(7);",evaluate:"ll.tail.value === 5 && ll.head.value === 7;",expected:!0},{id:5,name:"returns itself",inherit:[1,2],code:"",evaluate:"ll.prepend(10) === ll;",expected:!0}],setupCode:"",source:[],tags:[c,x],solution:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  prepend(value) {"},{stage:2,text:"    const newNode = new LinkedListNode(value, this.head);"},{stage:2,text:"    this.head = newNode;"},{stage:2,text:""},{stage:3,text:"    if (!this.tail) {"},{stage:3,text:"      this.tail = newNode;"},{stage:3,text:"    }"},{stage:2,text:""},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:"}"},{stage:0,text:""}]},_={problemID:2,problemName:"Implement **append** in a *LinkedList* class.",problemText:"Write an **append** method in a *LinkedList* class that accepts an arbitrary `value` parameter, creates a new Node, and inserts it at the end of the list.  The method should return the original list.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"append one node, check head",inherit:[1],code:"ll.append(5);",evaluate:"ll.head.value;",expected:5},{id:3,name:"append one node, check tail",inherit:[1,2],code:"",evaluate:"ll.tail.value;",expected:5},{id:4,name:"append two nodes, check head",inherit:[1,2],code:"ll.append(7);",evaluate:"ll.head.value;",expected:5},{id:5,name:"append two nodes, check tail",inherit:[1,2,4],code:"",evaluate:"ll.tail.value;",expected:7},{id:6,name:"returns itself",inherit:[1,2],code:"",evaluate:"ll.append(10) === ll;",expected:!0}],setupCode:"",source:[],tags:[c,x],solution:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  append(value) {"},{stage:2,text:"    const newNode = new LinkedListNode(value);"},{stage:2,text:""},{stage:3,text:"    if (!this.head) {"},{stage:4,text:"      this.head = newNode;"},{stage:4,text:"      this.tail = newNode;"},{stage:4,text:"      return this;"},{stage:3,text:"    }"},{stage:3,text:""},{stage:5,text:"    this.tail.next = newNode;"},{stage:5,text:"    this.tail = newNode;"},{stage:5,text:""},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:"}"},{stage:0,text:""}]},S="\nclass LinkedListNode {\n  constructor(value, next = null) {\n    this.value = value;\n    this.next = next;\n  }\n}\n\nclass LinkedList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n  \n  prepend(value) {\n    const newNode = new LinkedListNode(value, this.head);\n    this.head = newNode;\n    if (!this.tail) {\n      this.tail = newNode;\n    }\n    return this;\n  }\n\n  append(value) {\n    const newNode = new LinkedListNode(value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    this.tail = newNode;\n    return this;\n  }\n  \n  deleteHead() {\n    if (!this.head) {\n      return null;\n    }\n    const deletedHead = this.head;\n    if (this.head.next) {\n      this.head = this.head.next;\n    } else {\n      this.head = null;\n      this.tail = null;\n    }\n    return deletedHead;\n  }\n}\n",L="\nclass LinkedListNode {\n  constructor(key, value, next = null) {\n    this.key = key;\n    this.value = value;\n    this.next = next;\n  }\n}\n\nclass LinkedList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n  \n  append(key, value) {\n    const newNode = new LinkedListNode(key, value);\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n      return this;\n    }\n    this.tail.next = newNode;\n    this.tail = newNode;\n    return this;\n  }\n  \n  findKey(key) {\n    if (!this.head) {\n      return null;\n    }\n    let current = this.head;\n    while (current) {\n      if (current.key === key) {\n        return current;\n      }\n      current = current.next;\n    }\n    return null;\n  }\n\n  prepend(value) {\n    const newNode = new LinkedListNode(value, this.head);\n    this.head = newNode;\n    if (!this.tail) {\n      this.tail = newNode;\n    }\n    return this;\n  }\n  \n  deleteHead() {\n    if (!this.head) {\n      return null;\n    }\n    const deletedHead = this.head;\n    if (this.head.next) {\n      this.head = this.head.next;\n    } else {\n      this.head = null;\n      this.tail = null;\n    }\n    return deletedHead;\n  }\n\n  deleteKey(key) {\n    if (!this.head) {\n      return null;\n    }\n    if (key === this.head.key) {\n      const deletedHead = this.head;\n      if (this.head.next) {\n        this.head = this.head.next;\n      } else {\n        this.head = null;\n        this.tail = null;\n      }\n      return deletedHead;\n    } else if (key === this.tail.key) {\n      const deletedTail = this.tail;\n      let currentNode = this.head;\n      while (currentNode.next) {\n        if (!currentNode.next.next) {\n          currentNode.next = null;\n        } else {\n          currentNode = currentNode.next;\n        }\n      }\n      this.tail = currentNode;\n      return deletedTail;\n    } else {\n      let currentNode = this.head;\n      while (currentNode.next) {\n        if (currentNode.next.key === key) {\n          const deletedNode = currentNode.next;\n          currentNode.next = deletedNode.next;\n          return deletedNode;\n        }\n        currentNode = currentNode.next;\n      }\n      return null;\n    }\n  }\n}\n",T="\nLinkedList.prototype.append = function (value) {\n  const newNode = new LinkedListNode(value);\n  if (!this.head) {\n    this.head = newNode;\n    this.tail = newNode;\n    return this;\n  }\n  this.tail.next = newNode;\n  this.tail = newNode;\n  return this;\n};",E="\nLinkedList.prototype.toArray = function () {\n    const values = [];\n    let currentNode = this.head;\n    while (currentNode) {\n      values.push(currentNode.value);\n      currentNode = currentNode.next;\n    }\n    return values;\n  };",O="\nDoublyLinkedList.prototype.append = function(value) {\n  const newNode = new DoublyLinkedListNode(value);\n  if (!this.head) {\n    this.head = newNode;\n    this.tail = newNode;\n    return this;\n  }\n  this.tail.next = newNode;\n  newNode.previous = this.tail;\n  this.tail = newNode;\n  return this;\n}\n",q="\nHashTable.prototype.hash = function (key) {\n  const hash = Array.from(key).reduce(\n    (hashAccumulator, keySymbol) => hashAccumulator + keySymbol.charCodeAt(0),\n    0,\n  );\n  return hash % this.buckets.length;\n};",D="\nHashTable.prototype.get = function (key) {\n  const bucketLinkedList = this.buckets[this.hash(key)];\n  const node = bucketLinkedList.findKey(key);\n  return node ? node.value : undefined;\n};",M="\nHashTable.prototype.set = function (key, value) {\n  const keyHash = this.hash(key);\n  const bucketLinkedList = this.buckets[keyHash];\n  const node = bucketLinkedList.findKey(key);\n  if (!node) {\n    bucketLinkedList.append(key, value);\n  } else {\n    node.value = value;\n  }\n};",j="\nMinHeap.prototype.getLeftChildIndex = function (parentIndex) {\n  return 2 * parentIndex + 1;\n};\nMinHeap.prototype.getRightChildIndex = function (parentIndex) {\n  return 2 * parentIndex + 2;\n};\nMinHeap.prototype.hasLeftChild = function (parentIndex) {\n  return this.getLeftChildIndex(parentIndex) < this.heapContainer.length;\n};\nMinHeap.prototype.hasRightChild = function (parentIndex) {\n  return this.getRightChildIndex(parentIndex) < this.heapContainer.length;\n};\nMinHeap.prototype.leftChild = function (parentIndex) {\n  return this.heapContainer[this.getLeftChildIndex(parentIndex)];\n};\nMinHeap.prototype.rightChild = function (parentIndex) {\n  return this.heapContainer[this.getRightChildIndex(parentIndex)];\n};",R="\nMinHeap.prototype.heapifyDown = function (customStartIndex = 0) {\n  let currentIndex = customStartIndex;\n  let nextIndex = null;\n  while (this.hasLeftChild(currentIndex)) {\n    if (\n      this.hasRightChild(currentIndex) &&\n      this.rightChild(currentIndex) <= this.leftChild(currentIndex)\n    ) {\n      nextIndex = this.getRightChildIndex(currentIndex);\n    } else {\n      nextIndex = this.getLeftChildIndex(currentIndex);\n    }\n    if (this.heapContainer[currentIndex] <= this.heapContainer[nextIndex]) {\n      break;\n    }\n    this.swap(currentIndex, nextIndex);\n    currentIndex = nextIndex;\n  }\n};\n",H="\nMinHeap.prototype.heapifyUp = function (customStartIndex) {\n  let currentIndex = customStartIndex || this.heapContainer.length - 1;\n  while (\n    this.hasParent(currentIndex) &&\n    this.parent(currentIndex) > this.heapContainer[currentIndex]\n  ) {\n    this.swap(currentIndex, this.getParentIndex(currentIndex));\n    currentIndex = this.getParentIndex(currentIndex);\n  }\n};",P="\nMinHeap.prototype.swap = function (indexOne, indexTwo) {\n  const tmp = this.heapContainer[indexTwo];\n  this.heapContainer[indexTwo] = this.heapContainer[indexOne];\n  this.heapContainer[indexOne] = tmp;\n};\n",B="\nMinHeap.prototype.getParentIndex = function (childIndex) {\n    return Math.floor((childIndex - 1) / 2);\n  };\n  MinHeap.prototype.hasParent = function (childIndex) {\n    return this.getParentIndex(childIndex) >= 0;\n  };\n  MinHeap.prototype.parent = function (childIndex) {\n    return this.heapContainer[this.getParentIndex(childIndex)];\n  };\n",A="\nclass MinHeap {\n    constructor() {\n      this.heapContainer = [];\n    }\n  \n    getLeftChildIndex(parentIndex) {\n      return 2 * parentIndex + 1;\n    }\n  \n    getRightChildIndex(parentIndex) {\n      return 2 * parentIndex + 2;\n    }\n  \n    hasLeftChild(parentIndex) {\n      return this.getLeftChildIndex(parentIndex) < this.heapContainer.length;\n    }\n  \n    hasRightChild(parentIndex) {\n      return this.getRightChildIndex(parentIndex) < this.heapContainer.length;\n    }\n  \n    leftChild(parentIndex) {\n      return this.heapContainer[this.getLeftChildIndex(parentIndex)];\n    }\n  \n    rightChild(parentIndex) {\n      return this.heapContainer[this.getRightChildIndex(parentIndex)];\n    }\n  \n    getParentIndex(childIndex) {\n      return Math.floor((childIndex - 1) / 2);\n    }\n  \n    hasParent(childIndex) {\n      return this.getParentIndex(childIndex) >= 0;\n    }\n  \n    parent(childIndex) {\n      return this.heapContainer[this.getParentIndex(childIndex)];\n    }\n  \n    poll() {\n      if (this.heapContainer.length === 0) {\n        return null;\n      }\n      if (this.heapContainer.length === 1) {\n        return this.heapContainer.pop();\n      }\n      const item = this.heapContainer[0];\n      this.heapContainer[0] = this.heapContainer.pop();\n      this.heapifyDown();\n      return item;\n    }\n  \n    add(item) {\n      this.heapContainer.push(item);\n      this.heapifyUp();\n      return this;\n    }\n  \n    heapifyUp(customStartIndex) {\n      let currentIndex = customStartIndex || this.heapContainer.length - 1;\n  \n      while (\n        this.hasParent(currentIndex) &&\n        !(this.parent(currentIndex) <= this.heapContainer[currentIndex])\n      ) {\n        this.swap(currentIndex, this.getParentIndex(currentIndex));\n        currentIndex = this.getParentIndex(currentIndex);\n      }\n    }\n  \n    heapifyDown(customStartIndex = 0) {\n      let currentIndex = customStartIndex;\n      let nextIndex = null;\n  \n      while (this.hasLeftChild(currentIndex)) {\n        if (\n          this.hasRightChild(currentIndex) &&\n          this.rightChild(currentIndex) <= this.leftChild(currentIndex)\n        ) {\n          nextIndex = this.getRightChildIndex(currentIndex);\n        } else {\n          nextIndex = this.getLeftChildIndex(currentIndex);\n        }\n  \n        if (this.heapContainer[currentIndex] <= this.heapContainer[nextIndex]) {\n          break;\n        }\n  \n        this.swap(currentIndex, nextIndex);\n        currentIndex = nextIndex;\n      }\n    }\n  \n    swap(indexOne, indexTwo) {\n      const tmp = this.heapContainer[indexTwo];\n      this.heapContainer[indexTwo] = this.heapContainer[indexOne];\n      this.heapContainer[indexOne] = tmp;\n    }\n  \n    peek() {\n      if (this.heapContainer.length === 0) {\n        return null;\n      }\n  \n      return this.heapContainer[0];\n    }\n  \n    length() {\n      return this.heapContainer.length;\n    }\n  }\n",J="\nclass MaxHeap {\n    constructor() {\n      this.heapContainer = [];\n    }\n  \n    // child utils\n    getLeftChildIndex(parentIndex) {\n      return 2 * parentIndex + 1;\n    }\n  \n    getRightChildIndex(parentIndex) {\n      return 2 * parentIndex + 2;\n    }\n  \n    hasLeftChild(parentIndex) {\n      return this.getLeftChildIndex(parentIndex) < this.heapContainer.length;\n    }\n  \n    hasRightChild(parentIndex) {\n      return this.getRightChildIndex(parentIndex) < this.heapContainer.length;\n    }\n  \n    leftChild(parentIndex) {\n      return this.heapContainer[this.getLeftChildIndex(parentIndex)];\n    }\n  \n    rightChild(parentIndex) {\n      return this.heapContainer[this.getRightChildIndex(parentIndex)];\n    }\n  \n    // parent utils\n    getParentIndex(childIndex) {\n      return Math.floor((childIndex - 1) / 2);\n    }\n  \n    hasParent(childIndex) {\n      return this.getParentIndex(childIndex) >= 0;\n    }\n  \n    parent(childIndex) {\n      return this.heapContainer[this.getParentIndex(childIndex)];\n    }\n  \n    // peek\n    peek() {\n      if (this.heapContainer.length === 0) {\n        return null;\n      }\n  \n      return this.heapContainer[0];\n    }\n  \n    // poll\n    poll() {\n      if (this.heapContainer.length === 0) {\n        return null;\n      }\n  \n      if (this.heapContainer.length === 1) {\n        return this.heapContainer.pop();\n      }\n  \n      const item = this.heapContainer[0];\n  \n      // Move the last element from the end to the head.\n      this.heapContainer[0] = this.heapContainer.pop();\n      this.heapifyDown();\n  \n      return item;\n    }\n  \n    // add\n    add(item) {\n      this.heapContainer.push(item);\n      this.heapifyUp();\n      return this;\n    }\n  \n    // heapify up for min heap and max heap\n    heapifyUp(customStartIndex) {\n      // Take the last element (last in array or the bottom left in a tree)\n      // in the heap container and lift it up until it is in the correct\n      // order with respect to its parent element.\n      let currentIndex = customStartIndex || this.heapContainer.length - 1;\n  \n      while (\n        this.hasParent(currentIndex) &&\n        !(this.parent(currentIndex) >= this.heapContainer[currentIndex])\n      ) {\n        this.swap(currentIndex, this.getParentIndex(currentIndex));\n        currentIndex = this.getParentIndex(currentIndex);\n      }\n    }\n  \n    // heapify down for min heap or max heap\n    heapifyDown(customStartIndex = 0) {\n      // Compare the parent element to its children and swap parent with the appropriate\n      // child (smallest child for MinHeap, largest child for MaxHeap).\n      // Do the same for next children after swap.\n      let currentIndex = customStartIndex;\n      let nextIndex = null;\n  \n      while (this.hasLeftChild(currentIndex)) {\n        if (\n          this.hasRightChild(currentIndex) &&\n          this.rightChild(currentIndex) >= this.leftChild(currentIndex)\n        ) {\n          nextIndex = this.getRightChildIndex(currentIndex);\n        } else {\n          nextIndex = this.getLeftChildIndex(currentIndex);\n        }\n  \n        if (this.heapContainer[currentIndex] >= this.heapContainer[nextIndex]) {\n          break;\n        }\n  \n        this.swap(currentIndex, nextIndex);\n        currentIndex = nextIndex;\n      }\n    }\n  \n    // no, but added as utility\n    swap(indexOne, indexTwo) {\n      const tmp = this.heapContainer[indexTwo];\n      this.heapContainer[indexTwo] = this.heapContainer[indexOne];\n      this.heapContainer[indexOne] = tmp;\n    }\n  }\n",G="\nclass Heap {\n    constructor(fn) {\n      this.heapContainer = [];\n      this.isCorrectOrder = fn; // (a,b) => {}   min: a <= b, max a >= b\n    }\n  \n    getLeftChildIndex(parentIndex) {\n      return 2 * parentIndex + 1;\n    }\n  \n    getRightChildIndex(parentIndex) {\n      return 2 * parentIndex + 2;\n    }\n  \n    hasLeftChild(parentIndex) {\n      return this.getLeftChildIndex(parentIndex) < this.heapContainer.length;\n    }\n  \n    hasRightChild(parentIndex) {\n      return this.getRightChildIndex(parentIndex) < this.heapContainer.length;\n    }\n  \n    leftChild(parentIndex) {\n      return this.heapContainer[this.getLeftChildIndex(parentIndex)];\n    }\n  \n    rightChild(parentIndex) {\n      return this.heapContainer[this.getRightChildIndex(parentIndex)];\n    }\n  \n    getParentIndex(childIndex) {\n      return Math.floor((childIndex - 1) / 2);\n    }\n  \n    hasParent(childIndex) {\n      return this.getParentIndex(childIndex) >= 0;\n    }\n  \n    parent(childIndex) {\n      return this.heapContainer[this.getParentIndex(childIndex)];\n    }\n  \n    peek() {\n      return this.heapContainer[0] || null;\n    }\n  \n    poll() {\n      if (this.heapContainer.length === 0) {\n        return null;\n      }\n      if (this.heapContainer.length === 1) {\n        return this.heapContainer.pop();\n      }\n      const item = this.heapContainer[0];\n      this.heapContainer[0] = this.heapContainer.pop();\n      this.heapifyDown();\n      return item;\n    }\n  \n    add(item) {\n      this.heapContainer.push(item);\n      this.heapifyUp();\n      return this;\n    }\n  \n    heapifyUp(customStartIndex) {\n      let currentIndex = customStartIndex || this.heapContainer.length - 1;\n  \n      while (\n        this.hasParent(currentIndex) &&\n        !this.isCorrectOrder(this.parent(currentIndex), this.heapContainer[currentIndex])\n      ) {\n        this.swap(currentIndex, this.getParentIndex(currentIndex));\n        currentIndex = this.getParentIndex(currentIndex);\n      }\n    }\n  \n    heapifyDown(customStartIndex = 0) {\n      let currentIndex = customStartIndex;\n      let nextIndex = null;\n  \n      while (this.hasLeftChild(currentIndex)) {\n        if (\n          this.hasRightChild(currentIndex) &&\n          this.isCorrectOrder(this.rightChild(currentIndex), this.leftChild(currentIndex))\n        ) {\n          nextIndex = this.getRightChildIndex(currentIndex);\n        } else {\n          nextIndex = this.getLeftChildIndex(currentIndex);\n        }\n  \n        if (this.isCorrectOrder(this.heapContainer[currentIndex], this.heapContainer[nextIndex])) {\n          break;\n        }\n  \n        this.swap(currentIndex, nextIndex);\n        currentIndex = nextIndex;\n      }\n    }\n  \n    swap(indexOne, indexTwo) {\n      const tmp = this.heapContainer[indexTwo];\n      this.heapContainer[indexTwo] = this.heapContainer[indexOne];\n      this.heapContainer[indexOne] = tmp;\n    }\n  \n    remove(item, eqFn) {\n      // Find number of items to remove.\n      const numberOfItemsToRemove = this.find(item, eqFn).length;\n  \n      for (let iteration = 0; iteration < numberOfItemsToRemove; iteration += 1) {\n        // We need to find item index to remove each time after removal since\n        // indices are being changed after each heapify process.\n        const indexToRemove = this.find(item, eqFn).pop();\n  \n        // If we need to remove last child in the heap then just remove it.\n        // There is no need to heapify the heap afterwards.\n        if (indexToRemove === this.heapContainer.length - 1) {\n          this.heapContainer.pop();\n        } else {\n          // Move last element in heap to the vacant (removed) position.\n          this.heapContainer[indexToRemove] = this.heapContainer.pop();\n  \n          // Get parent.\n          const parentItem = this.parent(indexToRemove);\n  \n          // If there is no parent or parent is in correct order with the node\n          // we're going to delete then heapify down. Otherwise heapify up.\n          if (\n            this.hasLeftChild(indexToRemove) &&\n            (!parentItem || this.isCorrectOrder(parentItem, this.heapContainer[indexToRemove]))\n          ) {\n            this.heapifyDown(indexToRemove);\n          } else {\n            this.heapifyUp(indexToRemove);\n          }\n        }\n      }\n  \n      return this;\n    }\n  \n    find(item, eqFn) {\n      const foundItemIndices = [];\n  \n      for (let itemIndex = 0; itemIndex < this.heapContainer.length; itemIndex += 1) {\n        // todo need equality fn here\n        if (eqFn(item, this.heapContainer[itemIndex])) {\n          foundItemIndices.push(itemIndex);\n        }\n      }\n  \n      return foundItemIndices;\n    }\n  \n    length() {\n      return this.heapContainer.length;\n    }\n  }\n  \n\n",F="\nBinarySearchTree.prototype.insert = function(value) {\n    const thisNode = new BinarySearchTreeNode(value);\n    if (!this.root) {\n      this.root = thisNode;\n    } else {\n      let currentRoot = this.root;\n      while (true) {\n        if (currentRoot.value > value) {\n          if (currentRoot.left != null) {\n            currentRoot = currentRoot.left;\n          } else {\n            currentRoot.left = thisNode;\n            break;\n          }\n        } else if (currentRoot.value < value) {\n          if (currentRoot.right != null) {\n            currentRoot = currentRoot.right;\n          } else {\n            currentRoot.right = thisNode;\n            break;\n          }\n        } else {\n          break;\n        }\n      }\n    }\n  };\n",W="\n  BinarySearchTree.prototype.tempNodeList = [];\n  BinarySearchTree.prototype.callback = function (value) {\n    BinarySearchTree.prototype.tempNodeList.push(value);\n  };\n  BinarySearchTree.prototype.clearTempNodeList = function (value) {\n    BinarySearchTree.prototype.tempNodeList = [];\n  };\n  ",K="\nclass TreeNode {\n    constructor(val) {\n      this.val = val;\n      this.left = null;\n      this.right = null;\n    }\n  }\n",V="\nGraph.prototype.addEdge = function(startVertexKey, endVertexKey, edgeWeight = 1) {\n    if (!this.vertices[startVertexKey]) {\n      this.addVertex(startVertexKey);\n    }\n    if (!this.vertices[endVertexKey]) {\n      this.addVertex(endVertexKey);\n    }\n    const edge = new Edge(edgeWeight);\n    this.adjList[startVertexKey][endVertexKey] = edge;\n    if (!this.isDirected) {\n      this.adjList[endVertexKey][startVertexKey] = edge;\n    }\n  };\n",z="\nGraph.prototype.addVertex = function (key) {\n    const vertex = new Vertex(key);\n    this.vertices[key] = vertex;\n    if (!this.adjList[key]) {\n      this.adjList[key] = {};\n    }\n  };\n",Y="\nGraph.prototype.tempSet = [];\nGraph.prototype.callback = function(key) {\n  Graph.prototype.tempSet.push(key);\n};\n",U="\nTrie.prototype.search = function(word) {\n    let current = this.root;\n    for (let i = 0; i < word.length; i++) {\n      const ch = word.charAt(i);\n      const node = current.children[ch];\n      if (node == null) {\n        return false;\n      }\n      current = node;\n    }\n    return current.endOfWord;\n  };\n",Q="\nTrie.prototype.insert = function(word) {\n    let current = this.root;\n    for (let i = 0; i < word.length; i++) {\n      const ch = word.charAt(i);\n      let node = current.children[ch];\n      if (node == null) {\n        node = new TrieNode();\n        current.children[ch] = node;\n      }\n      current = node;\n    }\n    current.endOfWord = true;\n  };\n",X={problemID:3,problemName:"Implement **delete** in a *LinkedList* class.",problemText:"Write a **delete** method in a *LinkedList* class that accepts an arbitrary `value` parameter and removes all nodes that match that value.  The method should return the last node deleted (or `null` if no match found).",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"delete head return value",inherit:[1],code:"ll.append(5);ll.append(4);ll.append(7);ll.append(8);",evaluate:"ll.delete(5).value;",expected:5},{id:3,name:"delete tail return value",inherit:[1,2],code:"",evaluate:"ll.delete(8).value;",expected:8},{id:4,name:"delete head resets head",inherit:[1,2],code:"",evaluate:"ll.delete(5);ll.head.value;",expected:4},{id:5,name:"delete tail resets tail",inherit:[1,2],code:"",evaluate:"ll.delete(8);ll.tail.value;",expected:7},{id:6,name:"delete second item, head points to correct next",inherit:[1,2],code:"",evaluate:"ll.delete(4);ll.head.next.value;",expected:7}],setupCode:"".concat(T),source:[],tags:[c,x],solution:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  delete(value) {"},{stage:2,text:"    if (!this.head) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:2,text:""},{stage:3,text:"    let deletedNode = null;"},{stage:3,text:""},{stage:4,text:"    while (this.head && this.head.value === value) {"},{stage:4,text:"      deletedNode = this.head;"},{stage:4,text:"      this.head = this.head.next;"},{stage:4,text:"    }"},{stage:4,text:""},{stage:5,text:"    let currentNode = this.head;"},{stage:5,text:""},{stage:5,text:"    if (currentNode !== null) {"},{stage:6,text:"      while (currentNode.next) {"},{stage:6,text:"        if (currentNode.next.value === value) {"},{stage:7,text:"          deletedNode = currentNode.next;"},{stage:7,text:"          currentNode.next = currentNode.next.next;"},{stage:7,text:"        } else {"},{stage:7,text:"          currentNode = currentNode.next;"},{stage:6,text:"        }"},{stage:6,text:"      }"},{stage:5,text:"    }"},{stage:5,text:""},{stage:8,text:"    if (this.tail.value === value) {"},{stage:8,text:"      this.tail = currentNode;"},{stage:8,text:"    }"},{stage:3,text:""},{stage:2,text:"    return deletedNode;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Z={problemID:4,problemName:"Implement **find** in a *LinkedList* class.",problemText:"Write a **find** method in a *LinkedList* class that accepts an arbitrary `value` parameter and returns the first node that matches that value, or `null` if no matching value was found.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"find head value",inherit:[1],code:"ll.append(5);ll.append(4);ll.append(7);ll.append(8);",evaluate:"ll.find(5).value;",expected:5},{id:3,name:"find tail value",inherit:[1,2],code:"",evaluate:"ll.find(8).value;",expected:8},{id:4,name:"find a middle value",inherit:[1,2],code:"",evaluate:"ll.find(7).value;",expected:7},{id:5,name:"return null for non-existent value",inherit:[1,2],code:"",evaluate:"ll.find(17);",expected:null},{id:6,name:"return null when empty list",inherit:[1],code:"",evaluate:"ll.find(27);",expected:null}],setupCode:"".concat(T),source:[],tags:[c,x],solution:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  find(value) {"},{stage:2,text:"    let currentNode = this.head;"},{stage:2,text:""},{stage:3,text:"    while (currentNode) {"},{stage:4,text:"      if (currentNode.value === value) {"},{stage:4,text:"        return currentNode;"},{stage:4,text:"      }"},{stage:4,text:"      currentNode = currentNode.next;"},{stage:3,text:"    }"},{stage:3,text:""},{stage:2,text:"    return null;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},$={problemID:5,problemName:"Implement **deleteTail** in a *LinkedList* class.",problemText:"Write a **deleteTail** method in a *LinkedList* class that will remove the last node (the tail) of a list (if it exists, else null) and return it.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"delete tail and find return value",inherit:[1],code:"ll.append(5);ll.append(4);ll.append(7);ll.append(8);",evaluate:"ll.deleteTail().value;",expected:8},{id:3,name:"properly resets so following tail element can be deleted",inherit:[1,2],code:"",evaluate:"ll.deleteTail();ll.deleteTail().value;",expected:7},{id:4,name:"deleting tail of an empty list returns null",inherit:[1],code:"",evaluate:"ll.deleteTail();",expected:null}],setupCode:"".concat(T),source:[],tags:[c,x],solution:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  deleteTail() {"},{stage:2,text:"    const deletedTail = this.tail;"},{stage:3,text:""},{stage:3,text:"    if (this.head === this.tail) {"},{stage:4,text:"      this.head = null;"},{stage:4,text:"      this.tail = null;"},{stage:4,text:"      return deletedTail;"},{stage:3,text:"    }"},{stage:3,text:""},{stage:5,text:"    let currentNode = this.head;"},{stage:5,text:"    while (currentNode.next) {"},{stage:6,text:"      if (!currentNode.next.next) {"},{stage:7,text:"        currentNode.next = null;"},{stage:6,text:"      } else {"},{stage:7,text:"        currentNode = currentNode.next;"},{stage:6,text:"      }"},{stage:5,text:"    }"},{stage:6,text:""},{stage:6,text:"    this.tail = currentNode;"},{stage:6,text:""},{stage:2,text:"    return deletedTail;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},ee={problemID:6,problemName:"Implement **deleteHead** in a *LinkedList* class.",problemText:"Write a **deleteHead** method in a *LinkedList* class that will remove the first node (the head) of a list (if it exists, else null) and return it.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"delete head and find return value",inherit:[1],code:"ll.append(5);ll.append(4);ll.append(7);ll.append(8);",evaluate:"ll.deleteHead().value;",expected:5},{id:3,name:"delete head, properly set next head, delete and find return value",inherit:[1,2],code:"",evaluate:"ll.deleteHead();ll.deleteHead().value;",expected:4},{id:4,name:"delete head from empty list returns null",inherit:[1],code:"",evaluate:"ll.deleteHead();",expected:null}],setupCode:"".concat(T),source:[],tags:[c,x],solution:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  deleteHead() {"},{stage:2,text:"    if (!this.head) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:3,text:""},{stage:3,text:"    const deletedHead = this.head;"},{stage:3,text:""},{stage:4,text:"    if (this.head.next) {"},{stage:5,text:"      this.head = this.head.next;"},{stage:4,text:"    } else {"},{stage:6,text:"      this.head = null;"},{stage:6,text:"      this.tail = null;"},{stage:4,text:"    }"},{stage:3,text:""},{stage:3,text:"    return deletedHead;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},te={problemID:7,problemName:"Implement **fromArray** in a *LinkedList* class.",problemText:"Given a *LinkedList* class with an **append** method, create a **fromArray** method that will take in an array of `values` as a parameter and return a *LinkedList*.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"converts array to linked list (and back)",inherit:[1],code:"ll.fromArray([1,2,3,4,5]);",evaluate:"ll.toArray()",expected:JSON.stringify([1,2,3,4,5])},{id:3,name:"double check values by stepping through (head)",inherit:[1,2],code:"",evaluate:"ll.head.value",expected:1},{id:4,name:"double check values by stepping through (tail)",inherit:[1,2],code:"",evaluate:"ll.tail.value",expected:5},{id:5,name:"empty fromArray results in empty list",inherit:[1],code:"ll.fromArray([]);",evaluate:"ll.head == null;",expected:!0},{id:6,name:"empty fromArray results in empty list",inherit:[1,5],code:"",evaluate:"ll.toArray();",expected:JSON.stringify([])},{id:7,name:"double check values by stepping through (head next)",inherit:[1,2],code:"",evaluate:"ll.head.next.value",expected:2}],setupCode:"".concat(T).concat(E),source:[],tags:[c,x],solution:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED: append(value: any) LinkedList"},{stage:-1,text:""},{stage:1,text:"  fromArray(values) {"},{stage:3,text:"    values.forEach(value => this.append(value));"},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},ae={problemID:8,problemName:"Implement **toArray** in a *LinkedList* class.",problemText:"Provide a class method **toArray** that converts the value property of each *LinkedListNode* into a new array item, and returns that array.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"converts empty linked list to empty array",inherit:[1],code:"",evaluate:"ll.toArray();",expected:JSON.stringify([])},{id:3,name:"linked list of 4 items into array",inherit:[1],code:"ll.append(2).append(3).append(4).append(5);",evaluate:"ll.toArray();",expected:JSON.stringify([2,3,4,5])}],setupCode:"".concat(T),source:[],tags:[c,x],solution:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  toArray() {"},{stage:2,text:"    const values = [];"},{stage:2,text:""},{stage:3,text:"    let currentNode = this.head;"},{stage:3,text:"    while (currentNode) {"},{stage:4,text:"      values.push(currentNode.value);"},{stage:4,text:"      currentNode = currentNode.next;"},{stage:3,text:"    }"},{stage:3,text:""},{stage:2,text:"    return values;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},ne={problemID:9,problemName:"Reverse a *Linked List*.",problemText:"Write a **reverse** method to reverse a Linked List in-place (not using a copy) which then returns itself.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ll=new LinkedList();",evaluate:"Boolean(ll);",expected:!0},{id:2,name:"reverse a list",inherit:[1],code:"ll.append(1).append(2).append(3).append(4);",evaluate:"ll.reverse().toArray();",expected:JSON.stringify([4,3,2,1])},{id:3,name:"reverse an empty list",inherit:[1],code:"",evaluate:"ll.reverse().toArray();",expected:JSON.stringify([])}],setupCode:"".concat(T).concat(E),source:[],tags:[c,x],solution:[{stage:0,text:"class LinkedListNode {"},{stage:0,text:"  constructor(value, next = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  reverse() {"},{stage:1,text:"    let currNode = this.head;"},{stage:2,text:"    let prevNode = null;"},{stage:2,text:"    let nextNode = null;"},{stage:3,text:""},{stage:4,text:"    while (currNode) {"},{stage:5,text:"      nextNode = currNode.next;"},{stage:5,text:"      currNode.next = prevNode;"},{stage:6,text:"      prevNode = currNode;"},{stage:6,text:"      currNode = nextNode;"},{stage:4,text:"    }"},{stage:4,text:""},{stage:7,text:"    this.tail = this.head;"},{stage:7,text:"    this.head = prevNode;"},{stage:3,text:""},{stage:2,text:"    return this;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},se={problemID:10,problemName:"Implement **prepend** in a *DoublyLinkedList* class.",problemText:"Write a **prepend** method in a *DoublyLinkedList* class that accepts an arbitrary `value` parameter, creates a *DoublyLinkedListNode*, and inserts it at the front of the list.  The method should return the original list.",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"prepend element onto empty list",inherit:[1],code:"dll.prepend(5);",evaluate:"dll.head.value;",expected:5},{id:3,name:"prepend element onto empty list, tail correct",inherit:[1,2],code:"",evaluate:"dll.tail.value;",expected:5},{id:4,name:"prepend 2nd element onto list, head correct",inherit:[1],code:"dll.prepend(7);",evaluate:"dll.head.value;",expected:7},{id:5,name:"prepend 2nd element onto list, tail correct",inherit:[1,2,4],code:"",evaluate:"dll.tail.value;",expected:5},{id:6,name:"prepend 2nd element onto list, head next correct",inherit:[1,2,4],code:"",evaluate:"dll.head.next.value;",expected:5}],setupCode:"",source:[],tags:["Doubly Linked List",x],solution:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  prepend(value) {"},{stage:2,text:"    const newNode = new DoublyLinkedListNode(value, this.head);"},{stage:2,text:""},{stage:3,text:"    if (this.head) {"},{stage:4,text:"      this.head.previous = newNode;"},{stage:3,text:"    }"},{stage:4,text:"    this.head = newNode;"},{stage:3,text:""},{stage:5,text:"    if (!this.tail) {"},{stage:5,text:"      this.tail = newNode;"},{stage:5,text:"    }"},{stage:4,text:""},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},re={problemID:11,problemName:"Implement **append** in a *DoublyLinkedList* class.",problemText:"Write an **append** method in a *DoublyLinkedList* class that accepts an arbitrary `value` parameter, creates a *DoublyLinkedListNode*, and adds it to the end of the list.  The method should return the original list.",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"append onto empty list, head set correctly",inherit:[1],code:"dll.append(3);",evaluate:"dll.head.value;",expected:3},{id:3,name:"append onto empty list, tail set correctly",inherit:[1,2],code:"",evaluate:"dll.tail.value;",expected:3},{id:4,name:"append 2nd item onto list, check head",inherit:[1,2],code:"dll.append(8);",evaluate:"dll.head.value;",expected:3},{id:5,name:"append 2nd item onto list, check tail",inherit:[1,2,4],code:"",evaluate:"dll.tail.value;",expected:8},{id:6,name:"append 2nd item onto list, check head next",inherit:[1,2,4],code:"",evaluate:"dll.head.next.value;",expected:8}],setupCode:"",source:[],tags:["Doubly Linked List",x],solution:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  append(value) {"},{stage:2,text:"    const newNode = new DoublyLinkedListNode(value);"},{stage:2,text:""},{stage:3,text:"    if (!this.head) {"},{stage:4,text:"      this.head = newNode;"},{stage:4,text:"      this.tail = newNode;"},{stage:4,text:"      return this;"},{stage:3,text:"    }"},{stage:3,text:""},{stage:5,text:"    this.tail.next = newNode;"},{stage:5,text:"    newNode.previous = this.tail;"},{stage:5,text:"    this.tail = newNode;"},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},ie={problemID:12,problemName:"Implement **delete** in a *DoublyLinkedList* class.",problemText:"Write a **delete** method in a *DoublyLinkedList* class that accepts an arbitrary `value` parameter and deletes all `DoublyLinkedListNode` nodes that have a matching value.  The method should return the last node deleted (or `null` if no match found).",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"return null on empty list",inherit:[1],code:"",evaluate:"dll.delete(5);",expected:null},{id:3,name:"add and cleanly remove node from list (check head)",inherit:[1],code:"dll.append(5);dll.delete(5);",evaluate:"dll.head",expected:null},{id:4,name:"add and cleanly remove node from list (check tail)",inherit:[1,3],code:"",evaluate:"dll.tail",expected:null},{id:5,name:"add 3 nodes and delete the first",inherit:[1],code:"dll.append(1).append(2).append(3);",evaluate:"dll.delete(1);dll.head.value;",expected:2},{id:6,name:"add 3 nodes and delete the first (check tail)",inherit:[1,5],code:"",evaluate:"dll.delete(1);dll.tail.value;",expected:3},{id:7,name:"add 3 nodes and delete the second (check head connector)",inherit:[1,5],code:"",evaluate:"dll.delete(2);dll.head.next.value;",expected:3},{id:8,name:"add 3 nodes and delete the last (check tail)",inherit:[1,5],code:"",evaluate:"dll.delete(3);dll.tail.value;",expected:2},{id:9,name:"add 3 nodes and delete them all (check head)",inherit:[1,5],code:"",evaluate:"dll.delete(3);dll.delete(2);dll.delete(1);dll.head;",expected:null},{id:10,name:"add 3 nodes and delete them all (check tail)",inherit:[1,5],code:"",evaluate:"dll.delete(3);dll.delete(2);dll.delete(1);dll.tail;",expected:null}],setupCode:"".concat(O),source:[],tags:["Doubly Linked List",x],solution:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  delete(value) {"},{stage:2,text:"    if (!this.head) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:2,text:""},{stage:3,text:"    let deletedNode = null;"},{stage:3,text:"    let currentNode = this.head;"},{stage:3,text:""},{stage:4,text:"    while (currentNode) {"},{stage:5,text:"      if (currentNode.value === value) {"},{stage:6,text:"        deletedNode = currentNode;"},{stage:6,text:""},{stage:6,text:"        if (deletedNode === this.head) {"},{stage:7,text:"          this.head = deletedNode.next;"},{stage:7,text:""},{stage:8,text:"          if (this.head) {"},{stage:8,text:"            this.head.previous = null;"},{stage:8,text:"          }"},{stage:8,text:""},{stage:9,text:"          if (deletedNode === this.tail) {"},{stage:9,text:"            this.tail = null;"},{stage:9,text:"          }"},{stage:6,text:"        } else if (deletedNode === this.tail) {"},{stage:10,text:"          this.tail = deletedNode.previous;"},{stage:10,text:"          this.tail.next = null;"},{stage:6,text:"        } else {"},{stage:11,text:"          const previousNode = deletedNode.previous;"},{stage:11,text:"          const nextNode = deletedNode.next;"},{stage:11,text:""},{stage:12,text:"          previousNode.next = nextNode;"},{stage:12,text:"          nextNode.previous = previousNode;"},{stage:6,text:"        }"},{stage:5,text:"      }"},{stage:5,text:""},{stage:13,text:"      currentNode = currentNode.next;"},{stage:4,text:"    }"},{stage:7,text:""},{stage:7,text:"    return deletedNode;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},oe={problemID:13,problemName:"Implement **find** in a *DoublyLinkedList* class.",problemText:"Write a **find** method in a *DoublyLinkedList* class that accepts an arbitrary `value` parameter and returns the first `DoublyLinkedListNode` that has a matching value (or `null` if no match found).",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"find on an empty list",inherit:[1],code:"",evaluate:"dll.find(5);",expected:null},{id:3,name:"add one item, find that item",inherit:[1],code:"dll.append(4);",evaluate:"dll.find(4).value;",expected:4},{id:4,name:"add one item, find an item that does not exist",inherit:[1],code:"dll.append(4);",evaluate:"dll.find(6);",expected:null},{id:5,name:"add three items, find an item",inherit:[1],code:"dll.append(1).append(2).append(3);",evaluate:"dll.find(2).value;",expected:2},{id:6,name:"add three items -two dupicates, return the first",inherit:[1],code:"dll.append(1).append(2).append(2);",evaluate:"dll.find(2) === dll.head.next;",expected:!0}],setupCode:"".concat(O),source:[],tags:["Doubly Linked List",x],solution:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  find(value) {"},{stage:2,text:"    if (!this.head) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:3,text:""},{stage:3,text:"    let currentNode = this.head;"},{stage:3,text:""},{stage:4,text:"    while (currentNode) {"},{stage:5,text:"      if (currentNode.value === value) {"},{stage:5,text:"        return currentNode;"},{stage:5,text:"      }"},{stage:6,text:""},{stage:6,text:"      currentNode = currentNode.next;"},{stage:4,text:"    }"},{stage:4,text:""},{stage:4,text:"    return null;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},le={problemID:14,problemName:"Implement **deleteTail** in a *DoublyLinkedList* class.",problemText:"Write a **deleteTail** method in a *DoublyLinkedList* class that will remove and return the last `DoublyLinkedListNode` in the list, or `null` if the list is empty.",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"return null if list is empty",inherit:[1],code:"",evaluate:"dll.deleteTail();",expected:null},{id:3,name:"return item from 1 item list.",inherit:[1],code:"dll.append(5);",evaluate:"dll.deleteTail().value;",expected:5},{id:4,name:"return item from 1 item list - head set correctly.",inherit:[1,3],code:"dll.deleteTail();",evaluate:"dll.head;",expected:null},{id:5,name:"return item from 1 item list - tail set correctly.",inherit:[1,3],code:"dll.deleteTail();",evaluate:"dll.tail;",expected:null},{id:6,name:"add 3 items, deleteTail twice.",inherit:[1],code:"dll.append(5).append(4).append(3);dll.deleteTail();dll.deleteTail();",evaluate:"dll.head.value",expected:5},{id:7,name:"add 3 items, deleteTail twice.",inherit:[1,6],code:"",evaluate:"dll.tail.value",expected:5}],setupCode:"".concat(O),source:[],tags:["Doubly Linked List",x],solution:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  deleteTail() {"},{stage:2,text:"    if (!this.tail) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:3,text:""},{stage:3,text:"    if (this.head === this.tail) {"},{stage:4,text:"      const deletedTail = this.tail;"},{stage:4,text:"      this.head = null;"},{stage:4,text:"      this.tail = null;"},{stage:4,text:"      return deletedTail;"},{stage:3,text:"    }"},{stage:5,text:""},{stage:6,text:"    const deletedTail = this.tail;"},{stage:6,text:"    this.tail = this.tail.previous;"},{stage:6,text:"    this.tail.next = null;"},{stage:5,text:""},{stage:5,text:"    return deletedTail;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},ge={problemID:15,problemName:"Implement **deleteHead** in a *DoublyLinkedList* class.",problemText:"Write a **deleteHead** method in a *DoublyLinkedList* class that will remove and return the first `DoublyLinkedListNode` in the list (or `null` if the list is empty).",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"deleteHead from an empty list returns null",inherit:[1],code:"",evaluate:"dll.deleteHead();",expected:null},{id:3,name:"add item and delete item",inherit:[1],code:"dll.append(8);",evaluate:"dll.deleteHead().value;",expected:8},{id:4,name:"add item and delete item - check head;",inherit:[1],code:"dll.append(8);dll.deleteHead();",evaluate:"dll.head;",expected:null},{id:5,name:"add item and delete item",inherit:[1,4],code:"",evaluate:"dll.tail;",expected:null},{id:6,name:"add 3 items and delete one",inherit:[1],code:"dll.append(6).append(7).append(8);",evaluate:"dll.deleteHead().value;",expected:6},{id:7,name:"add 3 items and delete one - check head",inherit:[1,6],code:"dll.deleteHead();",evaluate:"dll.head.value;",expected:7},{id:8,name:"add 3 items and delete one - check tail",inherit:[1,6,7],code:"",evaluate:"dll.tail.value;",expected:8}],setupCode:"".concat(O),source:[],tags:["Doubly Linked List",x],solution:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  deleteHead() {"},{stage:2,text:"    if (!this.head) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:3,text:""},{stage:3,text:"    const deletedHead = this.head;"},{stage:3,text:""},{stage:4,text:"    if (this.head.next) {"},{stage:5,text:"      this.head = this.head.next;"},{stage:5,text:"      this.head.previous = null;"},{stage:4,text:"    } else {"},{stage:6,text:"      this.head = null;"},{stage:6,text:"      this.tail = null;"},{stage:4,text:"    }"},{stage:4,text:""},{stage:4,text:"    return deletedHead;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},xe={problemID:16,problemName:"Implement **fromArray** in a *DoublyLinkedList* class.",problemText:"Given a *DoublyLinkedList* class with an **append** method, create a **fromArray** method that will take in an array of `values` as a parameter, populate corresponding `DoublyLinkedListNode`'s and return the list.",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"empty array creates empty list - check head",inherit:[1],code:"dll.fromArray([]);",evaluate:"dll.head;",expected:null},{id:3,name:"empty array creates empty list - check tail",inherit:[1,2],code:"",evaluate:"dll.tail;",expected:null},{id:4,name:"creates one-item list - check head",inherit:[1],code:"dll.fromArray([5]);",evaluate:"dll.head.value;",expected:5},{id:5,name:"creates one-item list - check tail",inherit:[1,4],code:"",evaluate:"dll.tail.value;",expected:5},{id:6,name:"creates three-item list - check head",inherit:[1],code:"dll.fromArray([6,7,8]);",evaluate:"dll.head.value;",expected:6},{id:7,name:"creates three-item list - check tail",inherit:[1,6],code:"",evaluate:"dll.tail.value;",expected:8},{id:8,name:"creates three-item list - check head next",inherit:[1,6],code:"",evaluate:"dll.head.next.value;",expected:7}],setupCode:"".concat(O),source:[],tags:["Doubly Linked List",x],solution:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED: append(value: any) DoublyLinkedList"},{stage:-1,text:""},{stage:1,text:"  fromArray(values) {"},{stage:3,text:"    values.forEach(value => this.append(value));"},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},de={problemID:17,problemName:"Implement **toArray** in a *DoublyLinkedList* class.",problemText:"Provide a class method **toArray** that converts *DoublyLinkedListNode* `value`'s in a *DoublyLinkedList* into array elements in matching order.",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"empty list makes empty array",inherit:[1],code:"",evaluate:"dll.toArray();",expected:JSON.stringify([])},{id:3,name:"one item list",inherit:[1],code:"dll.append(4);",evaluate:"dll.toArray();",expected:JSON.stringify([4])},{id:4,name:"three item list",inherit:[1],code:"dll.append(4).append(5).append(6);",evaluate:"dll.toArray();",expected:JSON.stringify([4,5,6])}],setupCode:"".concat(O),source:[],tags:["Doubly Linked List",x],solution:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  toArray() {"},{stage:2,text:"    const nodes = [];"},{stage:2,text:""},{stage:3,text:"    let currentNode = this.head;"},{stage:3,text:"    while (currentNode) {"},{stage:4,text:"      nodes.push(currentNode.value);"},{stage:4,text:"      currentNode = currentNode.next;"},{stage:3,text:"    }"},{stage:3,text:""},{stage:2,text:"    return nodes;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},ce={problemID:18,problemName:"Reverse a *DoublyLinkedList* in-place.",problemText:"Provide a class method **reverse** that will reverse a *DoublyLinkedList* in place (not using a copy), and return the list.",testCases:[{id:1,name:"compiles",inherit:[],code:"const dll=new DoublyLinkedList();",evaluate:"Boolean(dll);",expected:!0},{id:2,name:"reversing an empty list - still empty",inherit:[1],code:"",evaluate:"dll.reverse();",expected:'{"head":null,"tail":null}'},{id:3,name:"reversing a one item list - check head",inherit:[1],code:"dll.append(5);",evaluate:"dll.reverse().head.value;",expected:5},{id:4,name:"reversing a one item list - check head",inherit:[1,3],code:"",evaluate:"dll.reverse().tail.value;",expected:5},{id:5,name:"reversing a three item list - check head",inherit:[1],code:"dll.append(6).append(7).append(8);",evaluate:"dll.reverse().head.value;",expected:8},{id:6,name:"reversing a three item list - check head",inherit:[1,5],code:"",evaluate:"dll.reverse().tail.value;",expected:6},{id:7,name:"reversing a three item list - check head next",inherit:[1,5],code:"",evaluate:"dll.reverse().head.next.value;",expected:7}],setupCode:"".concat(O),source:[],tags:["Doubly Linked List",x],solution:[{stage:0,text:"class DoublyLinkedListNode {"},{stage:0,text:"  constructor(value, next = null, previous = null) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.next = next;"},{stage:0,text:"    this.previous = previous;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = null;"},{stage:0,text:"    this.tail = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  reverse() {"},{stage:2,text:"    let currNode = this.head;"},{stage:2,text:"    let prevNode = null;"},{stage:2,text:"    let nextNode = null;"},{stage:3,text:""},{stage:3,text:"    while (currNode) {"},{stage:4,text:"      nextNode = currNode.next;"},{stage:4,text:"      prevNode = currNode.previous;"},{stage:4,text:""},{stage:5,text:"      currNode.next = prevNode;"},{stage:5,text:"      currNode.previous = nextNode;"},{stage:5,text:""},{stage:6,text:"      prevNode = currNode;"},{stage:6,text:"      currNode = nextNode;"},{stage:3,text:"    }"},{stage:3,text:""},{stage:7,text:"    this.tail = this.head;"},{stage:7,text:"    this.head = prevNode;"},{stage:7,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},ue={problemID:19,problemName:"Implement a recursive fibonacci function.",problemText:"Implement a function **fibonacciNth** which takes an integer parameter `n` and returns the nth indexed fibonnaci number in the sequence.  For example, n=0 would return 0, n=1 would return 1, n=2 would return 1, and n=3 would return 2. ([0,1,1,2,3,5,8,13... etc]).  Please solve **recursively**.",testCases:[{id:1,name:"0 case",inherit:[],code:"",evaluate:"fibonacciNth(0);",expected:0},{id:2,name:"1 case",inherit:[],code:"",evaluate:"fibonacciNth(1);",expected:1},{id:3,name:"2 case",inherit:[],code:"",evaluate:"fibonacciNth(2);",expected:1},{id:4,name:"3 case",inherit:[],code:"",evaluate:"fibonacciNth(3);",expected:2},{id:5,name:"4 case",inherit:[],code:"",evaluate:"fibonacciNth(4);",expected:3},{id:6,name:"5 case",inherit:[],code:"",evaluate:"fibonacciNth(5);",expected:5},{id:7,name:"6 case",inherit:[],code:"",evaluate:"fibonacciNth(6);",expected:8},{id:8,name:"7 case",inherit:[],code:"",evaluate:"fibonacciNth(7);",expected:13},{id:9,name:"8 case",inherit:[],code:"",evaluate:"fibonacciNth(8);",expected:21}],setupCode:"",source:[],tags:["Fibonacci",d],solution:[{stage:1,text:"const fibonacciNth = n => {"},{stage:2,text:"  if (n === 0 || n === 1) return n;"},{stage:3,text:"  return fibonacciNth(n - 1) + fibonacciNth(n - 2);"},{stage:1,text:"};"},{stage:0,text:""}]},he={problemID:20,problemName:"Implement an iterative fibonacci function.",problemText:"Implement a function `fibonacciNth` which takes an integer parameter `n` and returns the nth indexed fibonnaci number in the sequence.  For example, n=0 would return 0, n=1 would return 1, n=2 would return 1, and n=3 would return 2. ([0,1,1,2,3,5,8,13... etc]).  Please solve **iteratively**.",testCases:[{id:1,name:"0 case",inherit:[],code:"",evaluate:"fibonacciNth(0);",expected:0},{id:2,name:"1 case",inherit:[],code:"",evaluate:"fibonacciNth(1);",expected:1},{id:3,name:"2 case",inherit:[],code:"",evaluate:"fibonacciNth(2);",expected:1},{id:4,name:"3 case",inherit:[],code:"",evaluate:"fibonacciNth(3);",expected:2},{id:5,name:"4 case",inherit:[],code:"",evaluate:"fibonacciNth(4);",expected:3},{id:6,name:"5 case",inherit:[],code:"",evaluate:"fibonacciNth(5);",expected:5},{id:7,name:"6 case",inherit:[],code:"",evaluate:"fibonacciNth(6);",expected:8},{id:8,name:"7 case",inherit:[],code:"",evaluate:"fibonacciNth(7);",expected:13},{id:9,name:"8 case",inherit:[],code:"",evaluate:"fibonacciNth(8);",expected:21}],setupCode:"",source:[],tags:["Fibonacci",d],solution:[{stage:1,text:"function fibonacciNth(n) {"},{stage:2,text:"  let currentValue = 1;"},{stage:2,text:"  let previousValue = 0;"},{stage:2,text:""},{stage:3,text:"  if (n <= 1) {"},{stage:3,text:"    return n;"},{stage:3,text:"  }"},{stage:3,text:""},{stage:4,text:"  let iteration = 2;"},{stage:4,text:""},{stage:5,text:"  while (iteration <= n) {"},{stage:6,text:"    currentValue += previousValue;"},{stage:6,text:"    previousValue = currentValue - previousValue;"},{stage:6,text:"    iteration++;"},{stage:5,text:"  }"},{stage:5,text:""},{stage:4,text:"  return currentValue;"},{stage:1,text:"}"},{stage:0,text:""}]},pe={problemID:21,problemName:"Implement a *Queue* using a *Linked List*",problemText:"\nGiven a *Queue* class, implement the following methods: \n    \n - **isEmpty** (which returns a Boolean value indicating if there are any items in the queue)\n - **peek** (which returns - but does not remove - the value at the head of the queue)\n - **enqueue** (which adds a value to the end of the queue - does not return anything)\n - **dequeue** (which removes and returns the value at the head of the queue).  \n    \nBase the implementation on the given *LinkedList* base data structure.  Return `null` for **peek** and **dequeue** if the queue is empty.",testCases:[{id:1,name:"compiles",inherit:[],code:"const queue=new Queue();",evaluate:"Boolean(queue);",expected:!0},{id:2,name:"peek on an empty queue returns null",inherit:[1],code:"",evaluate:"queue.peek();",expected:null},{id:3,name:"dequeue on an empty queue returns null",inherit:[1],code:"",evaluate:"queue.dequeue();",expected:null},{id:4,name:"peek returns enqueued item",inherit:[1],code:"queue.enqueue(5);",evaluate:"queue.peek();",expected:5},{id:5,name:"peek, queue, dequeue work together properly",inherit:[1],code:"queue.enqueue(5);queue.enqueue(7);queue.dequeue();",evaluate:"queue.peek();",expected:7},{id:6,name:"peek returns enqueued item (3)",inherit:[1],code:"queue.enqueue(5);queue.enqueue(6);queue.enqueue(7);",evaluate:"queue.peek();",expected:5},{id:7,name:"dequeue multiple enqueued items",inherit:[1],code:"queue.enqueue(5);queue.enqueue(6);queue.enqueue(7);queue.dequeue();queue.dequeue();",evaluate:"queue.peek();",expected:7},{id:8,name:"isEmpty returns true for empty queue",inherit:[1],code:"",evaluate:"queue.isEmpty();",expected:!0},{id:9,name:"isEmpty returns false for queue with an item",inherit:[1],code:"queue.enqueue(5);",evaluate:"queue.isEmpty();",expected:!1},{id:10,name:"dequeue returns value, not node",inherit:[1],code:"queue.enqueue(5);",evaluate:"queue.dequeue();",expected:5}],setupCode:"".concat(S),source:[],tags:["Queue",x],solution:[{stage:-1,text:"//  class LinkedListNode {"},{stage:-1,text:"//    constructor(value, next = null) {"},{stage:-1,text:"//      this.value = value;"},{stage:-1,text:"//      this.next = next;"},{stage:-1,text:"//    }"},{stage:-1,text:"//  }"},{stage:-1,text:"//"},{stage:-1,text:"//  class LinkedList {"},{stage:-1,text:"//    constructor() {"},{stage:-1,text:"//      this.head = null;"},{stage:-1,text:"//      this.tail = null;"},{stage:-1,text:"//    }"},{stage:-1,text:"//"},{stage:-1,text:"//    append(value: any) LinkedList"},{stage:-1,text:"//    deleteHead() LinkedListNode"},{stage:-1,text:"//"},{stage:-1,text:"//  }"},{stage:-1,text:"//"},{stage:-1,text:"// All code above is implicitly included in your environment"},{stage:0,text:""},{stage:0,text:""},{stage:0,text:"class Queue {"},{stage:1,text:"  constructor() {"},{stage:2,text:"    this.linkedList = new LinkedList();"},{stage:1,text:"  }"},{stage:0,text:""},{stage:3,text:"  isEmpty() {"},{stage:5,text:"    return !this.linkedList.head;"},{stage:3,text:"  }"},{stage:0,text:""},{stage:3,text:"  peek() {"},{stage:6,text:"    if (this.isEmpty()) {"},{stage:6,text:"      return null;"},{stage:6,text:"    }"},{stage:6,text:"    return this.linkedList.head.value;"},{stage:3,text:"  }"},{stage:0,text:""},{stage:4,text:"  enqueue(value) {"},{stage:5,text:"    this.linkedList.append(value);"},{stage:4,text:"  }"},{stage:0,text:""},{stage:4,text:"  dequeue() {"},{stage:7,text:"    if (this.isEmpty()) {"},{stage:7,text:"      return null;"},{stage:7,text:"    }"},{stage:7,text:"    return this.linkedList.deleteHead().value;"},{stage:4,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},me={problemID:22,problemName:"Implement a *Queue* from scratch using an *Array*",problemText:"\nGiven a *Queue* class, implement the following methods: \n    \n - **isEmpty** which returns a Boolean value indicating if there are any items in the queue.\n - **peek** which returns - but does not remove - the `value` at the head of the queue.\n - **enqueue** which adds a `value` to the end of the queue - does not return anything.\n - **dequeue** which removes and returns the `value` at the head of the queue.  \n    \nBase the implementation on an *Array* base data structure.  Return `null` for **peek** and **dequeue** if the queue is empty.",testCases:[{id:1,name:"compiles",inherit:[],code:"const queue=new Queue();",evaluate:"Boolean(queue);",expected:!0},{id:2,name:"peek on an empty queue returns null",inherit:[1],code:"",evaluate:"queue.peek();",expected:null},{id:3,name:"dequeue on an empty queue returns null",inherit:[1],code:"",evaluate:"queue.dequeue();",expected:null},{id:4,name:"peek returns enqueued item",inherit:[1],code:"queue.enqueue(5);",evaluate:"queue.peek();",expected:5},{id:5,name:"peek, queue, dequeue work together properly",inherit:[1],code:"queue.enqueue(5);queue.enqueue(7);queue.dequeue();",evaluate:"queue.peek();",expected:7},{id:6,name:"peek returns enqueued item (3)",inherit:[1],code:"queue.enqueue(5);queue.enqueue(6);queue.enqueue(7);",evaluate:"queue.peek();",expected:5},{id:7,name:"dequeue multiple enqueued items",inherit:[1],code:"queue.enqueue(5);queue.enqueue(6);queue.enqueue(7);queue.dequeue();queue.dequeue();",evaluate:"queue.peek();",expected:7},{id:8,name:"isEmpty returns true for empty queue",inherit:[1],code:"",evaluate:"queue.isEmpty();",expected:!0},{id:9,name:"isEmpty returns false for queue with an item",inherit:[1],code:"queue.enqueue(5);",evaluate:"queue.isEmpty();",expected:!1}],setupCode:"",source:[],tags:["Queue",x],solution:[{stage:0,text:"class Queue {"},{stage:1,text:"  constructor() {"},{stage:2,text:"    this.items = [];"},{stage:1,text:"  }"},{stage:0,text:""},{stage:3,text:"  isEmpty() {"},{stage:5,text:"    return !this.items.length;"},{stage:3,text:"  }"},{stage:0,text:""},{stage:3,text:"  peek() {"},{stage:5,text:"    if (this.isEmpty()) {"},{stage:5,text:"      return null;"},{stage:5,text:"    }"},{stage:6,text:"    return this.items[0];"},{stage:3,text:"  }"},{stage:0,text:""},{stage:4,text:"  enqueue(value) {"},{stage:6,text:"    this.items.push(value);"},{stage:4,text:"  }"},{stage:0,text:""},{stage:4,text:"  dequeue() {"},{stage:7,text:"    if (this.isEmpty()) {"},{stage:7,text:"      return null;"},{stage:7,text:"    }"},{stage:7,text:"    return this.items.shift();"},{stage:4,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},fe={problemID:23,problemName:"Implement a *Stack* using a *Linked List*",problemText:"Given a *Stack* class, implement the following methods: \n\n   - **isEmpty**: returns a boolean value indicating if there are any values in the stack.\n   - **peek**: returns - but does not remove - the value at the top of the stack.\n   - **push**: adds a value to the top of the stack - does not return anything.\n   - **pop**: removes and returns the value at the top of the stack.\n   \nBase the implementation on the given *LinkedList* base data structure.  Return `null` for **peek** and **pop** if the stack is empty.",testCases:[{id:1,name:"compiles",inherit:[],code:"const stack=new Stack();",evaluate:"Boolean(stack);",expected:!0},{id:2,name:"peek on empty stack is null",inherit:[1],code:"",evaluate:"stack.peek();",expected:null},{id:3,name:"pop on empty stack is null",inherit:[1],code:"",evaluate:"stack.pop();",expected:null},{id:4,name:"isEmpty on empty stack is true",inherit:[1],code:"",evaluate:"stack.isEmpty();",expected:!0},{id:5,name:"isEmpty on stack with an item is false",inherit:[1],code:"stack.push(5);",evaluate:"stack.isEmpty();",expected:!1},{id:6,name:"peek on stack with an item returns that value",inherit:[1,5],code:"",evaluate:"stack.peek();",expected:5},{id:7,name:"peek on stack with two items returns correct value",inherit:[1,5],code:"stack.push(9);",evaluate:"stack.peek();",expected:9},{id:8,name:"peek does not remove items",inherit:[1,5,7],code:"",evaluate:"stack.peek();stack.peek();",expected:9},{id:9,name:"pop removes and returns correct item in stack (1)",inherit:[1,5,7],code:"",evaluate:"stack.pop();",expected:9},{id:10,name:"pop removes and returns correct item in stack (2)",inherit:[1,5,7],code:"",evaluate:"stack.pop();stack.pop();",expected:5}],setupCode:"".concat(S),source:[],tags:["Stack",x],solution:[{stage:-1,text:"//  class LinkedList {"},{stage:-1,text:"//    prepend(value: any) LinkedList"},{stage:-1,text:"//    deleteHead() LinkedListNode"},{stage:-1,text:"//  }"},{stage:-1,text:"//  class LinkedListNode {"},{stage:-1,text:"//    constructor(value, next = null) {"},{stage:-1,text:"//      this.value = value;"},{stage:-1,text:"//      this.next = next;"},{stage:-1,text:"//    }"},{stage:-1,text:"//  }"},{stage:-1,text:"//"},{stage:-1,text:"// All code above is implicitly included in your environment"},{stage:0,text:""},{stage:0,text:"class Stack {"},{stage:2,text:"  constructor() {"},{stage:2,text:"    this.linkedList = new LinkedList();"},{stage:2,text:"  }"},{stage:0,text:""},{stage:3,text:"  isEmpty() {"},{stage:5,text:"    return !this.linkedList.head;"},{stage:3,text:"  }"},{stage:0,text:""},{stage:3,text:"  peek() {"},{stage:5,text:"    if (this.isEmpty()) {"},{stage:5,text:"      return null;"},{stage:5,text:"    }"},{stage:6,text:"    return this.linkedList.head.value;"},{stage:3,text:"  }"},{stage:0,text:""},{stage:4,text:"  push(value) {"},{stage:6,text:"    this.linkedList.prepend(value);"},{stage:4,text:"  }"},{stage:0,text:""},{stage:4,text:"  pop() {"},{stage:7,text:"    const removedHead = this.linkedList.deleteHead();"},{stage:7,text:"    return removedHead ? removedHead.value : null;"},{stage:4,text:"  }"},{stage:1,text:""},{stage:0,text:"}"},{stage:0,text:""}]},ve={problemID:24,problemName:"Implement a *Stack* using an *Array*",problemText:"Given a *Stack* class, implement the following methods: **isEmpty** (which returns a boolean indicating if there are any values in the stack), **peek** (which returns - but does not remove - the value at the top of the stack), **push** (which adds a value to the top of the stack - does not return anything), and **pop** (which removes and returns the value at the top of the stack).  Base the implementation on an *Array* data structure.  Return `null` for **peek** and **pop** if the stack is empty.",testCases:[{id:1,name:"compiles",inherit:[],code:"const stack=new Stack();",evaluate:"Boolean(stack);",expected:!0},{id:2,name:"peek on empty stack is null",inherit:[1],code:"",evaluate:"stack.peek();",expected:null},{id:3,name:"pop on empty stack is null",inherit:[1],code:"",evaluate:"stack.pop();",expected:null},{id:4,name:"isEmpty on empty stack is true",inherit:[1],code:"",evaluate:"stack.isEmpty();",expected:!0},{id:5,name:"isEmpty on stack with an item is false",inherit:[1],code:"stack.push(5);",evaluate:"stack.isEmpty();",expected:!1},{id:6,name:"peek on stack with an item returns that value",inherit:[1,5],code:"",evaluate:"stack.peek();",expected:5},{id:7,name:"peek on stack with two items returns correct value",inherit:[1,5],code:"stack.push(9);",evaluate:"stack.peek();",expected:9},{id:8,name:"peek does not remove items",inherit:[1,5,7],code:"",evaluate:"stack.peek();stack.peek();",expected:9},{id:9,name:"pop removes and returns correct item in stack (1)",inherit:[1,5,7],code:"",evaluate:"stack.pop();",expected:9},{id:10,name:"pop removes and returns correct item in stack (2)",inherit:[1,5,7],code:"",evaluate:"stack.pop();stack.pop();",expected:5}],setupCode:"",source:[],tags:["Stack",x],solution:[{stage:0,text:"class Stack {"},{stage:1,text:"  constructor() {"},{stage:1,text:"    this.items = [];"},{stage:1,text:"  }"},{stage:0,text:""},{stage:2,text:"  isEmpty() {"},{stage:4,text:"    return !this.items.length;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:2,text:"  peek() {"},{stage:4,text:"    if (this.isEmpty()) {"},{stage:4,text:"      return null;"},{stage:4,text:"    }"},{stage:5,text:"    return this.items[this.items.length - 1];"},{stage:2,text:"  }"},{stage:0,text:""},{stage:3,text:"  push(value) {"},{stage:5,text:"    this.items.push(value);"},{stage:3,text:"  }"},{stage:0,text:""},{stage:3,text:"  pop() {"},{stage:6,text:"    if (this.isEmpty()) {"},{stage:6,text:"      return null;"},{stage:6,text:"    }"},{stage:6,text:"    return this.items.pop();"},{stage:3,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},we={problemID:25,problemName:"Implement **set** in a *HashTable* class.",problemText:"Given a *HashTable* class and a *LinkedList* class, implement a **set(key, value)** method in the *HashTable* class that will add or modify a `value` in the hash table for a given `key`.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ht=new HashTable();",evaluate:"Boolean(ht);",expected:!0},{id:2,name:"adds a new value",inherit:[1],code:"ht.set('key1', 5);",evaluate:"ht.get('key1');",expected:5},{id:3,name:"updates an existing value",inherit:[1,2],code:"ht.set('key1', 7);",evaluate:"ht.get('key1');",expected:7}],setupCode:"".concat(L," ").concat(q," ").concat(D),source:[],tags:["Hash Table",x],solution:[{stage:-1,text:"// class LinkedList {"},{stage:-1,text:"//   append(key: string, value: any) LinkedList"},{stage:-1,text:"//   findKey(key: string) LinkedListNode"},{stage:-1,text:"// }"},{stage:-1,text:"//"},{stage:-1,text:"//  class LinkedListNode {"},{stage:-1,text:"//    constructor(key, value, next = null) {"},{stage:-1,text:"//      this.key = key;"},{stage:-1,text:"//      this.value = value;"},{stage:-1,text:"//      this.next = next;"},{stage:-1,text:"//    }"},{stage:-1,text:"//  }"},{stage:-1,text:"//"},{stage:-1,text:"// All code above is implicitly included in your environment"},{stage:0,text:""},{stage:0,text:"class HashTable {"},{stage:0,text:"  constructor(hashTableSize = 32) {"},{stage:0,text:"    this.buckets = Array(hashTableSize)"},{stage:0,text:"      .fill(null)"},{stage:0,text:"      .map(() => new LinkedList());"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED:  hash(key: string) int"},{stage:-1,text:""},{stage:1,text:"  set(key, value) {"},{stage:2,text:"    const keyHash = this.hash(key);"},{stage:2,text:"    const bucketLinkedList = this.buckets[keyHash];"},{stage:3,text:"    const node = bucketLinkedList.findKey(key);"},{stage:3,text:""},{stage:4,text:"    if (!node) {"},{stage:5,text:"      bucketLinkedList.append(key, value);"},{stage:4,text:"    } else {"},{stage:5,text:"      node.value = value;"},{stage:4,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},be={problemID:26,problemName:"Implement **get** in a *HashTable* class.",problemText:"Given a *HashTable* class and an associated *LinkedList* class, implement a **get** method in the *HashTable* class that will retrieve a `value` from the hash table for a given `key`, or `undefined` if the `key` does not exist.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ht=new HashTable();",evaluate:"Boolean(ht);",expected:!0},{id:2,name:"get a key that doesnt exist",inherit:[1],code:"",evaluate:"ht.get('key1');",expected:void 0},{id:3,name:"get a key",inherit:[1],code:"ht.set('key1', 99);",evaluate:"ht.get('key1');",expected:99}],setupCode:"".concat(L," ").concat(q," ").concat(M),source:[],tags:["Hash Table",x],solution:[{stage:-1,text:"// class LinkedList {"},{stage:-1,text:"//   findKey(key: string) LinkedListNode"},{stage:-1,text:"// }"},{stage:-1,text:"//"},{stage:-1,text:"// class LinkedListNode {"},{stage:-1,text:"//   constructor(key, value, next = null) {"},{stage:-1,text:"//     this.key = key;"},{stage:-1,text:"//     this.value = value;"},{stage:-1,text:"//     this.next = next;"},{stage:-1,text:"//   }"},{stage:-1,text:"// }"},{stage:-1,text:"//"},{stage:-1,text:"// All code above is implicitly included in your environment"},{stage:0,text:""},{stage:0,text:"class HashTable {"},{stage:0,text:"  constructor(hashTableSize = 32) {"},{stage:0,text:"    this.buckets = Array(hashTableSize)"},{stage:0,text:"      .fill(null)"},{stage:0,text:"      .map(() => new LinkedList());"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED:  hash(key: string) int"},{stage:-1,text:""},{stage:1,text:"  get(key) {"},{stage:2,text:"    const bucketLinkedList = this.buckets[this.hash(key)];"},{stage:3,text:"    const node = bucketLinkedList.findKey(key);"},{stage:3,text:"    return node ? node.value : undefined;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},ye={problemID:27,problemName:"Implement **delete** in a *HashTable* class.",problemText:"Given a *HashTable* class and an associated *LinkedList* class, implement a **delete** method in the *HashTable* class that will delete the entry for a given `key`.\n  \n  The method must return the value of the deleted item, or `null` if an item matching the `key` was not found.",testCases:[{id:1,name:"compiles",inherit:[],code:"const ht=new HashTable();",evaluate:"Boolean(ht);",expected:!0},{id:2,name:"deleting a key that does not exist returns null",inherit:[1],code:"",evaluate:"ht.delete('key1');",expected:null},{id:3,name:"deleting a key that does exist",inherit:[1],code:"ht.set('key1', 77);",evaluate:"ht.delete('key1');",expected:77}],setupCode:"".concat(L," ").concat(q," ").concat(M," ").concat(D),source:[],tags:["Hash Table",x],solution:[{stage:-1,text:"// class LinkedList {"},{stage:-1,text:"//   deleteKey(key: string) LinkedListNode"},{stage:-1,text:"// }"},{stage:-1,text:"//  class LinkedListNode {"},{stage:-1,text:"//    constructor(key, value, next = null) {"},{stage:-1,text:"//      this.key = key;"},{stage:-1,text:"//      this.value = value;"},{stage:-1,text:"//      this.next = next;"},{stage:-1,text:"//    }"},{stage:-1,text:"//  }"},{stage:-1,text:"//"},{stage:-1,text:"// All code above is implicitly included in your environment"},{stage:0,text:""},{stage:0,text:"class HashTable {"},{stage:0,text:"  constructor(hashTableSize = 32) {"},{stage:0,text:"    this.buckets = Array(hashTableSize)"},{stage:0,text:"      .fill(null)"},{stage:0,text:"      .map(() => new LinkedList());"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED:  hash(key: string) int"},{stage:-1,text:""},{stage:1,text:"  delete(key) {"},{stage:2,text:"    const keyHash = this.hash(key);"},{stage:2,text:"    const bucketLinkedList = this.buckets[keyHash];"},{stage:3,text:"    const deletedNode = bucketLinkedList.deleteKey(key);"},{stage:4,text:"    if (deletedNode) {"},{stage:4,text:"      return deletedNode.value;"},{stage:4,text:"    }"},{stage:3,text:"    return null;"},{stage:1,text:"  }"},{stage:0,text:"}"},{stage:0,text:""}]},ke={problemID:28,problemName:"Implement child index functions for a *MinHeap* class.",problemText:"Implement the following methods for the *MinHeap* data structure:  \n   - **getLeftChildIndex** (parentIndex: integer) => integer  \n   - **getRightChildIndex** (parentIndex: integer) => integer  \n   - **hasLeftChild** (parentIndex: integer) => boolean  \n   - **hasRightChild** (parentIndex: integer) => boolean  \n   - **leftChild** (parentIndex: integer) => heap value  \n   - **rightChild** (parentIndex: integer) => heap value\n",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"getLeftChildIndex - test 0",inherit:[1],code:"",evaluate:"minheap.getLeftChildIndex(0);",expected:1},{id:2,name:"getLeftChildIndex - test 1",inherit:[1],code:"",evaluate:"minheap.getLeftChildIndex(5);",expected:11},{id:3,name:"getRightChildIndex - test 0",inherit:[1],code:"",evaluate:"minheap.getRightChildIndex(0);",expected:2},{id:4,name:"getRightChildIndex - test 1",inherit:[1],code:"",evaluate:"minheap.getRightChildIndex(12);",expected:26},{id:5,name:"hasLeftChild - true",inherit:[1],code:"minheap.heapContainer.length = 10;",evaluate:"minheap.hasLeftChild(4);",expected:!0},{id:6,name:"hasLeftChild - false",inherit:[1],code:"minheap.heapContainer.length = 9;",evaluate:"minheap.hasLeftChild(4);",expected:!1},{id:7,name:"hasRightChild - true",inherit:[1],code:"minheap.heapContainer.length = 11;",evaluate:"minheap.hasRightChild(4);",expected:!0},{id:8,name:"hasRightChild - false",inherit:[1],code:"minheap.heapContainer.length = 10;",evaluate:"minheap.hasRightChild(4);",expected:!1},{id:9,name:"leftChild",inherit:[1],code:"minheap.heapContainer = [1,4,5,8,10,12,16];",evaluate:"minheap.leftChild(0);",expected:4},{id:10,name:"leftChild",inherit:[1,9],code:"",evaluate:"minheap.leftChild(2);",expected:12},{id:11,name:"rightChild",inherit:[1,9],code:"",evaluate:"minheap.rightChild(0);",expected:5},{id:12,name:"rightChild",inherit:[1,9],code:"",evaluate:"minheap.rightChild(2);",expected:16}],setupCode:"",source:[],tags:[u,x],solution:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  getLeftChildIndex(parentIndex) {"},{stage:2,text:"    return 2 * parentIndex + 1;"},{stage:1,text:"  }"},{stage:2,text:""},{stage:1,text:"  getRightChildIndex(parentIndex) {"},{stage:3,text:"    return 2 * parentIndex + 2;"},{stage:1,text:"  }"},{stage:3,text:""},{stage:1,text:"  hasLeftChild(parentIndex) {"},{stage:4,text:"    return this.getLeftChildIndex(parentIndex) < this.heapContainer.length;"},{stage:1,text:"  }"},{stage:4,text:""},{stage:1,text:"  hasRightChild(parentIndex) {"},{stage:5,text:"    return this.getRightChildIndex(parentIndex) < this.heapContainer.length;"},{stage:1,text:"  }"},{stage:5,text:""},{stage:1,text:"  leftChild(parentIndex) {"},{stage:6,text:"    return this.heapContainer[this.getLeftChildIndex(parentIndex)];"},{stage:1,text:"  }"},{stage:6,text:""},{stage:1,text:"  rightChild(parentIndex) {"},{stage:7,text:"    return this.heapContainer[this.getRightChildIndex(parentIndex)];"},{stage:1,text:"  }"},{stage:0,text:"}"},{stage:0,text:""}]},Ne={problemID:29,problemName:"Implement parent index functions for a *MinHeap* class.",problemText:"Implement the following methods for the *MinHeap* data structure:  \n   - **getParentIndex** (childIndex: integer) => integer  \n   - **hasParent** (childIndex: integer) => boolean  \n   - **parent** (childIndex: integer) => heap value  \n",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"getParentIndex - 1",inherit:[1],code:"",evaluate:"minheap.getParentIndex(1);",expected:0},{id:3,name:"getParentIndex - 2",inherit:[1],code:"",evaluate:"minheap.getParentIndex(2);",expected:0},{id:4,name:"getParentIndex - 3",inherit:[1],code:"",evaluate:"minheap.getParentIndex(5);",expected:2},{id:5,name:"getParentIndex - 4",inherit:[1],code:"",evaluate:"minheap.getParentIndex(6);",expected:2},{id:6,name:"getParentIndex - 5",inherit:[1],code:"",evaluate:"minheap.getParentIndex(7);",expected:3},{id:7,name:"hasParent - 1",inherit:[1],code:"",evaluate:"minheap.hasParent(0);",expected:!1},{id:8,name:"hasParent - 2",inherit:[1],code:"",evaluate:"minheap.hasParent(1);",expected:!0},{id:9,name:"parent - 1",inherit:[1],code:"minheap.heapContainer = [1,4,5,8,10,12,16];",evaluate:"minheap.parent(1);",expected:1},{id:10,name:"parent - 2",inherit:[1,9],code:"",evaluate:"minheap.parent(2);",expected:1},{id:11,name:"parent - 3",inherit:[1,9],code:"",evaluate:"minheap.parent(3);",expected:4},{id:12,name:"parent - 4",inherit:[1,9],code:"",evaluate:"minheap.parent(4);",expected:4},{id:13,name:"parent - 5",inherit:[1,9],code:"",evaluate:"minheap.parent(5);",expected:5},{id:14,name:"parent - 6",inherit:[1,9],code:"",evaluate:"minheap.parent(6);",expected:5}],setupCode:"",source:[],tags:[u,x],solution:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  getParentIndex(childIndex) {"},{stage:2,text:"    return Math.floor((childIndex - 1) / 2);"},{stage:1,text:"  }"},{stage:2,text:""},{stage:1,text:"  hasParent(childIndex) {"},{stage:3,text:"    return this.getParentIndex(childIndex) >= 0;"},{stage:1,text:"  }"},{stage:3,text:""},{stage:1,text:"  parent(childIndex) {"},{stage:4,text:"    return this.heapContainer[this.getParentIndex(childIndex)];"},{stage:1,text:"  }"},{stage:4,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Ie={problemID:30,problemName:"Implement the **peek** method for a *MinHeap* class.",problemText:"Implement a **peek** method that will return the value of the first (next-up) item in a *MinHeap*.  Return `null` instead if there are no items in the heap.",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"null if no values in heap",inherit:[1],code:"minheap.heapContainer = [];",evaluate:"minheap.peek();",expected:null},{id:3,name:"first value - 1",inherit:[1],code:"minheap.heapContainer = [5];",evaluate:"minheap.peek();",expected:5},{id:4,name:"first value - 2",inherit:[1],code:"minheap.heapContainer = [3,7];",evaluate:"minheap.peek();",expected:3}],setupCode:"",source:[],tags:[u,x],solution:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  peek() {"},{stage:2,text:"    if (this.heapContainer.length === 0) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:3,text:"    return this.heapContainer[0];"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Ce={problemID:31,problemName:"Implement the **find** method for a *MinHeap* class.",problemText:"Implement a **find** method for a *MinHeap* that accepts a parameter `item` and returns an array of indices where matching items are found in the *MinHeap*.",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"empty heap",inherit:[1],code:"",evaluate:"minheap.find(5);",expected:JSON.stringify([])},{id:3,name:"one item heap, no match",inherit:[1],code:"minheap.heapContainer = [4];",evaluate:"minheap.find(5);",expected:JSON.stringify([])},{id:4,name:"one item heap, match",inherit:[1],code:"minheap.heapContainer = [4];",evaluate:"minheap.find(4);",expected:JSON.stringify([0])},{id:5,name:"multi-item heap, no match",inherit:[1],code:"minheap.heapContainer = [4,6,8,10,12];",evaluate:"minheap.find(7);",expected:JSON.stringify([])},{id:6,name:"multi-item heap, one match",inherit:[1],code:"minheap.heapContainer = [4,6,8,10,12];",evaluate:"minheap.find(8);",expected:JSON.stringify([2])},{id:7,name:"multi-item heap, multiple matches",inherit:[1],code:"minheap.heapContainer = [4,6,8,8,8,10,12];",evaluate:"minheap.find(8);",expected:JSON.stringify([2,3,4])}],setupCode:"",source:[],tags:[u,x],solution:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  find(item) {"},{stage:2,text:"    const foundItemIndices = [];"},{stage:3,text:"    for (let itemIndex = 0; itemIndex < this.heapContainer.length; itemIndex += 1) {"},{stage:4,text:"      if (item === this.heapContainer[itemIndex]) {"},{stage:4,text:"        foundItemIndices.push(itemIndex);"},{stage:4,text:"      }"},{stage:3,text:"    }"},{stage:2,text:"    return foundItemIndices;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},_e={problemID:32,problemName:"Implement **poll** for a *MinHeap* class.",problemText:"Implement a **poll** method for a *MinHeap* to remove and return the item at the top of the heap.  If the heap is empty, return `null`.",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"empty list",inherit:[1],code:"",evaluate:"minheap.poll();",expected:null},{id:3,name:"list, return top item",inherit:[1],code:"minheap.heapContainer = [1,2,4,6,3,5,6,10,8,7];",evaluate:"minheap.poll();",expected:1},{id:4,name:"list, correct 2nd item",inherit:[1,3],code:"minheap.poll();",evaluate:"minheap.poll();",expected:2},{id:5,name:"list, correct 3rd item",inherit:[1,3,4],code:"minheap.poll();",evaluate:"minheap.poll();",expected:3},{id:6,name:"list, correct 4th item",inherit:[1,3,4,5],code:"minheap.poll();",evaluate:"minheap.poll();",expected:4},{id:7,name:"list, correct 5th item",inherit:[1,3,4,5,6],code:"minheap.poll();",evaluate:"minheap.poll();",expected:5}],setupCode:"".concat(j," ").concat(R," ").concat(P),source:[],tags:[u,x],solution:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED:  heapifyDown(startIndex: int = 0)"},{stage:0,text:""},{stage:1,text:"  poll() {"},{stage:2,text:"    if (this.heapContainer.length === 0) {"},{stage:2,text:"      return null;"},{stage:2,text:"    }"},{stage:3,text:""},{stage:3,text:"    if (this.heapContainer.length === 1) {"},{stage:3,text:"      return this.heapContainer.pop();"},{stage:3,text:"    }"},{stage:4,text:""},{stage:4,text:"    const item = this.heapContainer[0];"},{stage:4,text:""},{stage:5,text:"    this.heapContainer[0] = this.heapContainer.pop();"},{stage:5,text:"    this.heapifyDown();"},{stage:4,text:"    return item;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Se={problemID:33,problemName:"Implement **add** for a *MinHeap* class.",problemText:"Implement an **add** method for a *MinHeap* to receive an `item` (integer) and add it to the heap.  The method should then return the heap.",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"add item to empty heap",inherit:[1],code:"minheap.add(5);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([5])},{id:3,name:"add 2nd item to heap",inherit:[1,2],code:"minheap.add(6);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([5,6])},{id:4,name:"add 3rd item to heap",inherit:[1,2,3],code:"minheap.add(3);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([3,6,5])},{id:5,name:"add 4th item to heap",inherit:[1,2,3,4],code:"minheap.add(8);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([3,6,5,8])},{id:6,name:"add 5th item to heap",inherit:[1,2,3,4,5],code:"minheap.add(1);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,3,5,8,6])},{id:7,name:"add 6th item to heap",inherit:[1,2,3,4,5,6],code:"minheap.add(4);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,3,4,8,6,5])},{id:8,name:"add 7th item to heap",inherit:[1,2,3,4,5,6,7],code:"minheap.add(2);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,3,2,8,6,5,4])},{id:9,name:"method should return itself",inherit:[1,2,3,4,5,6,7],code:"",evaluate:"minheap.add(2) === minheap",expected:!0}],setupCode:"".concat(B," ").concat(H," ").concat(P),source:[],tags:[u,x],solution:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED:  heapifyUp()"},{stage:0,text:""},{stage:1,text:"  add(item) {"},{stage:2,text:"    this.heapContainer.push(item);"},{stage:3,text:"    this.heapifyUp();"},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Le={problemID:34,problemName:"Implement **remove** for a *MinHeap* class.",problemText:"Implement a **remove** method for a *MinHeap* to receive an `item` (integer) and remove all instances of that item from the heap.  The method should then return the heap.\n  \n  (note: remove duplicate items from back to front)",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"remove from empty heap, remains empty heap",inherit:[1],code:"",evaluate:"minheap.remove(5);JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([])},{id:3,name:"remove from empty heap, returns empty heap",inherit:[1],code:"",evaluate:"minheap.remove(5) === minheap;",expected:!0},{id:4,name:"remove one from one item heap, heap becomes empty",inherit:[1],code:"minheap.heapContainer = [5];minheap.remove(5);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([])},{id:5,name:"remove one from two item heap, one item remains",inherit:[1],code:"minheap.heapContainer = [5,6];minheap.remove(5);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([6])},{id:6,name:"remove value from two item heap where value is duplicated",inherit:[1],code:"minheap.heapContainer = [5,5];minheap.remove(5);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([])},{id:7,name:"complex example",inherit:[1],code:"minheap.heapContainer = [1,2,4,6,3,5,6,10,8,7];minheap.remove(5).remove(6);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,2,4,10,3,7,8])}],setupCode:"".concat(B," ").concat(j," ").concat("\nMinHeap.prototype.find = function (item) {\n  const foundItemIndices = [];\n  for (let itemIndex = 0; itemIndex < this.heapContainer.length; itemIndex += 1) {\n    if (item === this.heapContainer[itemIndex]) {\n      foundItemIndices.push(itemIndex);\n    }\n  }\n  return foundItemIndices;\n};\n"," ").concat(H," ").concat(R," ").concat(P,"\n\n\n  "),source:[],tags:[u,x],solution:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED:  heapifyUp(index: int)"},{stage:-1,text:"// IMPLEMENTED:  heapifyDown(index: int)"},{stage:-1,text:"// IMPLEMENTED:  find(item: int) []index:int"},{stage:-1,text:"// IMPLEMENTED:  parent(index: int) item:int"},{stage:-1,text:"// IMPLEMENTED:  hasLeftChild(index: int) bool"},{stage:0,text:""},{stage:1,text:"  remove(item) {"},{stage:2,text:"    const numberOfItemsToRemove = this.find(item).length;"},{stage:2,text:""},{stage:3,text:"    for (let iteration = 0; iteration < numberOfItemsToRemove; iteration += 1) {"},{stage:4,text:"      const indexToRemove = this.find(item).pop();"},{stage:4,text:"      if (indexToRemove === this.heapContainer.length - 1) {"},{stage:5,text:"        this.heapContainer.pop();"},{stage:4,text:"      } else {"},{stage:5,text:"        this.heapContainer[indexToRemove] = this.heapContainer.pop();"},{stage:5,text:"        const parentItem = this.parent(indexToRemove);"},{stage:6,text:""},{stage:6,text:"        if ("},{stage:6,text:"          this.hasLeftChild(indexToRemove) &&"},{stage:6,text:"          (!parentItem || parentItem <= this.heapContainer[indexToRemove])"},{stage:6,text:"        ) {"},{stage:7,text:"          this.heapifyDown(indexToRemove);"},{stage:6,text:"        } else {"},{stage:8,text:"          this.heapifyUp(indexToRemove);"},{stage:6,text:"        }"},{stage:4,text:"      }"},{stage:3,text:"    }"},{stage:2,text:"    return this;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Te={problemID:35,problemName:"Implement **heapifyUp** for a *MinHeap* class.",problemText:"Implement a **heapifyUp** method for a *MinHeap* to take an array item at a specified `index` (the last index in the array by default) and move it up to the correct placement in the heap.",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"heapifyUp on one item heap, remains same",inherit:[1],code:"minheap.heapContainer = [5];minheap.heapifyUp();",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([5])},{id:3,name:"heapifyUp on two item heap",inherit:[1],code:"minheap.heapContainer = [5,4];minheap.heapifyUp(1);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([4,5])},{id:4,name:"heapifyUp on three item heap",inherit:[1],code:"minheap.heapContainer = [5,6,4];minheap.heapifyUp(2);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([4,6,5])},{id:5,name:"heapifyUp on four item heap",inherit:[1],code:"minheap.heapContainer = [4,6,5,3];minheap.heapifyUp(3);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([3,4,5,6])},{id:6,name:"heapifyUp on complex heap",inherit:[1],code:"minheap.heapContainer = [2,3,5,7,4,6,7,11,9,8,1];minheap.heapifyUp(10);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,2,5,7,3,6,7,11,9,8,4])},{id:7,name:"by default, works on last item in heap",inherit:[1],code:"minheap.heapContainer = [2,3,5,7,4,6,7,11,9,8,1];minheap.heapifyUp();",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,2,5,7,3,6,7,11,9,8,4])}],setupCode:"".concat(B," ").concat(P),source:[],tags:[u,x],solution:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED:  swap(index1: int, index2: int)"},{stage:-1,text:"// IMPLEMENTED:  getParentIndex(index: int) int"},{stage:-1,text:"// IMPLEMENTED:  hasParent(index: int) bool"},{stage:-1,text:"// IMPLEMENTED:  parent(index: int) int"},{stage:0,text:""},{stage:1,text:"  heapifyUp(customStartIndex) {"},{stage:2,text:"    let currentIndex = customStartIndex || this.heapContainer.length - 1;"},{stage:2,text:""},{stage:3,text:"    while ("},{stage:3,text:"      this.hasParent(currentIndex) &&"},{stage:3,text:"      (this.parent(currentIndex) > this.heapContainer[currentIndex])"},{stage:3,text:"    ) {"},{stage:4,text:"      this.swap(currentIndex, this.getParentIndex(currentIndex));"},{stage:5,text:"      currentIndex = this.getParentIndex(currentIndex);"},{stage:3,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Ee={problemID:36,problemName:"Implement **heapifyDown** for a *MinHeap* class.",problemText:"Implement a **heapifyDown** method for a *MinHeap* to take an array item at a specified `index` (the first item in the array by default) and move it down to the correct placement in the heap.",testCases:[{id:1,name:"compiles",inherit:[],code:"const minheap=new MinHeap();",evaluate:"Boolean(minheap);",expected:!0},{id:2,name:"one item in heap, heap is same",inherit:[1],code:"minheap.heapContainer = [1];  minheap.heapifyDown();",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1])},{id:3,name:"two items in heap, no change",inherit:[1],code:"minheap.heapContainer = [1,2];  minheap.heapifyDown();",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,2])},{id:4,name:"two items in heap, reorder",inherit:[1],code:"minheap.heapContainer = [2,1];  minheap.heapifyDown();",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,2])},{id:5,name:"five items in heap, reorder",inherit:[1],code:"minheap.heapContainer = [5,1,2,3,4];  minheap.heapifyDown();",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,3,2,5,4])},{id:6,name:"five items in heap, specific index",inherit:[1],code:"minheap.heapContainer = [1,5,2,3,4];  minheap.heapifyDown(1);",evaluate:"JSON.stringify(minheap.heapContainer);",expected:JSON.stringify([1,3,2,5,4])}],setupCode:"".concat(j," ").concat(P),source:[],tags:[u,x],solution:[{stage:0,text:"class MinHeap {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.heapContainer = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED:  swap(index1: int, index2: int)"},{stage:-1,text:"// IMPLEMENTED:  getLeftChildIndex(index: int) int"},{stage:-1,text:"// IMPLEMENTED:  getRightChildIndex(index: int) int"},{stage:-1,text:"// IMPLEMENTED:  hasLeftChild(index: int) bool"},{stage:-1,text:"// IMPLEMENTED:  hasRightChild(index: int) bool"},{stage:-1,text:"// IMPLEMENTED:  getLeftChildIndex(index: int) int"},{stage:-1,text:"// IMPLEMENTED:  getrightChildIndex(index: int) int"},{stage:0,text:""},{stage:1,text:"  heapifyDown(customStartIndex = 0) {"},{stage:2,text:"    let currentIndex = customStartIndex;"},{stage:2,text:"    let nextIndex = null;"},{stage:2,text:""},{stage:3,text:"    while (this.hasLeftChild(currentIndex)) {"},{stage:4,text:"      if ("},{stage:4,text:"        this.hasRightChild(currentIndex) &&"},{stage:4,text:"        this.rightChild(currentIndex) <= this.leftChild(currentIndex)"},{stage:4,text:"      ) {"},{stage:5,text:"        nextIndex = this.getRightChildIndex(currentIndex);"},{stage:4,text:"      } else {"},{stage:5,text:"        nextIndex = this.getLeftChildIndex(currentIndex);"},{stage:4,text:"      }"},{stage:5,text:""},{stage:6,text:"      if (this.heapContainer[currentIndex] <= this.heapContainer[nextIndex]) {"},{stage:6,text:"        break;"},{stage:6,text:"      }"},{stage:6,text:""},{stage:7,text:"      this.swap(currentIndex, nextIndex);"},{stage:7,text:"      currentIndex = nextIndex;"},{stage:3,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Oe={problemID:37,problemName:"Implement **insert** in a *BinarySearchTree* class.",problemText:"Write an **insert** method in a *BinarySearchTree* class that accepts a `value` (integer) and inserts it at the proper place in the tree.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"Insert value into empty tree.",inherit:[1],code:"tree.insert(5);",evaluate:"tree.root.value;",expected:5},{id:3,name:"Insert 2nd value.",inherit:[1,2],code:"tree.insert(7);",evaluate:"tree.root.right.value;",expected:7},{id:4,name:"Insert 3rd value.",inherit:[1,2,3],code:"tree.insert(6);",evaluate:"tree.root.right.left.value;",expected:6},{id:5,name:"Insert 4th value.",inherit:[1,2,3,4],code:"tree.insert(1);",evaluate:"tree.root.left.value;",expected:1},{id:6,name:"Insert 5th value.",inherit:[1,2,3,4,5],code:"tree.insert(2);",evaluate:"tree.root.left.right.value;",expected:2}],setupCode:"",source:[],tags:["Binary Search Tree",x],solution:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  insert(value) {"},{stage:2,text:"    const thisNode = new BinarySearchTreeNode(value);"},{stage:3,text:"    if (!this.root) {"},{stage:4,text:"      this.root = thisNode;"},{stage:3,text:"    } else {"},{stage:4,text:"      let currentRoot = this.root;"},{stage:4,text:"      while (true) {"},{stage:5,text:"        if (currentRoot.value > value) {"},{stage:6,text:"          if (currentRoot.left != null) {"},{stage:7,text:"            currentRoot = currentRoot.left;"},{stage:6,text:"          } else {"},{stage:7,text:"            currentRoot.left = thisNode;"},{stage:7,text:"            break;"},{stage:6,text:"          }"},{stage:5,text:"        } else if (currentRoot.value < value) {"},{stage:8,text:"          if (currentRoot.right != null) {"},{stage:9,text:"            currentRoot = currentRoot.right;"},{stage:8,text:"          } else {"},{stage:9,text:"            currentRoot.right = thisNode;"},{stage:9,text:"            break;"},{stage:8,text:"          }"},{stage:5,text:"        } else {"},{stage:9,text:"          break;"},{stage:5,text:"        }"},{stage:4,text:"      }"},{stage:3,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},qe={problemID:38,problemName:"Implement **search** in a *BinarySearchTree* class.",problemText:"Write a **search** method in a *BinarySearchTree* class that accepts a `value` (integer) and returns a boolean `true` or `false` indicating whether that integer is found within the tree.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"search an empty tree returns false",inherit:[1],code:"",evaluate:"tree.search(5);",expected:!1},{id:3,name:"search a tree finds value",inherit:[1],code:"tree.insert(5);",evaluate:"tree.search(5);",expected:!0},{id:4,name:"search a tree does not find value",inherit:[1],code:"tree.insert(5);",evaluate:"tree.search(2);",expected:!1},{id:5,name:"complex tree, found (1)",inherit:[1],code:"tree.insert(5);tree.insert(7);tree.insert(6);tree.insert(1);tree.insert(2);",evaluate:"tree.search(6);",expected:!0},{id:6,name:"complex tree, found (2)",inherit:[1,5],code:"",evaluate:"tree.search(1);",expected:!0},{id:7,name:"complex tree, not found (1)",inherit:[1,5],code:"",evaluate:"tree.search(8);",expected:!1},{id:8,name:"complex tree, not found (2)",inherit:[1,5],code:"",evaluate:"tree.search(4);",expected:!1}],setupCode:"".concat(F),source:[],tags:["Binary Search Tree",x],solution:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  search(value) {"},{stage:2,text:"    let currentRoot = this.root;"},{stage:2,text:"    let found = false;"},{stage:3,text:"    while (currentRoot) {"},{stage:4,text:"      if (currentRoot.value > value) {"},{stage:5,text:"        currentRoot = currentRoot.left;"},{stage:4,text:"      } else if (currentRoot.value < value) {"},{stage:5,text:"        currentRoot = currentRoot.right;"},{stage:4,text:"      } else {"},{stage:6,text:"        found = true;"},{stage:6,text:"        break;"},{stage:4,text:"      }"},{stage:3,text:"    }"},{stage:3,text:"    return found;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},De={problemID:39,problemName:"Implement **delete** in a *BinarySearchTree* class.",problemText:"Write a **delete** method in a *BinarySearchTree* class that accepts an integer `value` and deletes it from a tree, while maintaining a valid Binary Search Tree structure.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"delete on empty tree, no crash",inherit:[1],code:"tree.delete(5);",evaluate:"Boolean(tree);",expected:!0},{id:3,name:"insert an item into tree.  delete it. find it.",inherit:[1],code:"tree.insert(5);tree.delete(5);",evaluate:"tree.search(5);",expected:!1},{id:4,name:"insert two items into tree.  delete one. find the other.",inherit:[1],code:"tree.insert(5);tree.insert(6);tree.delete(5);",evaluate:"tree.search(6);",expected:!0},{id:5,name:"find the deleted of task #4.",inherit:[1,4],code:"",evaluate:"tree.search(5);",expected:!1}],setupCode:"".concat(F," ").concat("\nBinarySearchTree.prototype.search = function(value) {\n    let currentRoot = this.root;\n    let found = false;\n    while (currentRoot) {\n      if (currentRoot.value > value) {\n        currentRoot = currentRoot.left;\n      } else if (currentRoot.value < value) {\n        currentRoot = currentRoot.right;\n      } else {\n        found = true;\n        break;\n      }\n    }\n    return found;\n  };\n  "),source:[],tags:["Binary Search Tree",x],solution:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  delete(value) {"},{stage:2,text:"    this.root = deleteRecursively(this.root, value);"},{stage:2,text:""},{stage:2,text:"    function deleteRecursively(root, value) {"},{stage:3,text:"      if (!root) {"},{stage:4,text:"        return null;"},{stage:3,text:"      } else if (value < root.value) {"},{stage:4,text:"        root.left = deleteRecursively(root.left, value);"},{stage:3,text:"      } else if (value > root.value) {"},{stage:5,text:"        root.right = deleteRecursively(root.right, value);"},{stage:3,text:"      } else {"},{stage:6,text:"        if (!root.left && !root.right) {"},{stage:7,text:"          return null;"},{stage:6,text:"        } else if (!root.left) {"},{stage:7,text:"          root = root.right;"},{stage:7,text:"          return root;"},{stage:6,text:"        } else if (!root.right) {"},{stage:8,text:"          root = root.left;"},{stage:8,text:"          return root;"},{stage:6,text:"        } else {"},{stage:8,text:"          const temp = findMin(root.right);"},{stage:10,text:"          root.value = temp.value;"},{stage:10,text:"          root.right = deleteRecursively(root.right, temp.value);"},{stage:10,text:"          return root;"},{stage:6,text:"        }"},{stage:3,text:"      }"},{stage:5,text:"      return root;"},{stage:2,text:"    }"},{stage:9,text:""},{stage:8,text:"    function findMin(root) {"},{stage:9,text:"      while (root.left) {"},{stage:9,text:"        root = root.left;"},{stage:9,text:"      }"},{stage:9,text:"      return root;"},{stage:8,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Me={problemID:40,problemName:"Implement **traversePreOrderIterative** in a *BinarySearchTree* class.",problemText:"Write a **traversePreOrderIterative** method in a *BinarySearchTree* Class that traverses a tree iteratively and runs the supplied `callback` function on each node value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"proper pre-order ranking",inherit:[1],code:"tree.insert(5);tree.insert(3);tree.insert(11);tree.insert(0);tree.insert(7);tree.insert(2);tree.traversePreOrderIterative();",evaluate:"JSON.stringify(tree.tempNodeList);",expected:JSON.stringify([5,3,0,2,11,7])}],setupCode:"".concat(W," ").concat(F),source:[],tags:["Binary Search Tree",x],solution:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED  callback(value)"},{stage:-1,text:""},{stage:0,text:"  traversePreOrderIterative(node = this.root, callback = this.callback) {"},{stage:1,text:"    const nodeStack = [];"},{stage:1,text:"    nodeStack.push(node);"},{stage:1,text:""},{stage:2,text:"    while (nodeStack.length) {"},{stage:3,text:"      let next = nodeStack.pop();"},{stage:3,text:"      callback(next.value);"},{stage:4,text:"      if (next.right) {"},{stage:4,text:"        nodeStack.push(next.right);"},{stage:4,text:"      }"},{stage:5,text:"      if (next.left) {"},{stage:5,text:"        nodeStack.push(next.left);"},{stage:5,text:"      }"},{stage:2,text:"    }"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},je={problemID:41,problemName:"Implement **traversePreOrderRecursive** in a *BinarySearchTree* class.",problemText:"Write a **traversePreOrderRecursive** method in a *BinarySearchTree* class that traverses a tree recursively and runs the supplied `callback` function on each node value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"proper pre-order ranking",inherit:[1],code:"tree.insert(5);tree.insert(3);tree.insert(11);tree.insert(0);tree.insert(7);tree.insert(2);tree.traversePreOrderRecursive();",evaluate:"JSON.stringify(tree.tempNodeList);",expected:JSON.stringify([5,3,0,2,11,7])}],setupCode:"".concat(W," ").concat(F),source:[],tags:["Binary Search Tree",x],solution:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED  callback(value)"},{stage:-1,text:""},{stage:0,text:"  traversePreOrderRecursive(node = this.root, callback = this.callback) {"},{stage:1,text:"    if (!node) {"},{stage:1,text:"      return;"},{stage:0,text:"    }"},{stage:2,text:"    callback(node.value);"},{stage:3,text:"    this.traversePreOrderRecursive(node.left);"},{stage:3,text:"    this.traversePreOrderRecursive(node.right);"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Re={problemID:42,problemName:"Implement **traverseInOrderIterative** in a *BinarySearchTree* class.",problemText:"Write a **traverseInOrderIterative** method in a *BinarySearchTree* class that traverses a tree iteratively and runs the supplied `callback` function on each node value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"proper in-order ranking",inherit:[1],code:"tree.insert(5);tree.insert(3);tree.insert(11);tree.insert(0);tree.insert(7);tree.insert(2);tree.traverseInOrderIterative();",evaluate:"JSON.stringify(tree.tempNodeList);",expected:JSON.stringify([0,2,3,5,7,11])}],setupCode:"".concat(W," ").concat(F),source:[],tags:["Binary Search Tree",x],solution:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED  callback(value)"},{stage:-1,text:""},{stage:0,text:"  traverseInOrderIterative(node = this.root, callback = this.callback) {"},{stage:1,text:"    let stack = [];"},{stage:1,text:"    let done = false;"},{stage:1,text:""},{stage:2,text:"    while (!done) {"},{stage:3,text:"      if (node != null) {"},{stage:4,text:"        stack.push(node);"},{stage:4,text:"        node = node.left;"},{stage:3,text:"      } else {"},{stage:5,text:"        if (stack.length) {"},{stage:6,text:"          node = stack.pop();"},{stage:6,text:"          callback(node.value);"},{stage:7,text:"          node = node.right;"},{stage:5,text:"        } else {"},{stage:7,text:"          done = true;"},{stage:5,text:"        }"},{stage:3,text:"      }"},{stage:2,text:"    }"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},He={problemID:43,problemName:"Implement **traverseInOrderRecursive** in a *BinarySearchTree* class.",problemText:"Write a **traverseInOrderRecursive** method in a *BinarySearchTree* class that traverses a tree recursively and runs the supplied `callback` function on each node value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"proper in-order ranking",inherit:[1],code:"tree.insert(5);tree.insert(3);tree.insert(11);tree.insert(0);tree.insert(7);tree.insert(2);tree.traverseInOrderRecursive();",evaluate:"JSON.stringify(tree.tempNodeList);",expected:JSON.stringify([0,2,3,5,7,11])}],setupCode:"".concat(W," ").concat(F),source:[],tags:["Binary Search Tree",x],solution:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED  callback(value)"},{stage:-1,text:""},{stage:0,text:"  traverseInOrderRecursive(node = this.root, callback = this.callback) {"},{stage:1,text:"    if (!node) {"},{stage:1,text:"      return;"},{stage:1,text:"    }"},{stage:2,text:"    this.traverseInOrderRecursive(node.left);"},{stage:2,text:"    callback(node.value);"},{stage:3,text:"    this.traverseInOrderRecursive(node.right);"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Pe={problemID:44,problemName:"Implement **traversePostOrderIterative** in a *BinarySearchTree* class.",problemText:"Write a **traversePostOrderIterative** method in a *BinarySearchTree* class that traverses a tree iteratively and runs the supplied `callback` function on each node value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"proper post-order ranking",inherit:[1],code:"tree.insert(5);tree.insert(3);tree.insert(11);tree.insert(0);tree.insert(7);tree.insert(2);tree.traversePostOrderIterative();",evaluate:"JSON.stringify(tree.tempNodeList);",expected:JSON.stringify([2,0,3,7,11,5])}],setupCode:"".concat(W," ").concat(F),source:[],tags:["Binary Search Tree",x],solution:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED  callback(value)"},{stage:-1,text:""},{stage:0,text:"  traversePostOrderIterative(node = this.root, callback = this.callback) {"},{stage:1,text:"    const s1 = [];"},{stage:1,text:"    const s2 = [];"},{stage:1,text:"    s1.push(node);"},{stage:1,text:""},{stage:2,text:"    while (s1.length) {"},{stage:3,text:"      const next = s1.pop();"},{stage:3,text:"      s2.push(next);"},{stage:3,text:""},{stage:4,text:"      if (next.left) {"},{stage:4,text:"        s1.push(next.left);"},{stage:4,text:"      }"},{stage:5,text:"      if (next.right) {"},{stage:5,text:"        s1.push(next.right);"},{stage:5,text:"      }"},{stage:2,text:"    }"},{stage:6,text:"    while (s2.length) {"},{stage:7,text:"      const next = s2.pop();"},{stage:7,text:"      callback(next.value);"},{stage:6,text:"    }"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Be={problemID:45,problemName:"Implement **traversePostOrderRecursive** in a *BinarySearchTree* class.",problemText:"Write a **traversePostOrderRecursive** method in a *BinarySearchTree* class that traverses a tree recursively and runs the supplied `callback` function on each node value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"proper post-order ranking",inherit:[1],code:"tree.insert(5);tree.insert(3);tree.insert(11);tree.insert(0);tree.insert(7);tree.insert(2);tree.traversePostOrderRecursive();",evaluate:"JSON.stringify(tree.tempNodeList);",expected:JSON.stringify([2,0,3,7,11,5])}],setupCode:"".concat(W," ").concat(F),source:[],tags:["Binary Search Tree",x],solution:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"// IMPLEMENTED  callback(value)"},{stage:-1,text:""},{stage:0,text:"  traversePostOrderRecursive(node = this.root, callback = this.callback) {"},{stage:1,text:"    if (node.left) {"},{stage:1,text:"      this.traversePostOrderRecursive(node.left);"},{stage:1,text:"    }"},{stage:2,text:"    if (node.right) {"},{stage:2,text:"      this.traversePostOrderRecursive(node.right);"},{stage:2,text:"    }"},{stage:0,text:""},{stage:3,text:"    callback(node.value);"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Ae={problemID:46,problemName:"Implement a **traverseLevelOrderBfs** method in a *BinarySearchTree* class.",problemText:"Write a **traverseLevelOrderBfs** method in a *BinarySearchTree* class that traverses a tree iteratively and runs the supplied `callback` function on each node value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const tree=new BinarySearchTree();",evaluate:"Boolean(tree);",expected:!0},{id:2,name:"proper bfs",inherit:[1],code:"tree.insert(5);tree.insert(3);tree.insert(11);tree.insert(0);tree.insert(7);tree.insert(2);tree.traverseLevelOrderBfs();",evaluate:"JSON.stringify(tree.tempNodeList);",expected:JSON.stringify([5,3,11,0,7,2])}],setupCode:"".concat(W," ").concat(F),source:[],tags:["Binary Search Tree",x],solution:[{stage:0,text:"class BinarySearchTreeNode {"},{stage:0,text:"  constructor(value) {"},{stage:0,text:"    this.value = value;"},{stage:0,text:"    this.left = null;"},{stage:0,text:"    this.right = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class BinarySearchTree {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = null;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  traverseLevelOrderBfs(node = this.root, callback = this.callback) {"},{stage:1,text:"    const queue = [];"},{stage:1,text:"    if (!node) {"},{stage:1,text:"      return;"},{stage:1,text:"    }"},{stage:2,text:"    queue.push(node);"},{stage:0,text:""},{stage:2,text:"    while (queue.length) {"},{stage:3,text:"      const temp = queue.shift();"},{stage:3,text:"      callback(temp.value);"},{stage:4,text:"      if (temp.left) {"},{stage:4,text:"        queue.push(temp.left);"},{stage:4,text:"      }"},{stage:5,text:"      if (temp.right) {"},{stage:5,text:"        queue.push(temp.right);"},{stage:5,text:"      }"},{stage:2,text:"    }"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Je={problemID:47,problemName:"Implement the **addVertex** method for a *Graph* class.",problemText:"Implement an **addVertex** method that accepts a string `vertexKey` key, with no return value.  \n  Implementation involves:\n   - Create a Vertex node, and add it to the `vertices` lookup.\n   - Create a blank object entry in the adjacencyList `adjList` if there is not an existing entry for that node.",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"add single vertex, check vertices inventory",inherit:[1],code:"graph.addVertex('A');",evaluate:"graph.vertices['A'].key;",expected:"A"},{id:3,name:"adds single vertex, check adjacency list",inherit:[1,2],code:"",evaluate:"JSON.stringify(graph.adjList['A']);",expected:JSON.stringify({})},{id:4,name:"if already exists, do not clear place in adjacency list",inherit:[1,2],code:"graph.addVertex('B');graph.addEdge('A','B');graph.addVertex('A');",evaluate:"JSON.stringify(graph.adjList['A']) !== JSON.stringify({});",expected:!0}],setupCode:"".concat(V),source:[],tags:[p,x],solution:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:'    this.vertices = {};  // { "vertexKey": Vertex }'},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  addVertex(vertexKey) {"},{stage:2,text:"    const vertex = new Vertex(vertexKey);"},{stage:2,text:"    this.vertices[vertexKey] = vertex;"},{stage:2,text:""},{stage:3,text:"    if (!this.adjList[vertexKey]) {"},{stage:3,text:"      this.adjList[vertexKey] = {};"},{stage:3,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Ge={problemID:48,problemName:"Implement the **addEdge** method for a *Graph* class.",problemText:"Implement an **addEdge** method that accepts a `startingVertex` key (string) and an `endingVertex` key (string) and an optional `edgeWeight` (int, defaults to 1), with no return value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"creates vertices if they do not exist - start",inherit:[1],code:"graph.addEdge('A', 'B', 2);",evaluate:"Boolean(graph.vertices['A']);",expected:!0},{id:3,name:"creates vertices if they do not exist - end",inherit:[1,2],code:"",evaluate:"Boolean(graph.vertices['B']);",expected:!0},{id:4,name:"sets the proper edge weight",inherit:[1,2],code:"",evaluate:"graph.adjList['A']['B'].weight;",expected:2},{id:5,name:"defaults to 1 if edge weight is not given",inherit:[1],code:"graph.addEdge('A', 'B');",evaluate:"graph.adjList['A']['B'].weight;",expected:1},{id:6,name:"creates reverse path if not a directed network",inherit:[],code:"const graph=new Graph(false);graph.addEdge('A', 'B', 2);",evaluate:"graph.adjList['B']['A'].weight;",expected:2}],setupCode:"".concat(z),source:[],tags:[p,x],solution:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED: addVertex(key: string) void"},{stage:-1,text:""},{stage:1,text:"  addEdge(startVertexKey, endVertexKey, edgeWeight = 1) {"},{stage:2,text:"    if (!this.vertices[startVertexKey]) {"},{stage:2,text:"      this.addVertex(startVertexKey);"},{stage:2,text:"    }"},{stage:2,text:""},{stage:3,text:"    if (!this.vertices[endVertexKey]) {"},{stage:3,text:"      this.addVertex(endVertexKey);"},{stage:3,text:"    }"},{stage:3,text:""},{stage:4,text:"    const edge = new Edge(edgeWeight);"},{stage:4,text:""},{stage:4,text:"    this.adjList[startVertexKey][endVertexKey] = edge;"},{stage:4,text:""},{stage:5,text:"    if (!this.isDirected) {"},{stage:5,text:"      this.adjList[endVertexKey][startVertexKey] = edge;"},{stage:5,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Fe={problemID:49,problemName:"Implement the **deleteVertex** method for a *Graph* class.",problemText:"Implement a **deleteVertex** method that accepts a `vertexKey` (string), with no return value.  You must delete all items in the adjacency list which use that vertex.",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"add, then delete vertex",inherit:[1],code:"graph.addVertex('A');graph.deleteVertex('A');",evaluate:"Boolean(graph.vertices['A']);",expected:!1},{id:3,name:"add edge, make sure vertex is deleted from AdjList",inherit:[1],code:"graph.addEdge('A','B');graph.deleteVertex('A');",evaluate:"graph.adjList['A'] === undefined;",expected:!0},{id:4,name:"removed from reverse side of AdjList",inherit:[],code:"const graph=new Graph(false);graph.addEdge('A','B');graph.deleteVertex('A');",evaluate:"JSON.stringify(graph.adjList['B']);",expected:JSON.stringify({})}],setupCode:"".concat(z," ").concat(V),source:[],tags:[p,x],solution:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  deleteVertex(vertexKey) {"},{stage:2,text:"    delete this.vertices[vertexKey];"},{stage:2,text:"    delete this.adjList[vertexKey];"},{stage:3,text:"    for (let key of Object.keys(this.adjList)) {"},{stage:4,text:"      for (let vk of Object.keys(this.adjList[key])) {"},{stage:5,text:"        if (vk === vertexKey) {"},{stage:5,text:"          delete this.adjList[key][vk];"},{stage:5,text:"        }"},{stage:4,text:"      }"},{stage:3,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},We={problemID:50,problemName:"Implement the **deleteEdge** method for a *Graph* class.",problemText:"Implement a **deleteEdge** method that accepts a `startingVertex` key (string) and an `endingVertex` key (string), with no return value.  Account for directed and undirected graphs.",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"add edge, then delete. Check edge.",inherit:[1],code:"graph.addEdge('A', 'B');graph.deleteEdge('A', 'B');",evaluate:"Boolean(graph.adjList['A'] && graph.adjList['A']['B']);",expected:!1},{id:3,name:"add edge, then delete. Check reverse edge on undirected graph.",inherit:[],code:"const graph=new Graph(false);graph.addEdge('A', 'B');graph.deleteEdge('A', 'B');",evaluate:"Boolean(graph.adjList['B'] && graph.adjList['B']['A']);",expected:!1},{id:4,name:"trying to delete edge that does not exist should not throw error.",inherit:[],code:"const graph=new Graph();",evaluate:"graph.deleteEdge('A', 'B');",expected:void 0},{id:5,name:"trying to delete reverse edge that does not exist should not throw error.",inherit:[],code:"const graph=new Graph(false);",evaluate:"graph.deleteEdge('A', 'B');",expected:void 0}],setupCode:"".concat(z," ").concat(V),source:[],tags:[p,x],solution:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  deleteEdge(startVertexKey, endVertexKey) {"},{stage:2,text:"    if (this.adjList[startVertexKey]) {"},{stage:2,text:"      delete this.adjList[startVertexKey][endVertexKey];"},{stage:2,text:"    }"},{stage:2,text:""},{stage:3,text:"    if (!this.isDirected && this.adjList[endVertexKey]) {"},{stage:3,text:"      delete this.adjList[endVertexKey][startVertexKey];"},{stage:3,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Ke={problemID:51,problemName:"Implement a recursive **dfs** (depth first search) method for a *Graph* class.",problemText:"Implement a **dfs** method that accepts a `startingVertex` key (string) and a `callback` function (supplied) to be run on each graph node.  **Use recursion!**",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"dfs network 1",inherit:[1],code:"graph.addEdge('42', '41');graph.addEdge('42', '50');graph.addEdge('41', '10');graph.addEdge('41', '40');graph.addEdge('50', '45');graph.addEdge('50', '75');graph.dfs('42');",evaluate:"JSON.stringify(graph.tempSet);",expected:JSON.stringify(["42","41","10","40","50","45","75"])},{id:3,name:"dfs network 2",inherit:[1],code:"graph.addEdge('A', 'B');graph.addEdge('B', 'C');graph.addEdge('B', 'E');graph.addEdge('C', 'D');graph.addEdge('D', 'G');graph.addEdge('D', 'F');graph.addEdge('G', 'H');graph.addEdge('F', 'J');graph.dfs('A');",evaluate:"JSON.stringify(graph.tempSet);",expected:JSON.stringify(["A","B","C","D","G","H","F","J","E"])}],setupCode:"".concat(Y," ").concat(z," ").concat(V),source:[],tags:[p,x],solution:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED: callback(vertex: Vertex) void"},{stage:-1,text:""},{stage:0,text:"  dfs(startVertexKey, callback = this.callback) {"},{stage:1,text:"    const visited = {};"},{stage:0,text:""},{stage:2,text:"    const traverseDfs = vertex => {"},{stage:3,text:"      visited[vertex] = true;"},{stage:3,text:"      callback(vertex);"},{stage:4,text:"      for (let adjacent of Object.keys(this.adjList[vertex] || [])) {"},{stage:5,text:"        if (!visited[adjacent]) {"},{stage:5,text:"          traverseDfs(adjacent);"},{stage:5,text:"        }"},{stage:4,text:"      }"},{stage:2,text:"    };"},{stage:6,text:""},{stage:6,text:"    traverseDfs(startVertexKey);"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Ve={problemID:56,problemName:"Implement an iterative **dfs** (depth first search) method for a *Graph* class.",problemText:"Implement a **dfs** method that accepts a `startingVertex` key (string) and a `callback` function (supplied) to be run on each graph node.  **Implement iteratively!**",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"dfs network 1",inherit:[1],code:"graph.addEdge('42', '41');graph.addEdge('42', '50');graph.addEdge('41', '10');graph.addEdge('41', '40');graph.addEdge('50', '45');graph.addEdge('50', '75');graph.dfs('42');",evaluate:"JSON.stringify(graph.tempSet);",expected:JSON.stringify(["42","50","75","45","41","40","10"])},{id:3,name:"dfs network 2",inherit:[1],code:"graph.addEdge('A', 'B');graph.addEdge('B', 'C');graph.addEdge('B', 'E');graph.addEdge('C', 'D');graph.addEdge('D', 'G');graph.addEdge('D', 'F');graph.addEdge('G', 'H');graph.addEdge('F', 'J');graph.dfs('A');",evaluate:"JSON.stringify(graph.tempSet);",expected:JSON.stringify(["A","B","E","C","D","F","J","G","H"])}],setupCode:"".concat(Y," ").concat(z," ").concat(V),source:[],tags:[p,x],solution:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED: callback(vertex: Vertex) void"},{stage:-1,text:""},{stage:0,text:"  dfs(startVertexKey, callback = this.callback) {"},{stage:1,text:"    const stack = [];"},{stage:1,text:"    const visited = {};"},{stage:1,text:"    stack.push(startVertexKey);"},{stage:0,text:""},{stage:2,text:"    while (stack.length) {"},{stage:3,text:"      const vertexKey = stack.pop();"},{stage:3,text:"      if (!visited[vertexKey]) {"},{stage:4,text:"        callback(vertexKey);"},{stage:4,text:"        visited[vertexKey] = true;"},{stage:5,text:"        for (let adjacent of Object.keys(this.adjList[vertexKey] || {})) {"},{stage:5,text:"          stack.push(adjacent);"},{stage:5,text:"        }"},{stage:3,text:"      }"},{stage:2,text:"    }"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},ze={problemID:52,problemName:"Implement a **bfs** (breadth first search) method for a *Graph* class.",problemText:"Implement a **bfs** method that accepts a `startingVertex` key (string) and a `callback` function (supplied) to be run on each graph node.",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"bfs network 1",inherit:[1],code:"graph.addEdge('42', '41');graph.addEdge('42', '50');graph.addEdge('41', '10');graph.addEdge('41', '40');graph.addEdge('50', '45');graph.addEdge('50', '75');graph.bfs('42');",evaluate:"JSON.stringify(graph.tempSet);",expected:JSON.stringify(["42","41","50","10","40","45","75"])},{id:3,name:"bfs network 2",inherit:[1],code:"graph.addEdge('A', 'B');graph.addEdge('B', 'C');graph.addEdge('B', 'E');graph.addEdge('C', 'D');graph.addEdge('D', 'G');graph.addEdge('D', 'F');graph.addEdge('G', 'H');graph.addEdge('F', 'J');graph.bfs('A');",evaluate:"JSON.stringify(graph.tempSet);",expected:JSON.stringify(["A","B","C","E","D","G","F","H","J"])}],setupCode:"".concat(Y," ").concat(z," ").concat(V),source:[],tags:[p,x],solution:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:-1,text:"  // IMPLEMENTED: callback(vertex: Vertex) void"},{stage:-1,text:""},{stage:0,text:"  bfs(startVertexKey, callback = this.callback) {"},{stage:1,text:"    const queue = [];"},{stage:1,text:"    const visited = {};"},{stage:1,text:"    queue.push(startVertexKey);"},{stage:1,text:""},{stage:2,text:"    while (queue.length) {"},{stage:3,text:"      const vertexKey = queue.shift();"},{stage:3,text:"      if (!visited[vertexKey]) {"},{stage:4,text:"        callback(vertexKey);"},{stage:4,text:"        visited[vertexKey] = true;"},{stage:5,text:"        for (let adjacent of Object.keys(this.adjList[vertexKey] || {})) {"},{stage:5,text:"          queue.push(adjacent);"},{stage:5,text:"        }"},{stage:3,text:"      }"},{stage:2,text:"    }"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Ye={problemID:57,problemName:"Implement a **detectCycle** method for a *Graph* class.",problemText:"Implement a **detectCycle** method that returns either `true` or `false` depending upon whether or not the graph contains a cycle.",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"detectCycle 1 - false",inherit:[1],code:"graph.addEdge('42', '41');graph.addEdge('42', '50');graph.addEdge('41', '10');graph.addEdge('41', '40');graph.addEdge('50', '45');graph.addEdge('50', '75');",evaluate:"graph.detectCycle();",expected:!1},{id:3,name:"detectCycle 2 - false",inherit:[1],code:"graph.addEdge('A', 'B');graph.addEdge('B', 'C');graph.addEdge('B', 'E');graph.addEdge('C', 'D');graph.addEdge('D', 'G');graph.addEdge('D', 'F');graph.addEdge('G', 'H');graph.addEdge('F', 'J');",evaluate:"graph.detectCycle();",expected:!1},{id:4,name:"detectCycle 3 - true",inherit:[1],code:"graph.addEdge('A', 'B');graph.addEdge('B', 'C');graph.addEdge('C', 'A');",evaluate:"graph.detectCycle();",expected:!0}],setupCode:"".concat(Y," ").concat(z," ").concat(V),source:[],tags:[p,x],solution:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  detectCycle() {"},{stage:1,text:"    let visited = {};"},{stage:1,text:"    let recNodes = {};"},{stage:0,text:""},{stage:3,text:"    for (let key of Object.keys(this.adjList)) {"},{stage:4,text:"      if (this.detectCycleRec(key, visited, recNodes)) {"},{stage:5,text:"        return true;"},{stage:4,text:"      }"},{stage:3,text:"    }"},{stage:5,text:"    return false;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:2,text:"  detectCycleRec(key, visited, recNodes) {"},{stage:3,text:"    if (!visited[key]) {"},{stage:4,text:"      visited[key] = true;"},{stage:4,text:"      recNodes[key] = true;"},{stage:0,text:""},{stage:7,text:"      for (let adjacentKey of Object.keys(this.adjList[key])) {"},{stage:8,text:"        if (!visited[adjacentKey] && this.detectCycleRec(adjacentKey, visited, recNodes)) {"},{stage:9,text:"          return true;"},{stage:8,text:"        } else if (recNodes[adjacentKey]) {"},{stage:9,text:"          return true;"},{stage:8,text:"        }"},{stage:7,text:"      }"},{stage:3,text:"    }"},{stage:0,text:""},{stage:6,text:"    recNodes[key] = false;"},{stage:6,text:"    return false;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Ue={problemID:58,problemName:"Implement a **checkPath** method for a *Graph* class.",problemText:"Implement a **checkPath** method that takes a `source` key and a `destination` key and returns either `true` or `false` depending upon whether or not the graph contains a path from one to the other.",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"path to itself always true",inherit:[1],code:"graph.addEdge('42', '41');graph.addEdge('42', '50');graph.addEdge('41', '10');graph.addEdge('41', '40');graph.addEdge('50', '45');graph.addEdge('50', '75');",evaluate:"graph.checkPath('42', '42');",expected:!0},{id:3,name:"path q1 - true",inherit:[1,2],code:"",evaluate:"graph.checkPath('42', '10');",expected:!0},{id:4,name:"path q2 - true",inherit:[1,2],code:"",evaluate:"graph.checkPath('42', '40');",expected:!0},{id:5,name:"path q3 - true",inherit:[1,2],code:"",evaluate:"graph.checkPath('42', '75');",expected:!0},{id:6,name:"path q4 - false",inherit:[1,2],code:"",evaluate:"graph.checkPath('42', '88');",expected:!1},{id:7,name:"path q5 - false",inherit:[1,2],code:"",evaluate:"graph.checkPath('50', '41');",expected:!1}],setupCode:"".concat(Y," ").concat(z," ").concat(V),source:[],tags:[p,x],solution:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  checkPath(source, destination) {"},{stage:1,text:"    if (source === destination) {"},{stage:1,text:"      return true;"},{stage:1,text:"    }"},{stage:0,text:""},{stage:2,text:"    const visited = {};"},{stage:2,text:"    const stack = [];"},{stage:3,text:"    stack.push(source);"},{stage:3,text:"    visited[source] = true;"},{stage:0,text:""},{stage:4,text:"    while (stack.length) {"},{stage:5,text:"      let currentKey = stack.pop();"},{stage:0,text:""},{stage:5,text:"      for (let adjacentKey of Object.keys(this.adjList[currentKey])) {"},{stage:6,text:"        if (!visited[adjacentKey]) {"},{stage:7,text:"          if (adjacentKey === destination) {"},{stage:7,text:"            return true;"},{stage:7,text:"          }"},{stage:8,text:"          stack.push(adjacentKey);"},{stage:8,text:"          visited[adjacentKey] = true;"},{stage:6,text:"        }"},{stage:5,text:"      }"},{stage:4,text:"    }"},{stage:0,text:""},{stage:9,text:"    return false;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Qe={problemID:59,problemName:"Implement a **shortestPath** method for a *Graph* class.",problemText:"Implement a **shortestPath** method that takes a `source` key and a `destination` key and returns the shortest possible distance (integer) from one to the other.  Assume all edge lengths are 1.  Return `-1` if no path exists.",testCases:[{id:1,name:"compiles",inherit:[],code:"const graph=new Graph();",evaluate:"Boolean(graph);",expected:!0},{id:2,name:"path to itself is 0",inherit:[1],code:"graph.addEdge('42', '41');graph.addEdge('42', '50');graph.addEdge('41', '10');graph.addEdge('41', '40');graph.addEdge('50', '45');graph.addEdge('50', '75');graph.addEdge('75', '100');",evaluate:"graph.shortestPath('42', '42');",expected:0},{id:3,name:"path query 1",inherit:[1,2],code:"",evaluate:"graph.shortestPath('42', '10');",expected:2},{id:4,name:"path query 2",inherit:[1,2],code:"",evaluate:"graph.shortestPath('42', '40');",expected:2},{id:5,name:"path query 3",inherit:[1,2],code:"",evaluate:"graph.shortestPath('42', '100');",expected:3},{id:6,name:"no path returns -1",inherit:[1,2],code:"",evaluate:"graph.shortestPath('42', '1000');",expected:-1}],setupCode:"".concat(Y," ").concat(z," ").concat(V),source:[],tags:[p,x],solution:[{stage:0,text:"class Vertex {"},{stage:0,text:"  constructor(key) {"},{stage:0,text:"    this.key = key;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Edge {"},{stage:0,text:"  constructor(weight) {"},{stage:0,text:"    this.weight = weight;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Graph {"},{stage:0,text:"  constructor(isDirected = true) {"},{stage:0,text:"    this.isDirected = isDirected === true;"},{stage:0,text:"    this.adjList = {};"},{stage:0,text:"    this.vertices = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  shortestPath(source, destination) {"},{stage:1,text:"    if (source == destination) {"},{stage:1,text:"      return 0;"},{stage:1,text:"    }"},{stage:0,text:""},{stage:2,text:"    let visited = {};"},{stage:2,text:"    let distance = {};"},{stage:2,text:"    distance[source] = 0;"},{stage:0,text:""},{stage:3,text:"    let queue = [];"},{stage:3,text:"    queue.push(source);"},{stage:0,text:""},{stage:4,text:"    while (queue.length) {"},{stage:5,text:"      const currentKey = queue.shift();"},{stage:0,text:""},{stage:5,text:"      for (let adjacentKey of Object.keys(this.adjList[currentKey])) {"},{stage:6,text:"        if (!visited[adjacentKey]) {"},{stage:8,text:"          queue.push(adjacentKey);"},{stage:8,text:"          visited[currentKey] = true;"},{stage:8,text:"          distance[adjacentKey] = distance[currentKey] + 1;"},{stage:6,text:"        }"},{stage:7,text:"        if (adjacentKey == destination) {"},{stage:7,text:"          return distance[destination];"},{stage:7,text:"        }"},{stage:5,text:"      }"},{stage:4,text:"    }"},{stage:0,text:""},{stage:7,text:"    return -1;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Xe={problemID:53,problemName:"Implement the **insert** method for a *Trie* class.",problemText:"Implement an **insert** method that takes a `word` (string) as a parameter, with no return value.",testCases:[{id:1,name:"compiles",inherit:[],code:"const trie=new Trie();",evaluate:"Boolean(trie);",expected:!0},{id:2,name:"insert word, search true",inherit:[1],code:"trie.insert('daniel');",evaluate:"trie.search('daniel');",expected:!0},{id:3,name:"insert word, search half of that word.  return false",inherit:[1,2],code:"",evaluate:"trie.search('dan');",expected:!1}],setupCode:"".concat(U),source:[],tags:["Trie",x],solution:[{stage:0,text:"class TrieNode {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.children = {};"},{stage:0,text:"    this.endOfWord = false;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Trie {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = new TrieNode();"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  insert(word) {"},{stage:2,text:"    let current = this.root;"},{stage:2,text:"    for (let i = 0; i < word.length; i++) {"},{stage:3,text:"      const ch = word.charAt(i);"},{stage:3,text:"      let node = current.children[ch];"},{stage:4,text:"      if (node == null) {"},{stage:5,text:"        node = new TrieNode();"},{stage:5,text:"        current.children[ch] = node;"},{stage:4,text:"      }"},{stage:6,text:"      current = node;"},{stage:2,text:"    }"},{stage:6,text:"    current.endOfWord = true;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Ze={problemID:54,problemName:"Implement the **search** method for a *Trie* class.",problemText:"Implement a **search** method that takes in a `word` (string) and returns a boolean `true` or `false` depending on if it can be found in the Trie.",testCases:[{id:1,name:"compiles",inherit:[],code:"const trie=new Trie();",evaluate:"Boolean(trie);",expected:!0},{id:2,name:"nothing in trie should return false on search",inherit:[1],code:"",evaluate:"trie.search('');",expected:!1},{id:3,name:"insert word, search true",inherit:[1],code:"trie.insert('daniel');",evaluate:"trie.search('daniel');",expected:!0},{id:4,name:"insert word, search half of that word.  return false",inherit:[1,3],code:"",evaluate:"trie.search('dan');",expected:!1}],setupCode:"".concat(Q),source:[],tags:["Trie",x],solution:[{stage:0,text:"class TrieNode {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.children = {};"},{stage:0,text:"    this.endOfWord = false;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Trie {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = new TrieNode();"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  search(word) {"},{stage:2,text:"    let current = this.root;"},{stage:2,text:"    for (let i = 0; i < word.length; i++) {"},{stage:3,text:"      const ch = word.charAt(i);"},{stage:3,text:"      const node = current.children[ch];"},{stage:4,text:"      if (node == null) {"},{stage:4,text:"        return false;"},{stage:4,text:"      }"},{stage:5,text:"      current = node;"},{stage:2,text:"    }"},{stage:5,text:"    return current.endOfWord;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},$e={problemID:55,problemName:"Implement the **delete** method for a *Trie* class.",problemText:"Implement a **delete** method that takes in a `word` (string) and removes it from the Trie.",testCases:[{id:1,name:"compiles",inherit:[],code:"const trie=new Trie();",evaluate:"Boolean(trie);",expected:!0},{id:2,name:"insert, delete.  search is false.",inherit:[1],code:"trie.insert('daniel');trie.insert('david');trie.delete('daniel');",evaluate:"trie.search('daniel');",expected:!1},{id:3,name:"insert, delete.  search for non-deleted is true.",inherit:[1,2],code:"",evaluate:"trie.search('david');",expected:!0},{id:4,name:"delete remaining word.  search should be false.",inherit:[1,2],code:"trie.delete('david');",evaluate:"trie.search('david');",expected:!1}],setupCode:"".concat(Q," ").concat(U),source:[],tags:["Trie",x],solution:[{stage:0,text:"class TrieNode {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.children = {};"},{stage:0,text:"    this.endOfWord = false;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class Trie {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.root = new TrieNode();"},{stage:0,text:"  }"},{stage:0,text:""},{stage:1,text:"  delete(word) {"},{stage:2,text:"    deleteRecursively(this.root, word, 0);"},{stage:2,text:""},{stage:2,text:"    function deleteRecursively(current, word, index) {"},{stage:3,text:"      if (index === word.length) {"},{stage:4,text:"        if (!current.endOfWord) {"},{stage:4,text:"          return false;"},{stage:4,text:"        }"},{stage:5,text:"        current.endOfWord = false;"},{stage:5,text:"        return Object.keys(current.children).length === 0;"},{stage:3,text:"      }"},{stage:6,text:"      const ch = word.charAt(index);"},{stage:6,text:"      const node = current.children[ch];"},{stage:7,text:"      if (node == null) {"},{stage:7,text:"        return false;"},{stage:7,text:"      }"},{stage:8,text:"      const shouldDelete = deleteRecursively(node, word, index + 1);"},{stage:8,text:"      if (shouldDelete) {"},{stage:9,text:"        delete current.children[ch];"},{stage:9,text:"        return Object.keys(current.children).length === 0;"},{stage:8,text:"      }"},{stage:9,text:"      return false;"},{stage:2,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},et={problemID:60,problemName:"Implement a recursive binary search function.",problemText:"Implement a function **binarySearchRecursive** which takes an array of sorted, unique integers `array`, and a single integer `n` and returns the index where that integer is found in the array, or `-1` if not found.\n  Please solve **recursively**.",testCases:[{id:1,name:"case 1",inherit:[],code:"const arr = [1, 2, 3, 5, 7, 8, 9, 11, 13, 15, 17, 18, 21, 24, 27, 31, 34, 38, 42, 46, 50];",evaluate:"binarySearchRecursive(arr, 8);",expected:5},{id:2,name:"case 2",inherit:[1],code:"",evaluate:"binarySearchRecursive(arr, 13);",expected:8},{id:3,name:"case 3",inherit:[1],code:"",evaluate:"binarySearchRecursive(arr, 18);",expected:11},{id:4,name:"case 4",inherit:[1],code:"",evaluate:"binarySearchRecursive(arr, 42);",expected:18},{id:5,name:"case 5",inherit:[1],code:"",evaluate:"binarySearchRecursive(arr, 6);",expected:-1}],setupCode:"",source:[],tags:["Binary Search",d,"Recursion"],solution:[{stage:0,text:""},{stage:0,text:"function binarySearchRecursive(array, n, startIndex, endIndex) {"},{stage:-1,text:"  // initially, binarySearchRecursive is called with only (array, n)"},{stage:-1,text:"  // these lines initialize startIndex and endIndex on first run"},{stage:1,text:"  if (!startIndex) {"},{stage:1,text:"    startIndex = 0;"},{stage:1,text:"  }"},{stage:2,text:"  if (!endIndex) {"},{stage:2,text:"    endIndex = array.length - 1;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:3,text:"  let middleIndex = Math.floor((startIndex + endIndex) / 2);"},{stage:4,text:"  let val = array[middleIndex];"},{stage:0,text:""},{stage:-5,text:"  // when either the startIndex exceeds the end endIndex"},{stage:-5,text:"  // or if the indexes are equal, yet there is still no match, return -1 (not found)"},{stage:5,text:"  if (endIndex <= startIndex && val !== n) {"},{stage:6,text:"    return -1;"},{stage:5,text:"  } else if (val === n) {"},{stage:-7,text:"    // if there is a match, return the index"},{stage:7,text:"    return middleIndex;"},{stage:5,text:"  } else if (val < n) {"},{stage:-8,text:"    // new startIndex becomes middleIndex + 1"},{stage:8,text:"    return binarySearchRecursive(array, n, middleIndex + 1, endIndex);"},{stage:5,text:"  } else {"},{stage:-9,text:"    // new endIndex becomes middleIndex - 1"},{stage:9,text:"    return binarySearchRecursive(array, n, startIndex, middleIndex - 1);"},{stage:5,text:"  }"},{stage:0,text:"}"},{stage:0,text:""}]},tt={problemID:61,problemName:"Implement an iterative binary search function.",problemText:"Implement a function **binarySearchIterative** which takes an array of sorted, unique integers `array`, and a single integer `n` and returns the index where that integer is found in the array, or `-1` if not found.\n  Please solve **iteratively**.",testCases:[{id:1,name:"case 1",inherit:[],code:"const arr = [1, 2, 3, 5, 7, 8, 9, 11, 13, 15, 17, 18, 21, 24, 27, 31, 34, 38, 42, 46, 50];",evaluate:"binarySearchIterative(arr, 8);",expected:5},{id:2,name:"case 2",inherit:[1],code:"",evaluate:"binarySearchIterative(arr, 13);",expected:8},{id:3,name:"case 3",inherit:[1],code:"",evaluate:"binarySearchIterative(arr, 18);",expected:11},{id:4,name:"case 4",inherit:[1],code:"",evaluate:"binarySearchIterative(arr, 42);",expected:18},{id:5,name:"case 5",inherit:[1],code:"",evaluate:"binarySearchIterative(arr, 6);",expected:-1}],setupCode:"",source:[],tags:["Binary Search",d],solution:[{stage:0,text:""},{stage:0,text:"function binarySearchIterative(sortedArray, n) {"},{stage:-1,text:"  // use two pointers, one as the first index in the array, one as the last"},{stage:1,text:"  let startIndex = 0;"},{stage:1,text:"  let endIndex = sortedArray.length - 1;"},{stage:0,text:""},{stage:2,text:"  while (startIndex <= endIndex) {"},{stage:-3,text:"    // calculate the middle index of the (remaining) array"},{stage:3,text:"    let middleIndex = Math.floor((startIndex + endIndex) / 2);"},{stage:3,text:"    let val = sortedArray[middleIndex];"},{stage:0,text:""},{stage:4,text:"    if (n < val) {"},{stage:-5,text:"      // the number we're looking for is less than the number at middleIndex"},{stage:-5,text:"      // update the endIndex to be one less than middleIndex"},{stage:5,text:"      endIndex = middleIndex - 1;"},{stage:4,text:"    } else if (n > val) {"},{stage:-6,text:"      // the number we're looking for is greater than the number at middleIndex"},{stage:-6,text:"      // update the startIndex to be one more than middleIndex"},{stage:6,text:"      startIndex = middleIndex + 1;"},{stage:4,text:"    } else {"},{stage:-7,text:"      // we've found the target number (n).  Return the index."},{stage:7,text:"      return middleIndex;"},{stage:4,text:"    }"},{stage:2,text:"  }"},{stage:0,text:""},{stage:8,text:"  return -1;"},{stage:0,text:"}"},{stage:0,text:""}]},at={problemID:62,problemName:"Implement the quicksort algorithm.",problemText:"Implement a function **quickSort** which takes an array of unsorted integers, sorts them in place using the Quicksort algorithm and returns the array.",testCases:[{id:1,name:"case 1",inherit:[],code:"const arr = [];",evaluate:"quickSort(arr);",expected:JSON.stringify([])},{id:2,name:"case 2",inherit:[],code:"const arr = [5, 8, 1, 9, 3, 8, 2, 0, 2, 34, 2, 456, 342, 26, 75, 23];",evaluate:"quickSort(arr);",expected:JSON.stringify([0,1,2,2,2,3,5,8,8,9,23,26,34,75,342,456])},{id:3,name:"case 3",inherit:[],code:"const arr = [75, 98, 19, 99, 34, 48, 42, 40, 12, 134, 21, 1456, 3421, 1126, 1175, 2311];",evaluate:"quickSort(arr);",expected:JSON.stringify([12,19,21,34,40,42,48,75,98,99,134,1126,1175,1456,2311,3421])}],setupCode:"",source:[],tags:["Sorting",d],solution:[{stage:0,text:""},{stage:0,text:"function quickSort(items) {"},{stage:0,text:""},{stage:1,text:"  return quickSortHelper(items, 0, items.length - 1);"},{stage:0,text:"}"},{stage:0,text:""},{stage:2,text:"function quickSortHelper(items, left, right) {"},{stage:3,text:"  if (items.length > 1) {"},{stage:4,text:"    const index = partition(items, left, right);"},{stage:0,text:""},{stage:5,text:"    if (left < index - 1) {"},{stage:6,text:"      quickSortHelper(items, left, index - 1);"},{stage:5,text:"    }"},{stage:0,text:""},{stage:5,text:"    if (index < right) {"},{stage:6,text:"      quickSortHelper(items, index, right);"},{stage:5,text:"    }"},{stage:3,text:"  }"},{stage:0,text:""},{stage:4,text:"  return items;"},{stage:2,text:"}"},{stage:0,text:""},{stage:7,text:"function partition(array, left, right) {"},{stage:8,text:"  const pivot = array[Math.floor((right + left) / 2)];"},{stage:9,text:"  while (left <= right) {"},{stage:10,text:"    while (pivot > array[left]) {"},{stage:11,text:"      left++;"},{stage:10,text:"    }"},{stage:10,text:"    while (pivot < array[right]) {"},{stage:11,text:"      right--;"},{stage:10,text:"    }"},{stage:0,text:""},{stage:12,text:"    if (left <= right) {"},{stage:13,text:"      const temp = array[left];"},{stage:13,text:"      array[left] = array[right];"},{stage:13,text:"      array[right] = temp;"},{stage:14,text:"      left++;"},{stage:14,text:"      right--;"},{stage:12,text:"    }"},{stage:9,text:"  }"},{stage:0,text:""},{stage:15,text:"  return left;"},{stage:7,text:"}"},{stage:0,text:""}]},nt={problemID:63,problemName:"Implement the mergesort algorithm.",problemText:"Implement a function **mergeSort** which takes an array of unsorted integers, sorts them in place using the Mergesort algorithm and returns the array.",testCases:[{id:1,name:"case 1",inherit:[],code:"const arr = [];",evaluate:"mergeSort(arr);",expected:JSON.stringify([])},{id:2,name:"case 2",inherit:[],code:"const arr = [5, 8, 1, 9, 3, 8, 2, 0, 2, 34, 2, 456, 342, 26, 75, 23];",evaluate:"mergeSort(arr);",expected:JSON.stringify([0,1,2,2,2,3,5,8,8,9,23,26,34,75,342,456])},{id:3,name:"case 3",inherit:[],code:"const arr = [75, 98, 19, 99, 34, 48, 42, 40, 12, 134, 21, 1456, 3421, 1126, 1175, 2311];",evaluate:"mergeSort(arr);",expected:JSON.stringify([12,19,21,34,40,42,48,75,98,99,134,1126,1175,1456,2311,3421])}],setupCode:"",source:[],tags:["Sorting",d],solution:[{stage:0,text:""},{stage:0,text:"function mergeSort(array) {"},{stage:1,text:"  if (array.length <= 1) {"},{stage:1,text:"    return array;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:2,text:"  const midpoint = Math.floor(array.length / 2);"},{stage:2,text:"  const leftArray = array.slice(0, midpoint);"},{stage:2,text:"  const rightArray = array.slice(midpoint);"},{stage:0,text:""},{stage:3,text:"  return merge(mergeSort(leftArray), mergeSort(rightArray));"},{stage:0,text:"}"},{stage:0,text:""},{stage:4,text:"function merge(leftArr, rightArr) {"},{stage:5,text:"  const results = [];"},{stage:5,text:"  let leftIndex = 0;"},{stage:5,text:"  let rightIndex = 0;"},{stage:0,text:""},{stage:6,text:"  while (leftIndex < leftArr.length && rightIndex < rightArr.length) {"},{stage:7,text:"    if (leftArr[leftIndex] < rightArr[rightIndex]) {"},{stage:8,text:"      results.push(leftArr[leftIndex]);"},{stage:8,text:"      leftIndex = leftIndex + 1;"},{stage:7,text:"    } else {"},{stage:9,text:"      results.push(rightArr[rightIndex]);"},{stage:9,text:"      rightIndex = rightIndex + 1;"},{stage:7,text:"    }"},{stage:6,text:"  }"},{stage:0,text:""},{stage:10,text:"  const leftRemains = leftArr.slice(leftIndex);"},{stage:10,text:"  const rightRemains = rightArr.slice(rightIndex);"},{stage:0,text:""},{stage:11,text:"  return results.concat(leftRemains).concat(rightRemains);"},{stage:4,text:"}"},{stage:0,text:""}]},st={problemID:64,problemName:"Solve Two Sum (Unsorted Array).",problemText:"Given an unsorted array of integers `array`, and an integer `target`, return the indices of two numbers in the `array` that sum to `target`.\n  Assume one solution.  Return indices in a two element array.  Solution can be returned in any order.\n  Return `null` if no solution could be found.",testCases:[{id:1,name:"case 1",inherit:[],code:"",evaluate:"twoSum([3, 6, 17, 12], 9);",expected:JSON.stringify([0,1])},{id:2,name:"case 2",inherit:[],code:"",evaluate:"twoSum([3, 4, 5], 9);",expected:JSON.stringify([1,2])},{id:3,name:"case 3",inherit:[],code:"",evaluate:"twoSum([2, 2], 4)",expected:JSON.stringify([0,1])},{id:4,name:"not found",inherit:[],code:"",evaluate:"twoSum([1, 3], 7) === null;",expected:!0}],setupCode:"",lcid:1,source:["https://leetcode.com/problems/two-sum/"],tags:[v,d],solution:[{stage:0,text:""},{stage:0,text:"function twoSum(array, target) {"},{stage:1,text:"  let hash = {};"},{stage:0,text:""},{stage:2,text:"  for (let [index, num] of array.entries()) {"},{stage:3,text:"    const difference = target - num;"},{stage:4,text:"    if (hash[difference] !== undefined) {"},{stage:5,text:"      return [hash[difference], index];"},{stage:4,text:"    }"},{stage:5,text:"    hash[num] = index;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:1,text:"  return null;"},{stage:0,text:"}"},{stage:0,text:""}]},rt={problemID:65,problemName:"Solve Minimum Rectangle.",problemText:"Find the area of the smallest rectangle formed by a given array of `points`.  To qualify as a rectangle, it must have sides parallel to the X and Y axis.\n  Return `0` if no solution could be found.",testCases:[{id:1,name:"no solution found",inherit:[],code:"",evaluate:"minimumRectangle([[3, 6]]);",expected:0},{id:2,name:"case 1",inherit:[],code:"",evaluate:"minimumRectangle([[2,2],[2,4],[4,2],[4,4],[3,3]]);",expected:4},{id:3,name:"case 2",inherit:[],code:"",evaluate:"minimumRectangle([[2,2],[2,4],[4,2],[4,4],[5,2],[5,4]]);",expected:2}],setupCode:"",lcid:939,source:["https://leetcode.com/problems/minimum-area-rectangle"],tags:[v,d],solution:[{stage:0,text:""},{stage:0,text:"function minimumRectangle(points) {"},{stage:1,text:"  const map = {};"},{stage:0,text:""},{stage:2,text:"  for (const [x, y] of points) {"},{stage:3,text:"    if (!map[x]) {"},{stage:3,text:"      map[x] = [];"},{stage:3,text:"    }"},{stage:4,text:"    map[x].push(y);"},{stage:2,text:"  }"},{stage:0,text:""},{stage:5,text:"  let min = Infinity;"},{stage:0,text:""},{stage:6,text:"  for (const [x1, y1] of points) {"},{stage:7,text:"    for (const [x2, y2] of points) {"},{stage:8,text:"      if (x1 === x2 || y1 === y2) {"},{stage:8,text:"        continue;"},{stage:8,text:"      }"},{stage:0,text:""},{stage:9,text:"      if (map[x1].includes(y2) && map[x2].includes(y1)) {"},{stage:10,text:"        min = Math.min(min, Math.abs(x1 - x2) * Math.abs(y1 - y2));"},{stage:9,text:"      }"},{stage:7,text:"    }"},{stage:6,text:"  }"},{stage:0,text:""},{stage:11,text:"  return min === Infinity ? 0 : min;"},{stage:0,text:"}"},{stage:0,text:""}]},it={problemID:66,problemName:"Implement an *LRUCache* class.",problemText:"Implement **get** and **put** methods for an *LRUCache* class which uses an internal *DoublyLinkList* class to store the data.  \n   - The **get** method will return a value for a given `key`, or will return `-1` if that `key` is not found in the cache.\n   - The **put** method will either modify or add a node to the top of the cache, and evict a node from the bottom of the cache if the cache exceeds capacity.\n  ",testCases:[{id:1,name:"compiles",inherit:[],code:"const cache = new LRUCache(3);",evaluate:"Boolean(cache);",expected:!0},{id:2,name:"evicts propertly",inherit:[1],code:"cache.put('a', 1);cache.put('b', 2);cache.put('c', 3);cache.put('d', 4);",evaluate:"cache.list();",expected:JSON.stringify([{key:"d",data:4},{key:"c",data:3},{key:"b",data:2}])},{id:3,name:"get returns correct item",inherit:[1,2],code:"",evaluate:"cache.get('c');",expected:3},{id:4,name:"get moves item to top of list",inherit:[1,2],code:"cache.get('c');",evaluate:"cache.list()",expected:JSON.stringify([{key:"c",data:3},{key:"d",data:4},{key:"b",data:2}])},{id:5,name:"get returns -1 when not in cache",inherit:[1],code:"cache.put('a', 1);",evaluate:"cache.get('c');",expected:-1}],setupCode:"\n  LRUCache.prototype.list = function () {\n    let arr = [];\n    let node = this.ll.head.next;\n    while (node && node.next) {\n      arr.push({ key: node.key, data: node.data });\n      node = node.next;\n    }\n    return arr;\n  };\n  ",lcid:146,source:["https://leetcode.com/problems/lru-cache"],tags:["Cache",d,"Amazon","Cruise"],solution:[{stage:0,text:""},{stage:0,text:"class Node {"},{stage:0,text:"  constructor(key, data) {"},{stage:0,text:"    this.data = data;"},{stage:0,text:"    this.key = key;"},{stage:0,text:"    this.prev = null;"},{stage:0,text:"    this.next = null;"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class DoublyLinkedList {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.head = new Node('head', 0);"},{stage:0,text:"    this.tail = new Node('tail', 0);"},{stage:0,text:"    this.head.next = this.tail;"},{stage:0,text:"    this.tail.prev = this.head;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:3,text:"  detach(node) {"},{stage:4,text:"    const prev = node.prev;"},{stage:4,text:"    const next = node.next;"},{stage:4,text:"    prev.next = next;"},{stage:4,text:"    next.prev = prev;"},{stage:3,text:"  }"},{stage:0,text:""},{stage:6,text:"  addToFront(node) {"},{stage:7,text:"    const head = this.head;"},{stage:7,text:"    const hnext = head.next;"},{stage:8,text:"    head.next = node;"},{stage:8,text:"    node.next = hnext;"},{stage:8,text:"    node.prev = head;"},{stage:8,text:"    hnext.prev = node;"},{stage:6,text:"  }"},{stage:0,text:""},{stage:12,text:"  removeLast() {"},{stage:13,text:"    const del = this.tail.prev;"},{stage:13,text:"    const prev = del.prev;"},{stage:13,text:"    prev.next = this.tail;"},{stage:13,text:"    this.tail.prev = prev;"},{stage:12,text:"  }"},{stage:0,text:"}"},{stage:0,text:""},{stage:0,text:"class LRUCache {"},{stage:0,text:"  constructor(capacity) {"},{stage:0,text:"    if (!capacity) {"},{stage:0,text:"      throw new Error('Declare LRUCache with an integer capacity > 0.');"},{stage:0,text:"    }"},{stage:0,text:"    this.capacity = capacity;"},{stage:0,text:"    this.count = 0;"},{stage:0,text:"    this.hash = {};"},{stage:0,text:"    this.ll = new DoublyLinkedList();"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  get(key) {"},{stage:1,text:"    const node = this.hash[key];"},{stage:1,text:"    if (node === undefined) {"},{stage:1,text:"      return -1;"},{stage:1,text:"    }"},{stage:2,text:"    this.ll.detach(node);"},{stage:5,text:"    this.ll.addToFront(node);"},{stage:5,text:"    return node.data;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  put(key, value) {"},{stage:9,text:"    let node = this.hash[key];"},{stage:9,text:"    if (!node) {"},{stage:10,text:"      this.count++;"},{stage:10,text:"      if (this.count > this.capacity) {"},{stage:11,text:"        this.ll.removeLast();"},{stage:11,text:"        this.count--;"},{stage:10,text:"      }"},{stage:14,text:"      node = new Node(key, value);"},{stage:14,text:"      this.hash[key] = node;"},{stage:9,text:"    } else {"},{stage:15,text:"      node.data = value;"},{stage:15,text:"      this.ll.detach(node);"},{stage:9,text:"    }"},{stage:16,text:"    this.ll.addToFront(node);"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""}]},ot={problemID:67,problemName:"Implement a Calculator to evaluate an expression string. (Lvl 3)",problemText:"Implement a **calculate** function that takes a string `s`, and evaluates it with respect to parentheses grouping and order of operations.\n  Integer division should truncate to 0.  (ex: 5/2 = 2).  Assume the expression string is always a valid expression.",testCases:[{id:1,name:"single integer",inherit:[],code:"",evaluate:"calculate('5');",expected:5},{id:2,name:"simple expression",inherit:[],code:"",evaluate:"calculate('2+2');",expected:4},{id:3,name:"simple expression whitespace",inherit:[],code:"",evaluate:"calculate('2 + 2');",expected:4},{id:4,name:"proper order of operations",inherit:[],code:"",evaluate:"calculate('12-4/2');",expected:10},{id:5,name:"truncate integer division",inherit:[],code:"",evaluate:"calculate('10-5/2');",expected:8},{id:6,name:"simple parentheses",inherit:[],code:"",evaluate:"calculate('(5-2)*(8+4)');",expected:36},{id:7,name:"advanced 1",inherit:[],code:"",evaluate:"calculate('3*(10+5*2)/4+(6/2+12)');",expected:30}],setupCode:"",lcid:227,source:["https://leetcode.com/problems/basic-calculator-ii/"],tags:["Stack",d],solution:[{stage:0,text:""},{stage:0,text:"function calculate(s) {"},{stage:1,text:"  s = s.replaceAll(' ', '');"},{stage:1,text:"  const stack = [];"},{stage:2,text:"  let sign = '+';"},{stage:2,text:"  let i = 0;"},{stage:3,text:"  while (i < s.length) {"},{stage:4,text:"    let c = s[i];"},{stage:4,text:"    if (c === '(') {"},{stage:5,text:"      let l = 1;"},{stage:5,text:"      let j = i + 1;"},{stage:5,text:"      while (j < s.length && l > 0) {"},{stage:6,text:"        if (s[j] === '(') {"},{stage:7,text:"          l++;"},{stage:6,text:"        } else if (s.charAt(j) == ')') {"},{stage:7,text:"          l--;"},{stage:6,text:"        }"},{stage:7,text:"        j++;"},{stage:5,text:"      }"},{stage:8,text:"      let blockValue = calculate(s.substring(i + 1, j - 1));"},{stage:8,text:"      i = j;"},{stage:9,text:"      if (sign === '+') {"},{stage:10,text:"        stack.push(blockValue);"},{stage:9,text:"      } else if (sign === '-') {"},{stage:10,text:"        stack.push(-blockValue);"},{stage:9,text:"      } else if (sign === '*') {"},{stage:10,text:"        stack.push(stack.pop() * blockValue);"},{stage:9,text:"      } else if (sign === '/') {"},{stage:11,text:"        let temp = stack.pop() / blockValue;"},{stage:11,text:"        if (temp < 0) {"},{stage:11,text:"          stack.push(Math.ceil(temp));"},{stage:11,text:"        } else {"},{stage:11,text:"          stack.push(Math.floor(temp));"},{stage:11,text:"        }"},{stage:9,text:"      }"},{stage:4,text:"    } else if (isCharNumber(c)) {"},{stage:12,text:"      let j = i;"},{stage:12,text:"      let value = 0;"},{stage:13,text:"      while (j < s.length && isCharNumber(s[j])) {"},{stage:14,text:"        value = 10 * value + (s[j] - '0');"},{stage:14,text:"        j++;"},{stage:13,text:"      }"},{stage:15,text:"      i = j;"},{stage:16,text:"      if (sign === '+') {"},{stage:17,text:"        stack.push(value);"},{stage:16,text:"      } else if (sign === '-') {"},{stage:17,text:"        stack.push(-value);"},{stage:16,text:"      } else if (sign === '*') {"},{stage:17,text:"        stack.push(stack.pop() * value);"},{stage:16,text:"      } else if (sign === '/') {"},{stage:18,text:"        let temp = stack.pop() / value;"},{stage:18,text:"        if (temp < 0) {"},{stage:19,text:"          stack.push(Math.ceil(temp));"},{stage:18,text:"        } else {"},{stage:19,text:"          stack.push(Math.floor(temp));"},{stage:18,text:"        }"},{stage:16,text:"      }"},{stage:4,text:"    } else {"},{stage:20,text:"      sign = c;"},{stage:20,text:"      i++;"},{stage:4,text:"    }"},{stage:3,text:"  }"},{stage:0,text:""},{stage:21,text:"  let res = 0;"},{stage:21,text:"  while (stack.length) {"},{stage:22,text:"    res += stack.pop();"},{stage:21,text:"  }"},{stage:22,text:"  return res;"},{stage:0,text:"}"},{stage:0,text:""},{stage:5,text:"function isCharNumber(c) {"},{stage:5,text:"  return c >= '0' && c <= '9';"},{stage:5,text:"}"},{stage:0,text:""}]},lt={problemID:68,problemName:"Solve Word Search.",problemText:"Given a `board` (two dimensional array), and a `word` (string), create a function **wordSearch** which returns a boolean indicating whether the word can be found on the board.  \n  The word can be constructed from a series of letters which are either horizontally or vertically adjacent.  The same board letter can not be used multiple times.",testCases:[{id:1,name:"case 1",inherit:[],code:"\n      const board = [\n        ['B', 'C', 'D', 'F'],\n        ['T', 'G', 'D', 'T'],\n        ['B', 'E', 'F', 'F'],\n      ];\n      const word = 'BCDDFE';",evaluate:"wordSearch(board, word);",expected:!0},{id:2,name:"case 2",inherit:[],code:"\n      const board = [\n        ['B', 'C', 'D', 'F'],\n        ['T', 'G', 'D', 'T'],\n        ['B', 'E', 'F', 'F'],\n      ];\n      const word = 'TFF';",evaluate:"wordSearch(board, word);",expected:!0},{id:3,name:"case 3",inherit:[],code:"\n      const board = [\n        ['B', 'C', 'D', 'F'],\n        ['T', 'G', 'D', 'T'],\n        ['B', 'E', 'F', 'F'],\n      ];\n      const word = 'BDDC';",evaluate:"wordSearch(board, word);",expected:!1}],setupCode:"",lcid:79,source:["https://leetcode.com/problems/word-search/"],tags:["Recursion",d,"Cruise"],solution:[{stage:0,text:""},{stage:0,text:"function wordSearch(board, word) {"},{stage:1,text:"  for (let [rowIndex, row] of board.entries()) {"},{stage:1,text:"    for (let [columnIndex, letter] of row.entries()) {"},{stage:2,text:"      if (navigate(board, word, rowIndex, columnIndex, 0) === true) {"},{stage:2,text:"        return true;"},{stage:2,text:"      }"},{stage:1,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:3,text:"  return false;"},{stage:0,text:"}"},{stage:0,text:""},{stage:4,text:"function navigate(board, word, rowIndex, columnIndex, wordCharIndex) {"},{stage:5,text:"  let nextCharToFind = word[wordCharIndex];"},{stage:5,text:"  if (!nextCharToFind) {"},{stage:5,text:"    return true;"},{stage:5,text:"  }"},{stage:0,text:""},{stage:6,text:"  if ("},{stage:6,text:"    rowIndex < 0 ||"},{stage:6,text:"    rowIndex == board.length ||"},{stage:6,text:"    columnIndex < 0 ||"},{stage:6,text:"    columnIndex == board[0].length ||"},{stage:6,text:"    board[rowIndex][columnIndex] != nextCharToFind"},{stage:6,text:"  ) {"},{stage:7,text:"    return false;"},{stage:6,text:"  }"},{stage:0,text:""},{stage:8,text:"  let ret = false;"},{stage:8,text:"  board[rowIndex][columnIndex] = '#';"},{stage:0,text:""},{stage:9,text:"  let loop = ["},{stage:9,text:"    [-1, 0],"},{stage:9,text:"    [0, -1],"},{stage:9,text:"    [0, 1],"},{stage:9,text:"    [1, 0],"},{stage:9,text:"  ];"},{stage:10,text:"  for (let item of loop) {"},{stage:11,text:"    ret = navigate(board, word, rowIndex + item[0], columnIndex + item[1], wordCharIndex + 1);"},{stage:12,text:"    if (ret) {"},{stage:12,text:"      break;"},{stage:12,text:"    }"},{stage:10,text:"  }"},{stage:0,text:""},{stage:13,text:"  board[rowIndex][columnIndex] = word[wordCharIndex];"},{stage:13,text:"  return ret;"},{stage:4,text:"}"},{stage:0,text:""}]},gt={problemID:69,problemName:"Reorder a *LinkedList*.",problemText:"Given a `head` *Node*, reorder a linked list of length `n` so that a *LinkedList* in the pattern of:\n\n  ( L<sub>1</sub> -> L<sub>2</sub> -> L<sub>3</sub> -> L<sub>4</sub> -> L<sub>5</sub> )\n\n  becomes:\n\n  ( L<sub>1</sub> -> L<sub>n</sub> -> L<sub>2</sub> -> L<sub>n-1</sub> -> L<sub>3</sub> )\n  \n  List must be re-ordered in place, using no additional data structures.\n  ",testCases:[{id:1,name:"reorder empty list does not error",inherit:[],code:"reorderList(null);",evaluate:"reorderList(null);",expected:void 0},{id:2,name:"case 1",inherit:[],code:"let head = new Node(1);\n      head.next = new Node(2);\n      head.next.next = new Node(3);\n      head.next.next.next = new Node(4);\n      head.next.next.next.next = new Node(5);\n      reorderList(head);",evaluate:"printList(head);",expected:JSON.stringify([1,5,2,4,3])}],setupCode:"\n  function Node(val) {\n    this.val = val;\n    this.next = null;\n  }\n\n  function printList(head) {\n    const arr = [];\n    while (head) {\n      arr.push(head.val);\n      head = head.next;\n    }\n    return arr;\n  }",lcid:143,source:["https://leetcode.com/problems/reorder-list"],tags:[c,d],solution:[{stage:0,text:""},{stage:-1,text:"function Node(val) {"},{stage:-1,text:"  this.val = val;"},{stage:-1,text:"  this.next = null;"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function reorderList(head) {"},{stage:1,text:"  if (!head) {"},{stage:1,text:"    return;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:2,text:"  let slow = head;"},{stage:2,text:"  let fast = head;"},{stage:3,text:"  while (fast && fast.next) {"},{stage:4,text:"    slow = slow.next;"},{stage:4,text:"    fast = fast.next.next;"},{stage:3,text:"  }"},{stage:0,text:""},{stage:5,text:"  let prev = null;"},{stage:5,text:"  let curr = slow;"},{stage:5,text:"  let tmp = null;"},{stage:6,text:"  while (curr != null) {"},{stage:7,text:"    tmp = curr.next;"},{stage:7,text:"    curr.next = prev;"},{stage:7,text:"    prev = curr;"},{stage:7,text:"    curr = tmp;"},{stage:6,text:"  }"},{stage:0,text:""},{stage:8,text:"  let first = head;"},{stage:8,text:"  let second = prev;"},{stage:9,text:"  while (second.next) {"},{stage:10,text:"    tmp = first.next;"},{stage:10,text:"    first.next = second;"},{stage:10,text:"    first = tmp;"},{stage:0,text:""},{stage:11,text:"    tmp = second.next;"},{stage:11,text:"    second.next = first;"},{stage:11,text:"    second = tmp;"},{stage:9,text:"  }"},{stage:0,text:"}"},{stage:0,text:""}]},xt={problemID:70,problemName:"Find anagrams in a string.",problemText:"Given a string `str` and another string `p`, find all the start indices of `p`'s anagrams within `str`.\n\n  - All characters in either string are lowercase letters.\n  - Return the indices as an array of integers.  Indices should be returned in ascending order.",testCases:[{id:1,name:"string (str) length shorter than find (p)length",inherit:[],code:"",evaluate:'findAnagrams("a", "abc");',expected:JSON.stringify([])},{id:2,name:"case 1",inherit:[],code:"",evaluate:"findAnagrams('cbaebabacd', 'abc');",expected:JSON.stringify([0,6])},{id:3,name:"case 2",inherit:[],code:"",evaluate:"findAnagrams('abab', 'ab');",expected:JSON.stringify([0,1,2])}],setupCode:"",lcid:438,source:["https://leetcode.com/problems/find-all-anagrams-in-a-string"],tags:[v,d],solution:[{stage:0,text:""},{stage:0,text:"function findAnagrams(str, p) {"},{stage:1,text:"  if (str.length < p.length) {"},{stage:1,text:"    return [];"},{stage:1,text:"  }"},{stage:0,text:""},{stage:2,text:"  const pCount = {};"},{stage:2,text:"  const strCount = {};"},{stage:0,text:""},{stage:3,text:"  for (let i = 0; i < p.length; i++) {"},{stage:4,text:"    let ch = p[i];"},{stage:4,text:"    if (pCount[ch]) {"},{stage:5,text:"      pCount[ch]++;"},{stage:4,text:"    } else {"},{stage:5,text:"      pCount[ch] = 1;"},{stage:4,text:"    }"},{stage:3,text:"  }"},{stage:0,text:""},{stage:6,text:"  const output = [];"},{stage:0,text:""},{stage:6,text:"  for (let i = 0; i < str.length; ++i) {"},{stage:7,text:"    let ch = str[i];"},{stage:7,text:"    if (strCount[ch]) {"},{stage:8,text:"      strCount[ch]++;"},{stage:7,text:"    } else {"},{stage:8,text:"      strCount[ch] = 1;"},{stage:7,text:"    }"},{stage:0,text:""},{stage:9,text:"    if (i >= p.length) {"},{stage:10,text:"      ch = str[i - p.length];"},{stage:10,text:"      if (strCount[ch] == 1) {"},{stage:11,text:"        delete strCount[ch];"},{stage:10,text:"      } else {"},{stage:11,text:"        strCount[ch] = strCount[ch] - 1;"},{stage:10,text:"      }"},{stage:9,text:"    }"},{stage:0,text:""},{stage:12,text:"    if (Object.keys(pCount).length === Object.keys(strCount).length) {"},{stage:13,text:"      let isEqual = true;"},{stage:0,text:""},{stage:13,text:"      for (let key of Object.keys(pCount)) {"},{stage:14,text:"        if (pCount[key] !== strCount[key]) {"},{stage:14,text:"          isEqual = false;"},{stage:14,text:"          break;"},{stage:14,text:"        }"},{stage:13,text:"      }"},{stage:0,text:""},{stage:15,text:"      if (isEqual) {"},{stage:15,text:"        output.push(i - p.length + 1);"},{stage:15,text:"      }"},{stage:12,text:"    }"},{stage:6,text:"  }"},{stage:0,text:""},{stage:16,text:"  return output;"},{stage:0,text:"}"},{stage:0,text:""}]},dt={problemID:71,problemName:"Implement a *RandomizedSet* class.",problemText:"Implement a *RandomizedSet* class with **insert**, **remove** and **getRandom** methods.\n  \n   - **insert**: Inserts an item `val` into the set if not present. Returns `true` if the item was not present, false otherwise.\n   - **remove**: Removes an item `val` from the set if present. Returns `true` if the item was present, `false` otherwise.\n   - **getRandom**:  Returns a random element from the current set of elements, or `null` if there are no items in the set. Each element must have the same probability of being returned.\n\n   All operations should perform in O(1) time.\n   ",testCases:[{id:1,name:"compiles",inherit:[],code:"const randomizedSet = new RandomizedSet();",evaluate:"Boolean(randomizedSet);",expected:!0},{id:2,name:"getRandom on empty returns null",inherit:[1],code:"",evaluate:"randomizedSet.getRandom();",expected:null},{id:3,name:"insert returns true the first time a value is added",inherit:[1],code:"",evaluate:"randomizedSet.insert(1);",expected:!0},{id:4,name:"remove returns false if item is not in set",inherit:[1],code:"",evaluate:"randomizedSet.remove(2);",expected:!1},{id:5,name:"getRandom returns a valid value",inherit:[1],code:"randomizedSet.insert(1);randomizedSet.insert(2);",evaluate:"const a = randomizedSet.getRandom(); a === 1 || a === 2;",expected:!0},{id:6,name:"remove returns true when removing a valid value",inherit:[1,5],code:"",evaluate:"randomizedSet.remove(1);",expected:!0},{id:7,name:"insert returns false if item is already in set",inherit:[1,5],code:"",evaluate:"randomizedSet.insert(2);",expected:!1},{id:8,name:"getRandom returns only possible value",inherit:[1,5],code:"randomizedSet.remove(1);",evaluate:"randomizedSet.getRandom();",expected:2}],setupCode:"",lcid:380,source:["https://leetcode.com/problems/insert-delete-getrandom-o1"],tags:[v,d],solution:[{stage:0,text:""},{stage:0,text:"class RandomizedSet {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.dict = {};"},{stage:0,text:"    this.list = [];"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  insert(val) {"},{stage:1,text:"    if (this.dict[val] != null) {"},{stage:1,text:"      return false;"},{stage:1,text:"    }"},{stage:2,text:"    this.dict[val] = this.list.length;"},{stage:2,text:"    this.list.push(val);"},{stage:2,text:"    return true;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  remove(val) {"},{stage:3,text:"    if (this.dict[val] == null) {"},{stage:3,text:"      return false;"},{stage:3,text:"    }"},{stage:0,text:""},{stage:4,text:"    const lastElement = this.list[this.list.length - 1];"},{stage:4,text:"    const idx = this.dict[val];"},{stage:5,text:"    this.list[idx] = lastElement;"},{stage:5,text:"    this.dict[lastElement] = idx;"},{stage:0,text:""},{stage:6,text:"    this.list.pop();"},{stage:6,text:"    delete this.dict[val];"},{stage:6,text:"    return true;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  getRandom() {"},{stage:7,text:"    if (!this.list.length) {"},{stage:7,text:"      return null;"},{stage:7,text:"    }"},{stage:8,text:"    return this.list[Math.floor(Math.random(1) * this.list.length)];"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""}]},ct={problemID:72,problemName:"Minimum Path Sum on a 2D Matrix.",problemText:"Given a 2D `grid` filled with positive integers, trace a path from the top left to the bottom right which produces the minimum sum along its path, and return that value.\n\n   - Your path must only follow a trajectory of downward and rightward movements.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"minPathSum([\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1],\n      ]);",expected:7},{id:2,name:"example 2",inherit:[],code:"",evaluate:"minPathSum([\n        [1, 2, 3],\n        [4, 5, 6],\n      ]);",expected:12}],setupCode:"",lcid:64,source:["https://leetcode.com/problems/minimum-path-sum"],tags:["Dynamic Programming",d],solution:[{stage:0,text:""},{stage:0,text:"function minPathSum(grid) {"},{stage:1,text:"  const lastRow = grid.length - 1;"},{stage:2,text:"  for (let row = lastRow; row >= 0; row--) {"},{stage:3,text:"    const lastColumn = grid[row].length - 1;"},{stage:4,text:"    for (let column = lastColumn; column >= 0; column--) {"},{stage:5,text:"      if (row == lastRow && column != lastColumn) {"},{stage:6,text:"        grid[row][column] = grid[row][column] + grid[row][column + 1];"},{stage:5,text:"      } else if (column == lastColumn && row != lastRow) {"},{stage:7,text:"        grid[row][column] = grid[row][column] + grid[row + 1][column];"},{stage:5,text:"      } else if (column != lastColumn && row != lastRow) {"},{stage:8,text:"        grid[row][column] ="},{stage:8,text:"          grid[row][column] + Math.min(grid[row + 1][column], grid[row][column + 1]);"},{stage:5,text:"      }"},{stage:4,text:"    }"},{stage:2,text:"  }"},{stage:0,text:""},{stage:9,text:"  return grid[0][0];"},{stage:0,text:"}"},{stage:0,text:""}]},ut={problemID:73,problemName:"Determine Number of Islands in a 2D Grid.",problemText:"Given an 2d `grid` of '1's (land) and '0's (water), return the number of islands.\n\n  An island is surrounded by water and includes all land connected horizontally or vertically. \n  \n  Assume areas outside the bounds of the grid are water.",testCases:[{id:1,name:"example 1",inherit:[],code:"const grid = [\n        ['1', '1', '1', '1', '0'],\n        ['1', '1', '0', '1', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '0', '0', '0'],\n      ];",evaluate:"numIslands(grid);",expected:1},{id:1,name:"example 1",inherit:[],code:"const grid = [\n        ['1', '1', '0', '0', '0'],\n        ['1', '1', '0', '0', '0'],\n        ['0', '0', '1', '0', '0'],\n        ['0', '0', '0', '1', '1'],\n      ];",evaluate:"numIslands(grid);",expected:3}],setupCode:"",lcid:200,source:["https://leetcode.com/problems/number-of-islands"],tags:[v,d,"Amazon","Cruise"],solution:[{stage:0,text:""},{stage:0,text:"function numIslands(grid) {"},{stage:1,text:"  let count = 0;"},{stage:0,text:""},{stage:1,text:"  for (let row = 0; row < grid.length; row++) {"},{stage:2,text:"    for (let column = 0; column < grid[row].length; column++) {"},{stage:3,text:"      if (grid[row][column] === '1') {"},{stage:4,text:"        count++;"},{stage:4,text:"        doBFS(grid, row, column);"},{stage:3,text:"      }"},{stage:2,text:"    }"},{stage:1,text:"  }"},{stage:5,text:"  return count;"},{stage:0,text:"}"},{stage:0,text:""},{stage:6,text:"function doBFS(grid, row, column) {"},{stage:7,text:"  const rowOutOfBounds = row < 0 || row >= grid.length;"},{stage:7,text:"  if (rowOutOfBounds) {"},{stage:7,text:"    return;"},{stage:7,text:"  }"},{stage:8,text:"  const columnOutOfBounds = column < 0 || column >= grid[row].length;"},{stage:8,text:"  if (columnOutOfBounds || grid[row][column] === '0') {"},{stage:8,text:"    return;"},{stage:8,text:"  }"},{stage:0,text:""},{stage:9,text:"  grid[row][column] = '0';"},{stage:0,text:""},{stage:10,text:"  doBFS(grid, row + 1, column);"},{stage:10,text:"  doBFS(grid, row - 1, column);"},{stage:11,text:"  doBFS(grid, row, column + 1);"},{stage:11,text:"  doBFS(grid, row, column - 1);"},{stage:6,text:"}"},{stage:0,text:""}]},ht={problemID:74,problemName:"Solve Decode Ways Recursively",problemText:"A message containing letters from A-Z can be encoded into numbers using the following mapping:\n\n   - 'A' -> \"1\"\n   - 'B' -> \"2\"\n   - ...\n   - 'Z' -> \"26\"\n\n  To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways).\n  \n  Given a string `s` containing only digits, return the number of ways to decode it.\n  \n  Please solve using recursion.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"numDecodingsRecursive('12');",expected:2},{id:2,name:"example 2",inherit:[],code:"",evaluate:"numDecodingsRecursive('226');",expected:3},{id:3,name:"example 3",inherit:[],code:"",evaluate:"numDecodingsRecursive('0');",expected:0},{id:4,name:"example 4",inherit:[],code:"",evaluate:"numDecodingsRecursive('06');",expected:0}],setupCode:"",lcid:91,source:["https://leetcode.com/problems/decode-ways"],tags:["Dynamic Programming",d],solution:[{stage:0,text:""},{stage:0,text:"function numDecodingsRecursive(s) {"},{stage:0,text:""},{stage:1,text:"  const memo = {};"},{stage:1,text:"  return recursiveWithMemo(0, s, memo);"},{stage:0,text:"}"},{stage:0,text:""},{stage:2,text:"function recursiveWithMemo(index, str, memo) {"},{stage:3,text:"  if (memo[index] != null) {"},{stage:3,text:"    return memo[index];"},{stage:3,text:"  }"},{stage:0,text:""},{stage:4,text:"  if (index === str.length) {"},{stage:4,text:"    return 1;"},{stage:4,text:"  }"},{stage:0,text:""},{stage:5,text:"  if (str[index] === '0') {"},{stage:5,text:"    return 0;"},{stage:5,text:"  }"},{stage:0,text:""},{stage:6,text:"  if (index === str.length - 1) {"},{stage:6,text:"    return 1;"},{stage:6,text:"  }"},{stage:0,text:""},{stage:7,text:"  let ans = recursiveWithMemo(index + 1, str, memo);"},{stage:8,text:"  if (parseInt(str.substring(index, index + 2), 10) <= 26) {"},{stage:9,text:"    ans += recursiveWithMemo(index + 2, str, memo);"},{stage:8,text:"  }"},{stage:0,text:""},{stage:10,text:"  memo[index] = ans;"},{stage:0,text:""},{stage:11,text:"  return ans;"},{stage:2,text:"}"},{stage:0,text:""}]},pt={problemID:75,problemName:"Add Two Linked Lists.",problemText:"You are given the head nodes for each of two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as the head node of a linked list (also in reverse order).\n\n  You may assume the two numbers do not contain any leading zero, except the number 0 itself.",testCases:[{id:1,name:"example 1",inherit:[],code:"\n      const ex1l1 = new ListNode(2);ex1l1.next = new ListNode(4);ex1l1.next.next = new ListNode(3);const ex1l2 = new ListNode(5);ex1l2.next = new ListNode(6);ex1l2.next.next = new ListNode(4);",evaluate:"addTwoNumbers(ex1l1, ex1l2).convert();",expected:JSON.stringify([7,0,8])},{id:2,name:"example 2",inherit:[],code:"const ex2l1 = new ListNode(0);const ex2l2 = new ListNode(0);",evaluate:"addTwoNumbers(ex2l1, ex2l2).convert();",expected:JSON.stringify([0])},{id:3,name:"example 3",inherit:[],code:"const ex3l1 = new ListNode(9);ex3l1.next = new ListNode(9);ex3l1.next.next = new ListNode(9);const ex3l2 = new ListNode(9);ex3l2.next = new ListNode(9);",evaluate:"addTwoNumbers(ex3l1, ex3l2).convert();",expected:JSON.stringify([8,9,0,1])}],setupCode:"\n  function ListNode(val) {\n    this.val = val;\n    this.next = null;\n  }\n\n  ListNode.prototype.convert = function () {\n    const arr = [];\n    let node = this;\n    while (node) {\n      arr.push(node.val);\n      node = node.next;\n    }\n    return arr;\n  };\n  ",lcid:2,source:["https://leetcode.com/problems/add-two-numbers"],tags:[c,d],solution:[{stage:0,text:""},{stage:-1,text:"function ListNode(val) {"},{stage:-1,text:"  this.val = val;"},{stage:-1,text:"  this.next = null;"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function addTwoNumbers(l1, l2) {"},{stage:1,text:"  const dummyHead = new ListNode(0);"},{stage:1,text:"  let curr = dummyHead;"},{stage:0,text:""},{stage:2,text:"  let p = l1;"},{stage:2,text:"  let q = l2;"},{stage:2,text:"  let carry = 0;"},{stage:3,text:"  while (p || q) {"},{stage:4,text:"    let x = p ? p.val : 0;"},{stage:4,text:"    let y = q ? q.val : 0;"},{stage:5,text:"    let sum = carry + x + y;"},{stage:5,text:"    carry = Math.floor(sum / 10);"},{stage:6,text:"    curr.next = new ListNode(sum % 10);"},{stage:6,text:"    curr = curr.next;"},{stage:7,text:"    if (p) {"},{stage:7,text:"      p = p.next;"},{stage:7,text:"    }"},{stage:8,text:"    if (q) {"},{stage:8,text:"      q = q.next;"},{stage:8,text:"    }"},{stage:3,text:"  }"},{stage:9,text:"  if (carry > 0) {"},{stage:9,text:"    curr.next = new ListNode(carry);"},{stage:9,text:"  }"},{stage:0,text:""},{stage:10,text:"  return dummyHead.next;"},{stage:0,text:"}"},{stage:0,text:""}]},mt={problemID:76,problemName:"Solve Merge Intervals",problemText:"Given an array of intervals where intervals[i] = [start-i, end-i], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.",testCases:[{id:1,name:"example 1",inherit:[],code:"const intervals = [[0, 5],[11, 15],[4, 6],[8, 9],[1, 2],[12, 16],[2, 4]];",evaluate:"merge(intervals);",expected:JSON.stringify([[0,6],[8,9],[11,16]])},{id:2,name:"example 2",inherit:[],code:"const intervals = [[1, 3],[2, 6],[8, 10],[15, 18]];",evaluate:"merge(intervals);",expected:JSON.stringify([[1,6],[8,10],[15,18]])},{id:3,name:"example 3",inherit:[],code:"const intervals = [[1, 4],[4, 5]];",evaluate:"merge(intervals);",expected:JSON.stringify([[1,5]])}],setupCode:"",lcid:56,source:["https://leetcode.com/problems/merge-intervals"],tags:[v,d,"Cruise"],solution:[{stage:0,text:""},{stage:0,text:"function merge(intervals) {"},{stage:1,text:"  intervals.sort((a, b) => a[0] - b[0]);"},{stage:1,text:"  const result = [];"},{stage:0,text:""},{stage:2,text:"  let currentInterval = intervals[0];"},{stage:0,text:""},{stage:3,text:"  for (let i = 0; i < intervals.length; i++) {"},{stage:4,text:"    const thisInterval = intervals[i];"},{stage:4,text:"    const nextInterval = intervals[i + 1];"},{stage:5,text:"    if (nextInterval && thisInterval[1] >= nextInterval[0]) {"},{stage:6,text:"      currentInterval = [currentInterval[0], nextInterval[1]];"},{stage:5,text:"    } else {"},{stage:7,text:"      result.push(currentInterval);"},{stage:7,text:"      currentInterval = nextInterval;"},{stage:5,text:"    }"},{stage:3,text:"  }"},{stage:8,text:"  return result;"},{stage:0,text:"}"},{stage:0,text:""}]},ft={problemID:77,problemName:"Best Time to Buy and Sell Stock",problemText:"You are given an array prices where `prices[i]` is the price of a given stock on the `i`th day.\n\n  You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n  \n  Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return `0`.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"maxProfit([7, 1, 5, 3, 6, 4]);",expected:5},{id:2,name:"example 2",inherit:[],code:"",evaluate:"maxProfit([7, 6, 4, 3, 1]);",expected:0}],setupCode:"",lcid:121,source:["https://leetcode.com/problems/best-time-to-buy-and-sell-stock"],tags:[v,d],solution:[{stage:0,text:""},{stage:0,text:"function maxProfit(prices) {"},{stage:1,text:"  let minprice = Infinity;"},{stage:1,text:"  let maxprofit = 0;"},{stage:0,text:""},{stage:2,text:"  for (let i = 0; i < prices.length; i++) {"},{stage:3,text:"    if (prices[i] < minprice) {"},{stage:4,text:"      minprice = prices[i];"},{stage:3,text:"    } else if (prices[i] - minprice > maxprofit) {"},{stage:5,text:"      maxprofit = prices[i] - minprice;"},{stage:3,text:"    }"},{stage:2,text:"  }"},{stage:0,text:""},{stage:6,text:"  return maxprofit;"},{stage:0,text:"}"},{stage:0,text:""}]},vt={problemID:78,problemName:"Product of Array Except Self",problemText:"Given an array nums of `n` integers where `n > 1`,  return an array output such that `output[i]` is equal to the product of all the elements of` nums` except `nums[i]`.\n\n  Example:\n  \n  Input:  `[1,2,3,4]`\n  Output: `[24,12,8,6]`\n  Constraint: It's guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer.\n  \n  Note: Please solve it **without** division and in O(n).",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"productExceptSelf([1, 2, 3, 4]);",expected:JSON.stringify([24,12,8,6])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"productExceptSelf([5, 8, 4, 3, 7]);",expected:JSON.stringify([672,420,840,1120,480])}],setupCode:"",lcid:238,source:["https://leetcode.com/problems/product-of-array-except-self"],tags:[v,d,"Facebook"],solution:[{stage:0,text:""},{stage:0,text:"function productExceptSelf(nums) {"},{stage:1,text:"  let length = nums.length;"},{stage:0,text:""},{stage:2,text:"  const leftProducts = [];"},{stage:2,text:"  const rightProducts = [];"},{stage:0,text:""},{stage:3,text:"  const answer = [];"},{stage:0,text:""},{stage:4,text:"  leftProducts[0] = 1;"},{stage:5,text:"  for (let i = 1; i < length; i++) {"},{stage:5,text:"    leftProducts[i] = nums[i - 1] * leftProducts[i - 1];"},{stage:5,text:"  }"},{stage:0,text:""},{stage:6,text:"  rightProducts[length - 1] = 1;"},{stage:7,text:"  for (let i = length - 2; i >= 0; i--) {"},{stage:7,text:"    rightProducts[i] = nums[i + 1] * rightProducts[i + 1];"},{stage:7,text:"  }"},{stage:0,text:""},{stage:8,text:"  for (let i = 0; i < length; i++) {"},{stage:8,text:"    answer[i] = leftProducts[i] * rightProducts[i];"},{stage:8,text:"  }"},{stage:0,text:""},{stage:9,text:"  return answer;"},{stage:0,text:"}"},{stage:0,text:""}]},wt={problemID:79,problemName:"Shortest Path in a Binary Matrix",problemText:"Given an `n x n` binary matrix `grid`, return the length of the shortest clear path in the matrix. If there is no clear path, return `-1`.\n\n  A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:\n  \n  All the visited cells of the path are 0.\n  All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\n  The length of a clear path is the number of visited cells of this path.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"shortestPathBinaryMatrix([[0, 1],[1, 0]]);",expected:2},{id:2,name:"example 2",inherit:[],code:"",evaluate:"shortestPathBinaryMatrix([\n        [0, 0, 0],\n        [1, 1, 0],\n        [1, 1, 0],\n      ]);",expected:4},{id:3,name:"example 3 - no path",inherit:[],code:"",evaluate:"shortestPathBinaryMatrix([\n        [1, 0, 0],\n        [1, 1, 0],\n        [1, 1, 0],\n      ]);",expected:-1}],setupCode:"",lcid:1091,source:["https://leetcode.com/problems/shortest-path-in-binary-matrix"],tags:[p,d],solution:[{stage:0,text:""},{stage:11,text:"const directions = ["},{stage:11,text:"  [-1, -1],"},{stage:11,text:"  [-1, 0],"},{stage:11,text:"  [-1, 1],"},{stage:11,text:"  [0, -1],"},{stage:11,text:"  [0, 1],"},{stage:11,text:"  [1, -1],"},{stage:11,text:"  [1, 0],"},{stage:11,text:"  [1, 1],"},{stage:11,text:"];"},{stage:0,text:""},{stage:0,text:"function shortestPathBinaryMatrix(grid) {"},{stage:1,text:"  if (grid[0][0] !== 0 || grid[grid.length - 1][grid[0].length - 1] !== 0) {"},{stage:2,text:"    return -1;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:3,text:"  const naiveQueue = [];"},{stage:3,text:"  grid[0][0] = 1;"},{stage:3,text:"  naiveQueue.push([0, 0]);"},{stage:0,text:""},{stage:4,text:"  while (naiveQueue.length) {"},{stage:5,text:"    const cell = naiveQueue.shift();"},{stage:6,text:"    const row = cell[0];"},{stage:6,text:"    const col = cell[1];"},{stage:7,text:"    const distance = grid[row][col];"},{stage:8,text:"    if (row === grid.length - 1 && col === grid[0].length - 1) {"},{stage:9,text:"      return distance;"},{stage:8,text:"    }"},{stage:0,text:""},{stage:10,text:"    for (let neighbour of getNeighbours(row, col, grid)) {"},{stage:18,text:"      const neighbourRow = neighbour[0];"},{stage:18,text:"      const neighbourCol = neighbour[1];"},{stage:19,text:"      naiveQueue.push([neighbourRow, neighbourCol]);"},{stage:19,text:"      grid[neighbourRow][neighbourCol] = distance + 1;"},{stage:10,text:"    }"},{stage:4,text:"  }"},{stage:0,text:""},{stage:20,text:"  return -1;"},{stage:0,text:"}"},{stage:0,text:""},{stage:11,text:"function getNeighbours(row, col, grid) {"},{stage:12,text:"  const neighbours = [];"},{stage:12,text:"  for (let i = 0; i < directions.length; i++) {"},{stage:13,text:"    const newRow = row + directions[i][0];"},{stage:13,text:"    const newCol = col + directions[i][1];"},{stage:14,text:"    if ("},{stage:14,text:"      newRow < 0 ||"},{stage:14,text:"      newCol < 0 ||"},{stage:14,text:"      newRow >= grid.length ||"},{stage:14,text:"      newCol >= grid[0].length ||"},{stage:14,text:"      grid[newRow][newCol] !== 0"},{stage:14,text:"    ) {"},{stage:15,text:"      continue;"},{stage:14,text:"    }"},{stage:16,text:"    neighbours.push([newRow, newCol]);"},{stage:12,text:"  }"},{stage:17,text:"  return neighbours;"},{stage:11,text:"}"},{stage:0,text:""}]},bt={problemID:80,problemName:"Solve Palindrome Linked List",problemText:"Given a singly linked list's `head` node, determine if it is a palindrome.",testCases:[{id:1,name:"example 1",inherit:[],code:"const ex1 = new ListNode(1);\n      ex1.next = new ListNode(2);",evaluate:"isPalindrome(ex1);",expected:!1},{id:2,name:"example 2",inherit:[],code:"const ex2 = new ListNode(1);\n      ex2.next = new ListNode(2);\n      ex2.next.next = new ListNode(2);\n      ex2.next.next.next = new ListNode(1);",evaluate:"isPalindrome(ex2);",expected:!0},{id:3,name:"example 3",inherit:[],code:"const ex3 = new ListNode(1);\n      ex3.next = new ListNode(2);\n      ex3.next.next = new ListNode(3);\n      ex3.next.next.next = new ListNode(1);\n      ex3.next.next.next.next = new ListNode(2);\n      ex3.next.next.next.next.next = new ListNode(3);",evaluate:"isPalindrome(ex3);",expected:!1},{id:4,name:"example 4",inherit:[],code:"const ex4 = new ListNode(1);\n      ex4.next = new ListNode(2);\n      ex4.next.next = new ListNode(3);\n      ex4.next.next.next = new ListNode(4);\n      ex4.next.next.next.next = new ListNode(3);\n      ex4.next.next.next.next.next = new ListNode(2);\n      ex4.next.next.next.next.next.next = new ListNode(1);",evaluate:"isPalindrome(ex4);",expected:!0},{id:5,name:"example 5",inherit:[],code:"const ex5 = new ListNode(1);\n      ex5.next = new ListNode(2);\n      ex5.next.next = new ListNode(3);\n      ex5.next.next.next = new ListNode(3);\n      ex5.next.next.next.next = new ListNode(2);\n      ex5.next.next.next.next.next = new ListNode(1);\n      ex5.next.next.next.next.next.next = new ListNode(4);",evaluate:"isPalindrome(ex5);",expected:!1},{id:6,name:"example 6",inherit:[],code:"const ex6 = new ListNode(5);",evaluate:"isPalindrome(ex6);",expected:!0}],setupCode:"\n  function ListNode(val) {\n    this.val = val;\n    this.next = null;\n  }\n  ",lcid:234,source:["https://leetcode.com/problems/palindrome-linked-list"],tags:[c,d],solution:[{stage:0,text:""},{stage:-1,text:"function ListNode(val) {"},{stage:-1,text:"  this.val = val;"},{stage:-1,text:"  this.next = null;"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function isPalindrome(head) {"},{stage:1,text:"  if (head === null) {"},{stage:1,text:"    return true;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:2,text:"  const firstHalfEnd = endOfFirstHalf(head);"},{stage:2,text:"  const secondHalfStart = reverseList(firstHalfEnd.next);"},{stage:0,text:""},{stage:14,text:"  let p1 = head;"},{stage:14,text:"  let p2 = secondHalfStart;"},{stage:14,text:"  let result = true;"},{stage:15,text:"  while (result && p2 !== null) {"},{stage:16,text:"    if (p1.val != p2.val) {"},{stage:16,text:"      result = false;"},{stage:16,text:"    }"},{stage:17,text:"    p1 = p1.next;"},{stage:17,text:"    p2 = p2.next;"},{stage:15,text:"  }"},{stage:0,text:""},{stage:18,text:"  firstHalfEnd.next = reverseList(secondHalfStart);"},{stage:19,text:"  return result;"},{stage:0,text:"}"},{stage:0,text:""},{stage:8,text:"function reverseList(head) {"},{stage:9,text:"  let prev = null;"},{stage:9,text:"  let curr = head;"},{stage:10,text:"  while (curr !== null) {"},{stage:11,text:"    let nextTemp = curr.next;"},{stage:11,text:"    curr.next = prev;"},{stage:12,text:"    prev = curr;"},{stage:12,text:"    curr = nextTemp;"},{stage:10,text:"  }"},{stage:13,text:"  return prev;"},{stage:8,text:"}"},{stage:0,text:""},{stage:3,text:"function endOfFirstHalf(head) {"},{stage:4,text:"  let fast = head;"},{stage:4,text:"  let slow = head;"},{stage:5,text:"  while (fast.next !== null && fast.next.next !== null) {"},{stage:6,text:"    fast = fast.next.next;"},{stage:6,text:"    slow = slow.next;"},{stage:5,text:"  }"},{stage:7,text:"  return slow;"},{stage:3,text:"}"},{stage:0,text:""}]},yt={problemID:81,problemName:"Verify Alien Dictionary",problemText:"In an alien language, surprisingly they also use english lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.\n\n  Given a sequence of `words` written in the alien language, and the `order` of the alphabet, return `true` if and only if the given `words` are sorted lexicographicaly in this alien language.",testCases:[{id:1,name:"example 1",inherit:[],code:"const words1 = ['hello', 'leetcode'];\n      const order1 = 'hlabcdefgijkmnopqrstuvwxyz';",evaluate:"isAlienSorted(words1, order1);",expected:!0},{id:2,name:"example 2",inherit:[],code:"const words2 = ['word', 'world', 'row'];\n        const order2 = 'worldabcefghijkmnpqstuvxyz';",evaluate:"isAlienSorted(words2, order2);",expected:!1},{id:3,name:"example 3",inherit:[],code:"const words3 = ['apple', 'app'];\n      const order3 = 'abcdefghijklmnopqrstuvwxyz';",evaluate:"isAlienSorted(words3, order3);",expected:!1}],setupCode:"",lcid:953,source:["https://leetcode.com/problems/verifying-an-alien-dictionary"],tags:[v,d,"Facebook"],solution:[{stage:0,text:""},{stage:0,text:"function isAlienSorted(words, order) {"},{stage:1,text:"  const index = {};"},{stage:1,text:"  for (let i = 0; i < order.length; i++) {"},{stage:2,text:"    index[order[i]] = i;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:3,text:"  for (let i = 0; i < words.length - 1; i++) {"},{stage:4,text:"    let word1 = words[i];"},{stage:4,text:"    let word2 = words[i + 1];"},{stage:0,text:""},{stage:5,text:"    let breakLoop = false;"},{stage:6,text:"    for (let k = 0; k < Math.min(word1.length, word2.length); k++) {"},{stage:7,text:"      if (word1[k] !== word2[k]) {"},{stage:8,text:"        if (index[word1[k]] > index[word2[k]]) {"},{stage:9,text:"          return false;"},{stage:8,text:"        }"},{stage:9,text:"        breakLoop = true;"},{stage:9,text:"        break;"},{stage:7,text:"      }"},{stage:6,text:"    }"},{stage:0,text:""},{stage:10,text:"    if (breakLoop) {"},{stage:10,text:"      continue;"},{stage:10,text:"    }"},{stage:0,text:""},{stage:11,text:"    if (word1.length > word2.length) {"},{stage:11,text:"      return false;"},{stage:11,text:"    }"},{stage:3,text:"  }"},{stage:0,text:""},{stage:12,text:"  return true;"},{stage:0,text:"}"},{stage:0,text:""}]},kt={problemID:82,problemName:"Find Length of Longest Substring",problemText:"Given a string `str`, find the length of the longest substring without repeating characters.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"lengthOfLongestSubstring('abcabcbb');",expected:3},{id:2,name:"example 2",inherit:[],code:"",evaluate:"lengthOfLongestSubstring('bbbbb');",expected:1},{id:3,name:"example 3",inherit:[],code:"",evaluate:"lengthOfLongestSubstring('pwwkew');",expected:3},{id:4,name:"example 4",inherit:[],code:"",evaluate:"lengthOfLongestSubstring('');",expected:0}],setupCode:"",lcid:3,source:["https://leetcode.com/problems/longest-substring-without-repeating-characters"],tags:[v,d],solution:[{stage:0,text:""},{stage:0,text:"function lengthOfLongestSubstring(str) {"},{stage:1,text:"  let answer = 0;"},{stage:1,text:"  let map = {};"},{stage:2,text:"  for (let j = 0, i = 0; j < str.length; j++) {"},{stage:3,text:"    const char = str[j];"},{stage:4,text:"    if (map[char]) {"},{stage:4,text:"      i = Math.max(map[char], i);"},{stage:4,text:"    }"},{stage:5,text:"    answer = Math.max(answer, j - i + 1);"},{stage:6,text:"    map[char] = j + 1;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:7,text:"  return answer;"},{stage:0,text:"}"},{stage:0,text:""}]},Nt={problemID:83,problemName:"Find the minimum number of Meeting Rooms needed.",problemText:"Given an array of meeting time `intervals` where `intervals[i] = [start-i, end-i]`, return the minimum number of conference rooms required.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"minMeetingRooms([\n        [0, 30],\n        [5, 10],\n        [15, 20],\n      ]);",expected:2},{id:2,name:"example 2",inherit:[],code:"",evaluate:"minMeetingRooms([\n        [7, 10],\n        [2, 4],\n      ]);",expected:1},{id:3,name:"example 3",inherit:[],code:"",evaluate:"minMeetingRooms([\n        [1, 10],\n        [2, 7],\n        [3, 19],\n        [8, 12],\n        [10, 20],\n        [11, 30],\n      ]);",expected:4}],setupCode:"",lcid:253,source:["https://leetcode.com/problems/meeting-rooms-ii"],tags:[v,d],solution:[{stage:0,text:""},{stage:0,text:"function minMeetingRooms(intervals) {"},{stage:1,text:"  if (!intervals.length) {"},{stage:1,text:"    return 0;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:2,text:"  const starts = [];"},{stage:2,text:"  const ends = [];"},{stage:0,text:""},{stage:3,text:"  for (let i = 0; i < intervals.length; i++) {"},{stage:4,text:"    starts[i] = intervals[i][0];"},{stage:4,text:"    ends[i] = intervals[i][1];"},{stage:3,text:"  }"},{stage:0,text:""},{stage:5,text:"  const numericalSort = (a, b) => {"},{stage:5,text:"    return a - b;"},{stage:5,text:"  };"},{stage:0,text:""},{stage:6,text:"  starts.sort(numericalSort);"},{stage:6,text:"  ends.sort(numericalSort);"},{stage:0,text:""},{stage:7,text:"  let startPointer = 0;"},{stage:7,text:"  let endPointer = 0;"},{stage:7,text:"  let usedRooms = 0;"},{stage:0,text:""},{stage:8,text:"  while (startPointer < intervals.length) {"},{stage:9,text:"    if (starts[startPointer] >= ends[endPointer]) {"},{stage:10,text:"      usedRooms -= 1;"},{stage:10,text:"      endPointer += 1;"},{stage:9,text:"    }"},{stage:0,text:""},{stage:11,text:"    usedRooms += 1;"},{stage:11,text:"    startPointer += 1;"},{stage:8,text:"  }"},{stage:0,text:""},{stage:12,text:"  return usedRooms;"},{stage:0,text:"}"},{stage:0,text:""}]},It={problemID:84,problemName:"Design a Metro System.",problemText:"Implement the *MetroSystem* class:\n\n**checkIn** (`id`: number, `stationName`: string, `t`: number) void\n  \n   - A customer with a card id equal to `id`, gets in the station `stationName` at time `t`.  A customer can only be checked into one place at a time.\n\n**checkOut** (`id`: number, `stationName`: string, `t`: number) void\n  \n   - A customer with a card id equal to `id`, gets out from the station `stationName` at time `t`.\n  \n**getAverageTime** (`startStation`: string, `endStation`: string) number\n  \n   - Returns the average time to travel between the `startStation` and the `endStation`.  The average time is computed from all the previous traveling from `startStation` to `endStation` that happened directly.  Call to **getAverageTime** is always valid.\n\nYou can assume all calls to **checkIn** and **checkOut** methods are consistent. If a customer gets in at time t<sub>1</sub> at some station, they get out at time t<sub>2</sub> with t<sub>2</sub> > t<sub>1</sub>. All events happen in chronological order.",testCases:[{id:1,name:"compiles",inherit:[],code:"const metroSystem = new MetroSystem();",evaluate:"Boolean(metroSystem);",expected:!0},{id:2,name:"correct output 1",inherit:[1],code:"metroSystem.checkIn(45, 'Leyton', 3);\n      metroSystem.checkIn(32, 'Paradise', 8);\n      metroSystem.checkIn(27, 'Leyton', 10);\n      metroSystem.checkOut(45, 'Waterloo', 15);\n      metroSystem.checkOut(27, 'Waterloo', 20);\n      metroSystem.checkOut(32, 'Cambridge', 22);",evaluate:"metroSystem.getAverageTime('Paradise', 'Cambridge');",expected:14},{id:3,name:"correct output 2",inherit:[1,2],code:"",evaluate:"metroSystem.getAverageTime('Leyton', 'Waterloo');",expected:11},{id:4,name:"correct output 3",inherit:[1,2],code:"metroSystem.checkIn(10, 'Leyton', 24);",evaluate:"metroSystem.getAverageTime('Leyton', 'Waterloo');",expected:11},{id:5,name:"correct output 4",inherit:[1,2,4],code:"metroSystem.checkOut(10, 'Waterloo', 38);",evaluate:"metroSystem.getAverageTime('Leyton', 'Waterloo');",expected:12}],setupCode:"",lcid:1396,source:["https://leetcode.com/problems/design-underground-system"],tags:["Design",d],solution:[{stage:0,text:""},{stage:0,text:"class MetroSystem {"},{stage:0,text:"  constructor() {"},{stage:1,text:"    this.inProgress = {};"},{stage:2,text:"    this.finished = {};"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  checkIn(id, stationName, t) {"},{stage:0,text:""},{stage:3,text:"    this.inProgress[id] = { stationName, t };"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  checkOut(id, stationName, t) {"},{stage:0,text:""},{stage:4,text:"    const checkInRecord = this.inProgress[id];"},{stage:4,text:"    delete this.inProgress[id];"},{stage:5,text:"    if (!this.finished[checkInRecord.stationName]) {"},{stage:6,text:"      this.finished[checkInRecord.stationName] = {};"},{stage:5,text:"    }"},{stage:7,text:"    if (!this.finished[checkInRecord.stationName][stationName]) {"},{stage:8,text:"      this.finished[checkInRecord.stationName][stationName] = { sum: 0, trips: 0 };"},{stage:7,text:"    }"},{stage:9,text:"    const route = this.finished[checkInRecord.stationName][stationName];"},{stage:9,text:"    route.sum += t - checkInRecord.t;"},{stage:9,text:"    route.trips++;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  getAverageTime(startStation, endStation) {"},{stage:0,text:""},{stage:10,text:"    const route = this.finished[startStation][endStation];"},{stage:11,text:"    return route.sum / route.trips;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},Ct={problemID:85,problemName:"Find the Maximal Square in a Grid.",problemText:"Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.",testCases:[{id:1,name:"example 1",inherit:[],code:"const matrix = [\n        ['1', '0', '1', '0', '0'],\n        ['1', '0', '1', '1', '1'],\n        ['1', '1', '1', '1', '1'],\n        ['1', '0', '0', '1', '0'],\n      ];",evaluate:"maximalSquare(matrix);",expected:4}],setupCode:"",lcid:221,source:["https://leetcode.com/problems/maximal-square"],tags:["Dynamic Programming",d,"Amazon"],solution:[{stage:0,text:""},{stage:0,text:"function maximalSquare(matrix) {"},{stage:1,text:"  let rows = matrix.length;"},{stage:1,text:"  let cols = rows > 0 ? matrix[0].length : 0;"},{stage:0,text:""},{stage:2,text:"  let dp = new Array(cols + 1).fill(0);"},{stage:3,text:"  let maxsqlen = 0;"},{stage:3,text:"  let prev = 0;"},{stage:0,text:""},{stage:4,text:"  for (let i = 1; i <= rows; i++) {"},{stage:5,text:"    for (let j = 1; j <= cols; j++) {"},{stage:6,text:"      let temp = dp[j];"},{stage:7,text:"      if (matrix[i - 1][j - 1] === '1') {"},{stage:8,text:"        dp[j] = Math.min(Math.min(dp[j - 1], prev), dp[j]) + 1;"},{stage:9,text:"        maxsqlen = Math.max(maxsqlen, dp[j]);"},{stage:7,text:"      } else {"},{stage:10,text:"        dp[j] = 0;"},{stage:7,text:"      }"},{stage:11,text:"      prev = temp;"},{stage:5,text:"    }"},{stage:4,text:"  }"},{stage:0,text:""},{stage:12,text:"  return maxsqlen * maxsqlen;"},{stage:0,text:"}"},{stage:0,text:""}]},_t={problemID:86,problemName:"Find Average of Subarrays",problemText:"Given an array, find the average of all contiguous subarrays of size \u2018k\u2019 in it.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_averages_of_subarrays(5, [1, 3, 2, 6, -1, 4, 1, 8, 2]);",expected:JSON.stringify([2.2,2.8,2.4,3.6,2.8])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/7D5NNZWQ8Wr"],tags:["Sliding Window",d],solution:[{stage:0,text:""},{stage:0,text:"function find_averages_of_subarrays(k, arr) {"},{stage:1,text:"  const result = [];"},{stage:-2,text:"  // sum of numbers in current window"},{stage:2,text:"  let windowSum = 0;"},{stage:-2,text:"  // window start index"},{stage:2,text:"  let windowStart = 0;"},{stage:3,text:"  for (let windowEnd = 0; windowEnd < arr.length; windowEnd++) {"},{stage:-4,text:"    // add next number to sum"},{stage:4,text:"    windowSum += arr[windowEnd];"},{stage:-5,text:"    // only when index of windowEnd reaches kth number do we begin pushing to result array"},{stage:5,text:"    if (windowEnd >= k - 1) {"},{stage:6,text:"      result.push(windowSum / k);"},{stage:-7,text:"      // subtract item at beginning of window from sum"},{stage:7,text:"      windowSum -= arr[windowStart];"},{stage:-7,text:"      // increment start of window so it no longer includes subtracted item"},{stage:7,text:"      windowStart += 1;"},{stage:5,text:"    }"},{stage:3,text:"  }"},{stage:0,text:""},{stage:8,text:"  return result;"},{stage:0,text:"}"},{stage:0,text:""}]},St={problemID:87,problemName:"Find maximum of subarrays.",problemText:"Given an array of positive numbers and a positive number \u2018k,\u2019 find the maximum sum of any contiguous subarray of size \u2018k\u2019.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"max_sub_array_of_size_k(3, [2, 1, 5, 1, 3, 2]);",expected:9},{id:2,name:"example 2",inherit:[],code:"",evaluate:"max_sub_array_of_size_k(2, [2, 3, 4, 1, 5]);",expected:7}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/JPKr0kqLGNP"],tags:["Sliding Window",d],solution:[{stage:0,text:""},{stage:0,text:"function max_sub_array_of_size_k(k, arr) {"},{stage:1,text:"  let maxSum = 0;"},{stage:1,text:"  let windowSum = 0;"},{stage:1,text:"  let windowStart = 0;"},{stage:0,text:""},{stage:2,text:"  for (let windowEnd = 0; windowEnd < arr.length; windowEnd++) {"},{stage:3,text:"    windowSum += arr[windowEnd];"},{stage:-4,text:'    // only when window is "k" elements or larger do we start comparing to max'},{stage:4,text:"    if (windowEnd >= k - 1) {"},{stage:5,text:"      maxSum = Math.max(maxSum, windowSum);"},{stage:-6,text:"      // window is currently at k elements"},{stage:-6,text:"      // in preparation for next iteration, subtract number at start of window from sum"},{stage:6,text:"      windowSum -= arr[windowStart];"},{stage:7,text:"      windowStart += 1;"},{stage:4,text:"    }"},{stage:2,text:"  }"},{stage:0,text:""},{stage:8,text:"  return maxSum;"},{stage:0,text:"}"},{stage:0,text:""}]},Lt={problemID:88,problemName:"Smallest Subarray given Sum.",problemText:"Given an array of positive numbers and a positive number \u2018S,\u2019 find the length of the smallest contiguous subarray whose sum is greater than or equal to \u2018S\u2019. Return 0 if no such subarray exists.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"smallest_subarray_with_given_sum(7, [2, 1, 5, 2, 3, 2]);",expected:2},{id:2,name:"example 2",inherit:[],code:"",evaluate:"smallest_subarray_with_given_sum(7, [2, 1, 5, 2, 8]);",expected:1},{id:3,name:"example 3",inherit:[],code:"",evaluate:"smallest_subarray_with_given_sum(8, [3, 4, 1, 1, 6]);",expected:3}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/7XMlMEQPnnQ"],tags:["Sliding Window",d],solution:[{stage:0,text:""},{stage:0,text:"function smallest_subarray_with_given_sum(s, arr) {"},{stage:1,text:"  let windowSum = 0;"},{stage:0,text:""},{stage:-1,text:"  // since we'll be using Math.min for comparison, initialize starting value at Infinity"},{stage:1,text:"  let minLength = Infinity;"},{stage:1,text:"  let windowStart = 0;"},{stage:0,text:""},{stage:2,text:"  for (let windowEnd = 0; windowEnd < arr.length; windowEnd++) {"},{stage:3,text:"    windowSum += arr[windowEnd];"},{stage:0,text:""},{stage:-4,text:"    // each time sum > s, we check to see if subarray is shortest"},{stage:-4,text:"    // sum might still be > s after subtracting item at windowStart, so use a loop"},{stage:4,text:"    while (windowSum >= s) {"},{stage:5,text:"      minLength = Math.min(minLength, windowEnd - windowStart + 1);"},{stage:6,text:"      windowSum -= arr[windowStart];"},{stage:6,text:"      windowStart += 1;"},{stage:4,text:"    }"},{stage:2,text:"  }"},{stage:0,text:""},{stage:-7,text:"  // a value of Infinity means we did not find a substring with sum > s"},{stage:7,text:"  if (minLength === Infinity) {"},{stage:7,text:"    return 0;"},{stage:7,text:"  }"},{stage:0,text:""},{stage:8,text:"  return minLength;"},{stage:0,text:"}"},{stage:0,text:""}]},Tt={problemID:89,problemName:"Longest Substring K Distinct Characters",problemText:"Given a string, find the length of the longest substring in it with no more than K distinct characters.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"longest_substring_with_k_distinct('araaci', 2);",expected:4},{id:2,name:"example 2",inherit:[],code:"",evaluate:"longest_substring_with_k_distinct('araaci', 1);",expected:2},{id:3,name:"example 3",inherit:[],code:"",evaluate:"longest_substring_with_k_distinct('cbbebi', 3);",expected:5}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/YQQwQMWLx80"],tags:["Sliding Window",d],solution:[{stage:0,text:""},{stage:0,text:"function longest_substring_with_k_distinct(str, k) {"},{stage:1,text:"  let windowStart = 0;"},{stage:1,text:"  let longestSubstring = 0;"},{stage:-1,text:"  // characters (key) by count (value)"},{stage:1,text:"  let charFrequency = {};"},{stage:1,text:"  let distinct = 0;"},{stage:0,text:""},{stage:2,text:"  for (let windowEnd = 0; windowEnd < str.length; windowEnd++) {"},{stage:3,text:"    const rightChar = str[windowEnd];"},{stage:0,text:""},{stage:-4,text:"    // check to see if rightChar is a key in charFrequency"},{stage:4,text:"    if (!(rightChar in charFrequency)) {"},{stage:5,text:"      charFrequency[rightChar] = 0;"},{stage:-6,text:"      // since it is a new character, increment count of distinct characters"},{stage:6,text:"      distinct++;"},{stage:4,text:"    }"},{stage:7,text:"    charFrequency[rightChar] += 1;"},{stage:0,text:""},{stage:-8,text:"    // if we've exceeded distinct character limit, remove until within limit"},{stage:8,text:"    while (distinct > k) {"},{stage:9,text:"      const leftChar = str[windowStart];"},{stage:9,text:"      charFrequency[leftChar] -= 1;"},{stage:10,text:"      if (charFrequency[leftChar] === 0) {"},{stage:-11,text:"        // remove character entirely from frequency hashMap (since we use for ... in above to check membership)"},{stage:11,text:"        delete charFrequency[leftChar];"},{stage:11,text:"        distinct--;"},{stage:10,text:"      }"},{stage:0,text:""},{stage:12,text:"      windowStart++;"},{stage:8,text:"    }"},{stage:0,text:""},{stage:13,text:"    longestSubstring = Math.max(longestSubstring, windowEnd - windowStart + 1);"},{stage:2,text:"  }"},{stage:0,text:""},{stage:14,text:"  return longestSubstring;"},{stage:0,text:"}"},{stage:0,text:""}]},Et={problemID:90,problemName:"Fruits into Basket",problemText:"Given an array of characters where each character represents a fruit tree, you are given two baskets, and your goal is to put maximum number of fruits in each basket. The only restriction is that each basket can have only one type of fruit.\n\n  You can start with any tree, but you can\u2019t skip a tree once you have started. You will pick one fruit from each tree until you cannot, i.e., you will stop when you have to pick from a third fruit type.\n  \n  Write a function to return the maximum number of fruits in both baskets.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"fruits_into_baskets(['A', 'B', 'C', 'A', 'C']);",expected:3},{id:2,name:"example 2",inherit:[],code:"",evaluate:"fruits_into_baskets(['A', 'B', 'C', 'B', 'B', 'C']);",expected:5}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/Bn2KLlOR0lQ"],tags:["Sliding Window",d],solution:[{stage:0,text:""},{stage:0,text:"function fruits_into_baskets(fruits) {"},{stage:1,text:"  let windowStart = 0;"},{stage:1,text:"  let maxLength = 0;"},{stage:2,text:"  let fruitFrequency = {};"},{stage:2,text:"  let distinct = 0;"},{stage:0,text:""},{stage:3,text:"  for (let windowEnd = 0; windowEnd < fruits.length; windowEnd++) {"},{stage:4,text:"    const rightFruit = fruits[windowEnd];"},{stage:0,text:""},{stage:-5,text:"    // the fruitFrequency object keeps track of how many fruits are in each basket"},{stage:-5,text:"    // each key entry in the object is a basket of that type of fruit"},{stage:5,text:"    if (!(rightFruit in fruitFrequency)) {"},{stage:5,text:"      fruitFrequency[rightFruit] = 0;"},{stage:5,text:"      distinct++;"},{stage:5,text:"    }"},{stage:6,text:"    fruitFrequency[rightFruit] += 1;"},{stage:0,text:""},{stage:-7,text:"    // only two keys in the obj are allowed.  If more than that, iterate"},{stage:-7,text:"    // fruits from windowStart until there are only 2 keys left."},{stage:7,text:"    while (distinct > 2) {"},{stage:8,text:"      const leftFruit = fruits[windowStart];"},{stage:8,text:"      fruitFrequency[leftFruit] -= 1;"},{stage:9,text:"      if (fruitFrequency[leftFruit] === 0) {"},{stage:9,text:"        delete fruitFrequency[leftFruit];"},{stage:9,text:"        distinct--;"},{stage:9,text:"      }"},{stage:10,text:"      windowStart += 1;"},{stage:7,text:"    }"},{stage:0,text:""},{stage:-11,text:"    // no need to calculate fruits in basket, the length of the window tells us"},{stage:11,text:"    maxLength = Math.max(maxLength, windowEnd - windowStart + 1);"},{stage:3,text:"  }"},{stage:0,text:""},{stage:12,text:"  return maxLength;"},{stage:0,text:"}"},{stage:0,text:""}]},Ot={problemID:91,problemName:"No Repeat Substring",problemText:"Given a string, find the length of the longest substring, which has no repeating characters.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"non_repeat_substring('aabccbb');",expected:3},{id:2,name:"example 2",inherit:[],code:"",evaluate:"non_repeat_substring('abbbb');",expected:2},{id:3,name:"example 3",inherit:[],code:"",evaluate:"non_repeat_substring('abccde');",expected:3}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/YMzBx1gE5EO"],tags:["Sliding Window",d],solution:[{stage:0,text:""},{stage:0,text:"function non_repeat_substring(str) {"},{stage:1,text:"  let windowStart = 0;"},{stage:1,text:"  let maxLength = 0;"},{stage:0,text:""},{stage:-2,text:"  // hash map to keep track of the index the character was last found"},{stage:2,text:"  let charIndexMap = {};"},{stage:0,text:""},{stage:-3,text:"  // sliding window approach - use two pointers"},{stage:3,text:"  for (let windowEnd = 0; windowEnd < str.length; windowEnd++) {"},{stage:0,text:""},{stage:-4,text:"    // character on right side of window"},{stage:4,text:"    const rightChar = str[windowEnd];"},{stage:0,text:""},{stage:5,text:"    // if the character already exists in hash map"},{stage:5,text:"    if (rightChar in charIndexMap) {"},{stage:0,text:""},{stage:-6,text:"      // move the starting point (windowStart) to character after the last found index of the duplicate character"},{stage:6,text:"      windowStart = Math.max(windowStart, charIndexMap[rightChar] + 1);"},{stage:5,text:"    }"},{stage:0,text:""},{stage:-7,text:"    // update the last found index of the character"},{stage:7,text:"    charIndexMap[rightChar] = windowEnd;"},{stage:0,text:""},{stage:-8,text:"    // recompute max length, add one because a window of (for example) index 0 to 0 still contains one character (at index 0)"},{stage:8,text:"    maxLength = Math.max(maxLength, windowEnd - windowStart + 1);"},{stage:3,text:"  }"},{stage:0,text:""},{stage:9,text:"  return maxLength;"},{stage:0,text:"}"},{stage:0,text:""}]},qt={problemID:92,problemName:"Longest Substring Same Letter",problemText:"Given a string with lowercase letters only, if you are allowed to replace no more than \u2018k\u2019 individual characters in the string with any letter, find the length of the longest substring having the same letter after replacement.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"length_of_longest_substring('aabccbb', 2);",expected:5},{id:2,name:"example 2",inherit:[],code:"",evaluate:"length_of_longest_substring('abbcb', 1);",expected:4},{id:3,name:"example 3",inherit:[],code:"",evaluate:"length_of_longest_substring('abccde', 1);",expected:3}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/R8DVgjq78yR"],tags:["Sliding Window",d],solution:[{stage:0,text:""},{stage:0,text:"function length_of_longest_substring(str, k) {"},{stage:1,text:"  let windowStart = 0;"},{stage:1,text:"  let maxLength = 0;"},{stage:2,text:"  let maxRepeatLetterCount = 0;"},{stage:0,text:""},{stage:-2,text:"  // object is key (character) value (count)"},{stage:2,text:"  let frequencyMap = {};"},{stage:0,text:""},{stage:3,text:"  for (let windowEnd = 0; windowEnd < str.length; windowEnd++) {"},{stage:4,text:"    const rightChar = str[windowEnd];"},{stage:5,text:"    if (!(rightChar in frequencyMap)) {"},{stage:5,text:"      frequencyMap[rightChar] = 0;"},{stage:5,text:"    }"},{stage:6,text:"    frequencyMap[rightChar] += 1;"},{stage:0,text:""},{stage:-7,text:"    // we only care to find the max count of a single character within the window"},{stage:-7,text:"    // other characters around it will be individually replaced"},{stage:7,text:"    maxRepeatLetterCount = Math.max(maxRepeatLetterCount, frequencyMap[rightChar]);"},{stage:0,text:""},{stage:-8,text:"    // if the length of the window, minus count of the most frequent characters"},{stage:-8,text:"    // is greater than allowed replacement characters (k)"},{stage:-8,text:"    // remove characters from the start until condition is met"},{stage:8,text:"    if (windowEnd - windowStart + 1 - maxRepeatLetterCount > k) {"},{stage:9,text:"      let leftChar = str[windowStart];"},{stage:9,text:"      frequencyMap[leftChar] -= 1;"},{stage:9,text:"      windowStart += 1;"},{stage:8,text:"    }"},{stage:0,text:""},{stage:10,text:"    maxLength = Math.max(maxLength, windowEnd - windowStart + 1);"},{stage:3,text:"  }"},{stage:0,text:""},{stage:11,text:"  return maxLength;"},{stage:0,text:"}"},{stage:0,text:""}]},Dt={problemID:93,problemName:"Longest Binary Subarray After Replacement",problemText:"Given an array containing 0s and 1s, if you are allowed to replace no more than \u2018k\u2019 0s with 1s, find the length of the longest contiguous subarray having all 1s.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"length_of_longest_substring([0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1], 2);",expected:6},{id:2,name:"example 2",inherit:[],code:"",evaluate:"length_of_longest_substring([0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1], 3);",expected:9}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/B6VypRxPolJ"],tags:["Sliding Window",d],solution:[{stage:0,text:""},{stage:0,text:"function length_of_longest_substring(arr, k) {"},{stage:1,text:"  let windowStart = 0;"},{stage:1,text:"  let maxLength = 0;"},{stage:1,text:"  let maxOnesCount = 0;"},{stage:0,text:""},{stage:2,text:"  for (let windowEnd = 0; windowEnd < arr.length; windowEnd++) {"},{stage:0,text:""},{stage:0,text:"    // keep track of count of 1's only"},{stage:3,text:"    if (arr[windowEnd] === 1) {"},{stage:4,text:"      maxOnesCount += 1;"},{stage:3,text:"    }"},{stage:0,text:""},{stage:0,text:"    // if the length of the window, minus the count of ones"},{stage:0,text:"    // is greater than max allowed number of replacements"},{stage:0,text:"    // remove characters from beginning of substring"},{stage:0,text:"    // until condition is met"},{stage:5,text:"    if (windowEnd - windowStart + 1 - maxOnesCount > k) {"},{stage:6,text:"      if (arr[windowStart] === 1) {"},{stage:7,text:"        maxOnesCount -= 1;"},{stage:6,text:"      }"},{stage:7,text:"      windowStart += 1;"},{stage:5,text:"    }"},{stage:0,text:""},{stage:8,text:"    maxLength = Math.max(maxLength, windowEnd - windowStart + 1);"},{stage:2,text:"  }"},{stage:0,text:""},{stage:9,text:"  return maxLength;"},{stage:0,text:"}"},{stage:0,text:""}]},Mt={problemID:94,problemName:"Permutation in a String",problemText:"Given a string and a pattern, find out if the string contains any permutation of the pattern.\n\nPermutation is defined as the re-arranging of the characters of the string. For example, \u201cabc\u201d has the following six permutations:\n  \n   - abc\n   - acb\n   - bac\n   - bca\n   - cab\n   - cba\n  \nIf a string has \u2018n\u2019 distinct characters, it will have n!n! permutations.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_permutation('oidbcaf', 'abc');",expected:!0},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_permutation('odicf', 'dc');",expected:!1},{id:3,name:"example 3",inherit:[],code:"",evaluate:"find_permutation('bcdxabcdy', 'bcdyabcdx');",expected:!0},{id:4,name:"example 4",inherit:[],code:"",evaluate:"find_permutation('aaacb', 'abc');",expected:!0}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/N0o9QnPLKNv"],tags:["Sliding Window",d],solution:[{stage:0,text:""},{stage:0,text:"function find_permutation(str, pattern) {"},{stage:1,text:"  let windowStart = 0;"},{stage:1,text:"  let matched = 0;"},{stage:1,text:"  let charFrequency = {};"},{stage:0,text:""},{stage:2,text:"  for (let i = 0; i < pattern.length; i++) {"},{stage:3,text:"    const chr = pattern[i];"},{stage:4,text:"    if (!(chr in charFrequency)) {"},{stage:5,text:"      charFrequency[chr] = 0;"},{stage:4,text:"    }"},{stage:5,text:"    charFrequency[chr] += 1;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:6,text:"  for (let windowEnd = 0; windowEnd < str.length; windowEnd++) {"},{stage:7,text:"    const rightChar = str[windowEnd];"},{stage:8,text:"    if (rightChar in charFrequency) {"},{stage:9,text:"      charFrequency[rightChar] -= 1;"},{stage:10,text:"      if (charFrequency[rightChar] === 0) {"},{stage:10,text:"        matched += 1;"},{stage:10,text:"      }"},{stage:8,text:"    }"},{stage:0,text:""},{stage:11,text:"    if (matched === Object.keys(charFrequency).length) {"},{stage:11,text:"      return true;"},{stage:11,text:"    }"},{stage:0,text:""},{stage:12,text:"    if (windowEnd >= pattern.length - 1) {"},{stage:13,text:"      let leftChar = str[windowStart];"},{stage:13,text:"      windowStart += 1;"},{stage:14,text:"      if (leftChar in charFrequency) {"},{stage:15,text:"        if (charFrequency[leftChar] === 0) {"},{stage:16,text:"          matched -= 1;"},{stage:15,text:"        }"},{stage:17,text:"        charFrequency[leftChar] += 1;"},{stage:14,text:"      }"},{stage:12,text:"    }"},{stage:6,text:"  }"},{stage:0,text:""},{stage:18,text:"  return false;"},{stage:0,text:"}"},{stage:0,text:""}]},jt={problemID:95,problemName:"String Anagrams",problemText:"Given a string and a pattern, find all anagrams of the pattern in the given string.\n\nAnagram is actually a Permutation of a string. For example, \u201cabc\u201d has the following six anagrams:\n  \n   - abc\n   - acb\n   - bac\n   - bca\n   - cab\n   - cba\n  \nWrite a function to return a list of starting indices of the anagrams of the pattern in the given string.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_string_anagrams('ppqp', 'pq');",expected:JSON.stringify([1,2])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_string_anagrams('abbcabc', 'abc');",expected:JSON.stringify([2,3,4])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/xl2g3vxrMq3"],tags:["Sliding Window",d],solution:[{stage:0,text:""},{stage:0,text:"function find_string_anagrams(str, pattern) {"},{stage:1,text:"  let windowStart = 0;"},{stage:1,text:"  let matched = 0;"},{stage:1,text:"  let charFrequency = {};"},{stage:0,text:""},{stage:2,text:"  for (let i = 0; i < pattern.length; i++) {"},{stage:3,text:"    const chr = pattern[i];"},{stage:4,text:"    if (!(chr in charFrequency)) {"},{stage:5,text:"      charFrequency[chr] = 0;"},{stage:4,text:"    }"},{stage:6,text:"    charFrequency[chr] += 1;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:7,text:"  const resultIndices = [];"},{stage:0,text:""},{stage:8,text:"  for (let windowEnd = 0; windowEnd < str.length; windowEnd++) {"},{stage:9,text:"    const rightChar = str[windowEnd];"},{stage:10,text:"    if (rightChar in charFrequency) {"},{stage:11,text:"      charFrequency[rightChar] -= 1;"},{stage:12,text:"      if (charFrequency[rightChar] === 0) {"},{stage:12,text:"        matched += 1;"},{stage:12,text:"      }"},{stage:10,text:"    }"},{stage:0,text:""},{stage:13,text:"    if (matched === Object.keys(charFrequency).length) {"},{stage:14,text:"      resultIndices.push(windowStart);"},{stage:13,text:"    }"},{stage:0,text:""},{stage:15,text:"    if (windowEnd >= pattern.length - 1) {"},{stage:16,text:"      let leftChar = str[windowStart];"},{stage:16,text:"      windowStart += 1;"},{stage:17,text:"      if (leftChar in charFrequency) {"},{stage:18,text:"        if (charFrequency[leftChar] === 0) {"},{stage:19,text:"          matched -= 1;"},{stage:18,text:"        }"},{stage:19,text:"        charFrequency[leftChar] += 1;"},{stage:17,text:"      }"},{stage:15,text:"    }"},{stage:8,text:"  }"},{stage:0,text:""},{stage:20,text:"  return resultIndices;"},{stage:0,text:"}"},{stage:0,text:""}]},Rt={1:C,2:_,3:X,4:Z,5:$,6:ee,7:te,8:ae,9:ne,10:se,11:re,12:ie,13:oe,14:le,15:ge,16:xe,17:de,18:ce,19:ue,20:he,21:pe,22:me,23:fe,24:ve,25:we,26:be,27:ye,28:ke,29:Ne,30:Ie,31:Ce,32:_e,33:Se,34:Le,35:Te,36:Ee,37:Oe,38:qe,39:De,40:Me,41:je,42:Re,43:He,44:Pe,45:Be,46:Ae,47:Je,48:Ge,49:Fe,50:We,51:Ke,52:ze,53:Xe,54:Ze,55:$e,56:Ve,57:Ye,58:Ue,59:Qe,60:et,61:tt,62:at,63:nt,64:st,65:rt,66:it,67:ot,68:lt,69:gt,70:xt,71:dt,72:ct,73:ut,74:ht,75:pt,76:mt,77:ft,78:vt,79:wt,80:bt,81:yt,82:kt,83:Nt,84:It,85:Ct,86:_t,87:St,88:Lt,89:Tt,90:Et,91:Ot,92:qt,93:Dt,94:Mt,95:jt,96:{problemID:96,problemName:"Smallest Window Containing Substring",problemText:"Given a string and a pattern, find the smallest substring in the given string which has all the characters of the given pattern.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_substring('aabdec', 'abc');",expected:"abdec"},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_substring('abdbca', 'abc');",expected:"bca"},{id:3,name:"example 3",inherit:[],code:"",evaluate:"find_substring('adcad', 'abc');",expected:""}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/xoyL4q6ApNE"],tags:["Sliding Window",d],solution:[{stage:0,text:""},{stage:0,text:"function find_substring(str, pattern) {"},{stage:1,text:"  let windowStart = 0;"},{stage:1,text:"  let matched = 0;"},{stage:1,text:"  let substrStart = 0;"},{stage:2,text:"  let minLength = str.length + 1;"},{stage:2,text:"  let charFrequency = {};"},{stage:0,text:""},{stage:3,text:"  for (let i = 0; i < pattern.length; i++) {"},{stage:4,text:"    const chr = pattern[i];"},{stage:5,text:"    if (!(chr in charFrequency)) {"},{stage:6,text:"      charFrequency[chr] = 0;"},{stage:5,text:"    }"},{stage:6,text:"    charFrequency[chr] += 1;"},{stage:3,text:"  }"},{stage:0,text:""},{stage:7,text:"  for (let windowEnd = 0; windowEnd < str.length; windowEnd++) {"},{stage:8,text:"    const rightChar = str[windowEnd];"},{stage:9,text:"    if (rightChar in charFrequency) {"},{stage:10,text:"      charFrequency[rightChar] -= 1;"},{stage:11,text:"      if (charFrequency[rightChar] >= 0) {"},{stage:11,text:"        matched += 1;"},{stage:11,text:"      }"},{stage:9,text:"    }"},{stage:0,text:""},{stage:12,text:"    while (matched === pattern.length) {"},{stage:13,text:"      if (minLength > windowEnd - windowStart + 1) {"},{stage:14,text:"        minLength = windowEnd - windowStart + 1;"},{stage:14,text:"        substrStart = windowStart;"},{stage:13,text:"      }"},{stage:0,text:""},{stage:15,text:"      const leftChar = str[windowStart];"},{stage:15,text:"      windowStart += 1;"},{stage:0,text:""},{stage:16,text:"      if (leftChar in charFrequency) {"},{stage:17,text:"        if (charFrequency[leftChar] === 0) {"},{stage:17,text:"          matched -= 1;"},{stage:17,text:"        }"},{stage:18,text:"        charFrequency[leftChar] += 1;"},{stage:16,text:"      }"},{stage:12,text:"    }"},{stage:7,text:"  }"},{stage:0,text:""},{stage:19,text:"  if (minLength > str.length) {"},{stage:19,text:'    return "";'},{stage:19,text:"  }"},{stage:0,text:""},{stage:20,text:"  return str.substring(substrStart, substrStart + minLength);"},{stage:0,text:"}"},{stage:0,text:""}]},97:{problemID:97,problemName:"Words Concatenation",problemText:"Given a string and a list of words, find all the starting indices of substrings in the given string that are a concatenation of all the given words exactly once without any overlapping of words. It is given that all words are of the same length.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_word_concatenation('catfoxcat', ['cat', 'fox']);",expected:JSON.stringify([0,3])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_word_concatenation('catcatfoxfox', ['cat', 'fox']);",expected:JSON.stringify([3])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/N8nMBvDQJ0m"],tags:["Sliding Window",d],solution:[{stage:0,text:""},{stage:0,text:"function find_word_concatenation(str, words) {"},{stage:1,text:"  if (words.length === 0 || words[0].length === 0) {"},{stage:1,text:"    return [];"},{stage:1,text:"  }"},{stage:0,text:""},{stage:2,text:"  const wordFrequency = {};"},{stage:0,text:""},{stage:3,text:"  words.forEach(word => {"},{stage:4,text:"    if (!(word in wordFrequency)) {"},{stage:5,text:"      wordFrequency[word] = 0;"},{stage:4,text:"    }"},{stage:5,text:"    wordFrequency[word] += 1;"},{stage:3,text:"  });"},{stage:0,text:""},{stage:6,text:"  const resultIndices = [];"},{stage:6,text:"  const wordsCount = words.length;"},{stage:6,text:"  const wordLength = words[0].length;"},{stage:0,text:""},{stage:7,text:"  for (let i = 0; i < str.length - wordsCount * wordLength + 1; i++) {"},{stage:8,text:"    const wordsSeen = {};"},{stage:9,text:"    for (let j = 0; j < wordsCount; j++) {"},{stage:10,text:"      let next_word_index = i + j * wordLength;"},{stage:11,text:"      let word = str.substring(next_word_index, next_word_index + wordLength);"},{stage:12,text:"      if (!(word in wordFrequency)) {"},{stage:12,text:"        break;"},{stage:12,text:"      }"},{stage:0,text:""},{stage:13,text:"      if (!(word in wordsSeen)) {"},{stage:13,text:"        wordsSeen[word] = 0;"},{stage:13,text:"      }"},{stage:14,text:"      wordsSeen[word] += 1;"},{stage:0,text:""},{stage:15,text:"      if (wordsSeen[word] > (wordFrequency[word] || 0)) {"},{stage:15,text:"        break;"},{stage:15,text:"      }"},{stage:0,text:""},{stage:16,text:"      if (j + 1 === wordsCount) {"},{stage:16,text:"        resultIndices.push(i);"},{stage:16,text:"      }"},{stage:9,text:"    }"},{stage:7,text:"  }"},{stage:0,text:""},{stage:17,text:"  return resultIndices;"},{stage:0,text:"}"},{stage:0,text:""}]},98:{problemID:98,problemName:"Use Bitwise XOR",problemText:"In a non-empty array of integers, every number appears twice except for one, find that single number.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_single_number([1, 4, 2, 1, 3, 2, 3]);",expected:4},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_single_number([7, 9, 7]);",expected:9}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/gk20xz4VwpG"],tags:["Bitwise",d],solution:[{stage:0,text:""},{stage:0,text:"function find_single_number(arr) {"},{stage:1,text:"  let num = 0;"},{stage:2,text:"  for (let i = 0; i < arr.length; i++) {"},{stage:3,text:"    num ^= arr[i];"},{stage:2,text:"  }"},{stage:0,text:""},{stage:4,text:"  return num;"},{stage:0,text:"}"},{stage:0,text:""}]},99:{problemID:99,problemName:"Implement Cyclic Sort",problemText:"We are given an array containing \u2018n\u2019 objects. Each object, when created, was assigned a unique number from 1 to \u2018n\u2019 based on their creation sequence. This means that the object with sequence number \u20183\u2019 was created just before the object with sequence number \u20184\u2019.\n\nWrite a function to sort the objects in-place on their creation sequence number in O(n)O(n) and without any extra space. For simplicity, let\u2019s assume we are passed an integer array containing only the sequence numbers, though each number is actually an object.\n",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"cyclic_sort([3, 1, 5, 4, 2]);",expected:JSON.stringify([1,2,3,4,5])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"cyclic_sort([2, 6, 4, 3, 1, 5]);",expected:JSON.stringify([1,2,3,4,5,6])},{id:3,name:"example 3",inherit:[],code:"",evaluate:"cyclic_sort([1, 5, 6, 4, 3, 2]);",expected:JSON.stringify([1,2,3,4,5,6])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/B8qXVqVwDKY"],tags:["Cyclic Sort",d],solution:[{stage:0,text:""},{stage:0,text:"function cyclic_sort(nums) {"},{stage:0,text:""},{stage:1,text:"  let i = 0;"},{stage:2,text:"  while (i < nums.length) {"},{stage:3,text:"    const j = nums[i] - 1;"},{stage:4,text:"    if (nums[i] !== nums[j]) {"},{stage:5,text:"      [nums[i], nums[j]] = [nums[j], nums[i]];"},{stage:4,text:"    } else {"},{stage:6,text:"      i += 1;"},{stage:4,text:"    }"},{stage:2,text:"  }"},{stage:0,text:""},{stage:7,text:"  return nums;"},{stage:0,text:"}"},{stage:0,text:""}]},100:{problemID:100,problemName:"Find Missing Number",problemText:"We are given an array containing \u2018n\u2019 distinct numbers taken from the range 0 to \u2018n\u2019. Since the array has only \u2018n\u2019 numbers out of the total \u2018n+1\u2019 numbers, find the missing number.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_missing_number([4, 0, 3, 1]);",expected:2},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_missing_number([8, 3, 5, 2, 4, 6, 0, 1]);",expected:7}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/JPnp17NYXE9"],tags:["Cyclic Sort",d],solution:[{stage:0,text:""},{stage:0,text:"function find_missing_number(nums) {"},{stage:1,text:"  let i = 0;"},{stage:1,text:"  const n = nums.length;"},{stage:0,text:""},{stage:2,text:"  while (i < n) {"},{stage:3,text:"    let j = nums[i];"},{stage:4,text:"    if (nums[i] < n && nums[i] !== nums[j]) {"},{stage:5,text:"      [nums[i], nums[j]] = [nums[j], nums[i]];"},{stage:4,text:"    } else {"},{stage:5,text:"      i += 1;"},{stage:4,text:"    }"},{stage:2,text:"  }"},{stage:0,text:""},{stage:6,text:"  for (i = 0; i < n; i++) {"},{stage:7,text:"    if (nums[i] !== i) {"},{stage:7,text:"      return i;"},{stage:7,text:"    }"},{stage:6,text:"  }"},{stage:0,text:""},{stage:8,text:"  return n;"},{stage:0,text:"}"},{stage:0,text:""}]},101:{problemID:101,problemName:"Find All Missing Numbers",problemText:"We are given an unsorted array containing numbers taken from the range 1 to \u2018n\u2019. The array can have duplicates, which means some numbers will be missing. Find all those missing numbers.  Return missing numbers as an array (in ascending order).",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_missing_numbers([2, 3, 1, 8, 2, 3, 5, 1]);",expected:JSON.stringify([4,6,7])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_missing_numbers([2, 4, 1, 2]);",expected:JSON.stringify([3])},{id:3,name:"example 3",inherit:[],code:"",evaluate:"find_missing_numbers([2, 3, 2, 1]);",expected:JSON.stringify([4])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/Y52qNM0ljWK"],tags:[d,"Cyclic Sort"],solution:[{stage:0,text:""},{stage:0,text:"function find_missing_numbers(nums) {"},{stage:1,text:"  let i = 0;"},{stage:1,text:"  while (i < nums.length) {"},{stage:2,text:"    const j = nums[i] - 1;"},{stage:3,text:"    if (nums[i] !== nums[j]) {"},{stage:4,text:"      [nums[i], nums[j]] = [nums[j], nums[i]];"},{stage:3,text:"    } else {"},{stage:4,text:"      i += 1;"},{stage:3,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:5,text:"  const missingNumbers = [];"},{stage:6,text:"  for (i = 0; i < nums.length; i++) {"},{stage:7,text:"    if (nums[i] !== i + 1) {"},{stage:8,text:"      missingNumbers.push(i + 1);"},{stage:7,text:"    }"},{stage:6,text:"  }"},{stage:0,text:""},{stage:8,text:"  return missingNumbers;"},{stage:0,text:"}"},{stage:0,text:""}]},102:{problemID:102,problemName:"Find Duplicate Number",problemText:"We are given an unsorted array containing \u2018n+1\u2019 numbers taken from the range 1 to \u2018n\u2019. The array has only one duplicate but it can be repeated multiple times. Find that duplicate number without using any extra space. You are, however, allowed to modify the input array.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_duplicate([1, 4, 4, 3, 2]);",expected:4},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_duplicate([2, 1, 3, 3, 5, 4]);",expected:3},{id:3,name:"example 3",inherit:[],code:"",evaluate:"find_duplicate([2, 4, 1, 4, 4]);",expected:4}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/3wEkKy6Pr9A"],tags:["Cyclic Sort",d],solution:[{stage:0,text:""},{stage:0,text:"function find_duplicate(nums) {"},{stage:1,text:"  let i = 0;"},{stage:0,text:""},{stage:1,text:"  while (i < nums.length) {"},{stage:2,text:"    if (nums[i] !== i + 1) {"},{stage:3,text:"      let j = nums[i] - 1;"},{stage:4,text:"      if (nums[i] !== nums[j]) {"},{stage:5,text:"        [nums[i], nums[j]] = [nums[j], nums[i]];"},{stage:4,text:"      } else {"},{stage:6,text:"        return nums[i];"},{stage:4,text:"      }"},{stage:2,text:"    } else {"},{stage:7,text:"      i += 1;"},{stage:2,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:8,text:"  return -1;"},{stage:0,text:"}"},{stage:0,text:""}]},103:{problemID:103,problemName:"Find All Duplicate Numbers",problemText:"We are given an unsorted array containing \u2018n\u2019 numbers taken from the range 1 to \u2018n\u2019. The array has some numbers appearing twice, find all these duplicate numbers without using any extra space.  Return them as an array in ascending order.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_all_duplicates([3, 4, 4, 5, 5]);",expected:JSON.stringify([5,4])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_all_duplicates([5, 4, 7, 2, 3, 5, 3]);",expected:JSON.stringify([3,5])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/RLw1Pjk1GQ0"],tags:["Cyclic Sort",d],solution:[{stage:0,text:""},{stage:0,text:"function find_all_duplicates(nums) {"},{stage:1,text:"  let i = 0;"},{stage:1,text:"  while (i < nums.length) {"},{stage:2,text:"    let j = nums[i] - 1;"},{stage:2,text:"    if (nums[i] != nums[j]) {"},{stage:3,text:"      [nums[i], nums[j]] = [nums[j], nums[i]];"},{stage:2,text:"    } else {"},{stage:4,text:"      i++;"},{stage:2,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:5,text:"  const duplicateNumbers = [];"},{stage:6,text:"  for (i = 0; i < nums.length; i++) {"},{stage:7,text:"    if (nums[i] !== i + 1) {"},{stage:8,text:"      duplicateNumbers.push(nums[i]);"},{stage:7,text:"    }"},{stage:6,text:"  }"},{stage:0,text:""},{stage:9,text:"  return duplicateNumbers;"},{stage:0,text:"}"},{stage:0,text:""}]},104:{problemID:104,problemName:"0/1 Knapsack",problemText:"Given two integer arrays to represent weights and profits of \u2018N\u2019 items, we need to find a subset of these items which will give us maximum profit such that their cumulative weight is not more than a given number \u2018C.\u2019 Each item can only be selected once, which means either we put an item in the knapsack or we skip it.",testCases:[{id:1,name:"example 1",inherit:[],code:"var profits = [1, 6, 10, 16];\n      var weights = [1, 2, 3, 5];",evaluate:"solveKnapsack(profits, weights, 7);",expected:22},{id:2,name:"example 2",inherit:[1],code:"",evaluate:"solveKnapsack(profits, weights, 6);",expected:17}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/gkZNLjV2kBk"],tags:["Dynamic Programming",d],solution:[{stage:0,text:""},{stage:0,text:"let solveKnapsack = function (profits, weights, capacity) {"},{stage:1,text:"  const n = profits.length;"},{stage:2,text:"  if (capacity <= 0 || n == 0 || weights.length != n) return 0;"},{stage:0,text:""},{stage:3,text:"  const dp = Array(capacity + 1).fill(0);"},{stage:0,text:""},{stage:4,text:"  for (let c = 0; c <= capacity; c++) {"},{stage:5,text:"    if (weights[0] <= c) dp[c] = profits[0];"},{stage:4,text:"  }"},{stage:0,text:""},{stage:6,text:"  for (let i = 1; i < n; i++) {"},{stage:7,text:"    for (let c = capacity; c >= 0; c--) {"},{stage:8,text:"      let profit1 = 0;"},{stage:8,text:"      let profit2 = 0;"},{stage:0,text:""},{stage:9,text:"      if (weights[i] <= c) {"},{stage:10,text:"        profit1 = profits[i] + dp[c - weights[i]];"},{stage:9,text:"      }"},{stage:0,text:""},{stage:11,text:"      profit2 = dp[c];"},{stage:12,text:"      dp[c] = Math.max(profit1, profit2);"},{stage:7,text:"    }"},{stage:6,text:"  }"},{stage:0,text:""},{stage:13,text:"  return dp[capacity];"},{stage:0,text:"};"},{stage:0,text:""}]},105:{problemID:105,problemName:"Linked List Cycle",problemText:"Given the head of a Singly LinkedList, write a function to determine if the LinkedList has a cycle in it or not.",testCases:[{id:1,name:"example 1",inherit:[],code:"const head = new Node(1);\n      head.next = new Node(2);\n      head.next.next = new Node(3);\n      head.next.next.next = new Node(4);\n      head.next.next.next.next = new Node(5);\n      head.next.next.next.next.next = new Node(6);",evaluate:"has_cycle(head);",expected:!1},{id:2,name:"example 2",inherit:[1],code:"head.next.next.next.next.next.next = head.next.next;",evaluate:"has_cycle(head);",expected:!0},{id:3,name:"example 3",inherit:[1,2],code:"head.next.next.next.next.next.next = head.next.next.next;",evaluate:"has_cycle(head);",expected:!0}],setupCode:"class Node {\n    constructor(value, next = null) {\n      this.value = value;\n      this.next = next;\n    }\n  }",source:["https://www.educative.io/courses/grokking-the-coding-interview/N7rwVyAZl6D"],tags:[w,d],solution:[{stage:0,text:""},{stage:-1,text:"class Node {"},{stage:-1,text:"  constructor(value, next = null) {"},{stage:-1,text:"    this.value = value;"},{stage:-1,text:"    this.next = next;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function has_cycle(head) {"},{stage:1,text:"  let slow = head;"},{stage:1,text:"  let fast = head;"},{stage:0,text:""},{stage:2,text:"  while (fast !== null && fast.next !== null) {"},{stage:3,text:"    fast = fast.next.next;"},{stage:3,text:"    slow = slow.next;"},{stage:4,text:"    if (slow === fast) {"},{stage:5,text:"      return true;"},{stage:4,text:"    }"},{stage:2,text:"  }"},{stage:0,text:""},{stage:6,text:"  return false;"},{stage:0,text:"}"},{stage:0,text:""}]},106:{problemID:106,problemName:"Middle of Linked List",problemText:"Given the head of a Singly LinkedList, write a method to return the middle node of the LinkedList.\n\nIf the total number of nodes in the LinkedList is even, return the second middle node.",testCases:[{id:1,name:"example 1",inherit:[],code:"const head = new Node(1);\n      head.next = new Node(2);\n      head.next.next = new Node(3);\n      head.next.next.next = new Node(4);\n      head.next.next.next.next = new Node(5);",evaluate:"find_middle_of_linked_list(head).value",expected:3},{id:2,name:"example 2",inherit:[1],code:"head.next.next.next.next.next = new Node(6);",evaluate:"find_middle_of_linked_list(head).value",expected:4},{id:3,name:"example 3",inherit:[1,2],code:"head.next.next.next.next.next.next = new Node(7);",evaluate:"find_middle_of_linked_list(head).value",expected:4}],setupCode:"\nclass Node {\n  constructor(value, next = null) {\n    this.value = value;\n    this.next = next;\n  }\n}\n",source:["https://www.educative.io/courses/grokking-the-coding-interview/3j5GD3EQMGM"],tags:[w,d],solution:[{stage:0,text:""},{stage:-1,text:"class Node {"},{stage:-1,text:"  constructor(value, next = null) {"},{stage:-1,text:"    this.value = value;"},{stage:-1,text:"    this.next = next;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function find_middle_of_linked_list(head) {"},{stage:1,text:"  let slow = head;"},{stage:1,text:"  let fast = head;"},{stage:0,text:""},{stage:2,text:"  while (fast !== null && fast.next !== null) {"},{stage:3,text:"    slow = slow.next;"},{stage:3,text:"    fast = fast.next.next;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:4,text:"  return slow;"},{stage:0,text:"}"},{stage:0,text:""}]},107:{problemID:107,problemName:"Merge K Sorted Lists",problemText:"Given an array of \u2018K\u2019 sorted LinkedLists, merge them into one sorted list.",testCases:[{id:1,name:"example 1",inherit:[],code:"const l1 = new ListNode(2);\n      l1.next = new ListNode(6);\n      l1.next.next = new ListNode(8);\n      const l2 = new ListNode(3);\n      l2.next = new ListNode(6);\n      l2.next.next = new ListNode(7);\n      const l3 = new ListNode(1);\n      l3.next = new ListNode(3);\n      l3.next.next = new ListNode(4);",evaluate:"merge_lists([l1, l2, l3]).convert();",expected:JSON.stringify([1,2,3,3,4,6,6,7,8])},{id:2,name:"example 2",inherit:[],code:"const l1 = new ListNode(5);\n      l1.next = new ListNode(8);\n      l1.next.next = new ListNode(9);\n      const l2 = new ListNode(1);\n      l2.next = new ListNode(7);;",evaluate:"merge_lists([l1, l2]).convert();",expected:JSON.stringify([1,5,7,8,9])}],setupCode:"".concat("\nclass MinHeap {\n    constructor() {\n      this.heapContainer = [];\n    }\n  \n    getLeftChildIndex(parentIndex) {\n      return 2 * parentIndex + 1;\n    }\n  \n    getRightChildIndex(parentIndex) {\n      return 2 * parentIndex + 2;\n    }\n  \n    hasLeftChild(parentIndex) {\n      return this.getLeftChildIndex(parentIndex) < this.heapContainer.length;\n    }\n  \n    hasRightChild(parentIndex) {\n      return this.getRightChildIndex(parentIndex) < this.heapContainer.length;\n    }\n  \n    leftChild(parentIndex) {\n      return this.heapContainer[this.getLeftChildIndex(parentIndex)];\n    }\n  \n    rightChild(parentIndex) {\n      return this.heapContainer[this.getRightChildIndex(parentIndex)];\n    }\n  \n    getParentIndex(childIndex) {\n      return Math.floor((childIndex - 1) / 2);\n    }\n  \n    hasParent(childIndex) {\n      return this.getParentIndex(childIndex) >= 0;\n    }\n  \n    parent(childIndex) {\n      return this.heapContainer[this.getParentIndex(childIndex)];\n    }\n  \n    poll() {\n      if (this.heapContainer.length === 0) {\n        return null;\n      }\n      if (this.heapContainer.length === 1) {\n        return this.heapContainer.pop();\n      }\n      const item = this.heapContainer[0];\n      this.heapContainer[0] = this.heapContainer.pop();\n      this.heapifyDown();\n      return item;\n    }\n  \n    add(item) {\n      this.heapContainer.push(item);\n      this.heapifyUp();\n      return this;\n    }\n  \n    heapifyUp(customStartIndex) {\n      let currentIndex = customStartIndex || this.heapContainer.length - 1;\n  \n      while (\n        this.hasParent(currentIndex) &&\n        !(this.parent(currentIndex).value <= this.heapContainer[currentIndex].value)\n      ) {\n        this.swap(currentIndex, this.getParentIndex(currentIndex));\n        currentIndex = this.getParentIndex(currentIndex);\n      }\n    }\n  \n    heapifyDown(customStartIndex = 0) {\n      let currentIndex = customStartIndex;\n      let nextIndex = null;\n  \n      while (this.hasLeftChild(currentIndex)) {\n        if (\n          this.hasRightChild(currentIndex) &&\n          this.rightChild(currentIndex).value <= this.leftChild(currentIndex).value\n        ) {\n          nextIndex = this.getRightChildIndex(currentIndex);\n        } else {\n          nextIndex = this.getLeftChildIndex(currentIndex);\n        }\n  \n        if (this.heapContainer[currentIndex].value <= this.heapContainer[nextIndex].value) {\n          break;\n        }\n  \n        this.swap(currentIndex, nextIndex);\n        currentIndex = nextIndex;\n      }\n    }\n  \n    swap(indexOne, indexTwo) {\n      const tmp = this.heapContainer[indexTwo];\n      this.heapContainer[indexTwo] = this.heapContainer[indexOne];\n      this.heapContainer[indexOne] = tmp;\n    }\n  \n    length() {\n      return this.heapContainer.length;\n    }\n  }\n"," \n  class ListNode {\n    constructor(value, next = null) {\n      this.value = value;\n      this.next = next;\n    }\n  }\n\n  ListNode.prototype.convert = function () {\n    const arr = [];\n    let node = this;\n    while (node) {\n      arr.push(node.value);\n      node = node.next;\n    }\n    return arr;\n  };"),lcid:23,source:["https://www.educative.io/courses/grokking-the-coding-interview/Y5n0n3vAgYK","https://leetcode.com/problems/merge-k-sorted-lists/"],tags:[u,"K-Way-Merge",d],solution:[{stage:0,text:""},{stage:-1,text:"class MinHeap {"},{stage:-1,text:"/*"},{stage:-1,text:"  poll(): ListNode"},{stage:-1,text:"  add(item: ListNode) void"},{stage:-1,text:"  length() Number"},{stage:-1,text:"*/"},{stage:-1,text:"}"},{stage:-1,text:""},{stage:-1,text:"class ListNode {"},{stage:-1,text:"  constructor(value, next = null) {"},{stage:-1,text:"    this.value = value;"},{stage:-1,text:"    this.next = next;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function merge_lists(lists) {"},{stage:1,text:"  const minHeap = new MinHeap();"},{stage:0,text:""},{stage:2,text:"  lists.forEach(a => {"},{stage:3,text:"    if (a !== null) {"},{stage:3,text:"      minHeap.add(a);"},{stage:3,text:"    }"},{stage:2,text:"  });"},{stage:0,text:""},{stage:4,text:"  let resultHead = null;"},{stage:4,text:"  let resultTail = null;"},{stage:5,text:"  while (minHeap.length() > 0) {"},{stage:6,text:"    let node = minHeap.poll();"},{stage:0,text:""},{stage:7,text:"    if (resultHead === null) {"},{stage:8,text:"      resultHead = resultTail = node;"},{stage:7,text:"    } else {"},{stage:9,text:"      resultTail.next = node;"},{stage:9,text:"      resultTail = resultTail.next;"},{stage:7,text:"    }"},{stage:10,text:"    if (node.next !== null) {"},{stage:11,text:"      minHeap.add(node.next);"},{stage:10,text:"    }"},{stage:5,text:"  }"},{stage:0,text:""},{stage:12,text:"  return resultHead;"},{stage:0,text:"}"},{stage:0,text:""}]},108:{problemID:108,problemName:"Insert Intervals",problemText:"Given a list of non-overlapping intervals sorted by their start time, insert a given interval at the correct position and merge all necessary intervals to produce a list that has only mutually exclusive intervals.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"insert([[1, 3],[5, 7],[8, 12]],[4, 6]);",expected:JSON.stringify([[1,3],[4,7],[8,12]])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"insert([[1, 3],[5, 7],[8, 12]],[4, 10]);",expected:JSON.stringify([[1,3],[4,12]])},{id:3,name:"example 3",inherit:[],code:"",evaluate:"insert([[2, 3],[5, 7]],[1, 4]);",expected:JSON.stringify([[1,4],[5,7]])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/3jKlyNMJPEM"],tags:["Merge Intervals",d],solution:[{stage:0,text:""},{stage:0,text:"function insert(intervals, new_interval) {"},{stage:1,text:"  let merged = [];"},{stage:1,text:"  let i = 0;"},{stage:0,text:""},{stage:2,text:"  while (i < intervals.length && intervals[i][1] < new_interval[0]) {"},{stage:3,text:"    merged.push(intervals[i]);"},{stage:3,text:"    i += 1;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:4,text:"  while (i < intervals.length && intervals[i][0] <= new_interval[1]) {"},{stage:5,text:"    new_interval[0] = Math.min(intervals[i][0], new_interval[0]);"},{stage:6,text:"    new_interval[1] = Math.max(intervals[i][1], new_interval[1]);"},{stage:6,text:"    i += 1;"},{stage:4,text:"  }"},{stage:0,text:""},{stage:7,text:"  merged.push(new_interval);"},{stage:0,text:""},{stage:8,text:"  while (i < intervals.length) {"},{stage:9,text:"    merged.push(intervals[i]);"},{stage:9,text:"    i += 1;"},{stage:8,text:"  }"},{stage:0,text:""},{stage:10,text:"  return merged;"},{stage:0,text:"}"},{stage:0,text:""}]},109:{problemID:109,problemName:"Order Agnostic Binary Search",problemText:"Given a sorted array of numbers, find if a given number \u2018key\u2019 is present in the array. Though we know that the array is sorted, we don\u2019t know if it\u2019s sorted in ascending or descending order. You should assume that the array can have duplicates.\n\nWrite a function to return the index of the \u2018key\u2019 if it is present in the array, otherwise return -1.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"binary_search([4, 6, 10], 10);",expected:2},{id:2,name:"example 2",inherit:[],code:"",evaluate:"binary_search([1, 2, 3, 4, 5, 6, 7], 5);",expected:4},{id:3,name:"example 3",inherit:[],code:"",evaluate:"binary_search([10, 6, 4], 10);",expected:0},{id:4,name:"example 4",inherit:[],code:"",evaluate:"binary_search([10, 6, 4], 4);",expected:2}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/R8LzZQlj8lO"],tags:["Binary Search",d],solution:[{stage:0,text:""},{stage:0,text:"function binary_search(arr, key) {"},{stage:1,text:"  let start = 0;"},{stage:1,text:"  let end = arr.length - 1;"},{stage:2,text:"  let isAscending = arr[start] < arr[end];"},{stage:0,text:""},{stage:3,text:"  while (start <= end) {"},{stage:4,text:"    let mid = Math.floor(start + (end - start) / 2);"},{stage:5,text:"    if (key === arr[mid]) {"},{stage:6,text:"      return mid;"},{stage:5,text:"    }"},{stage:7,text:"    if (isAscending) {"},{stage:8,text:"      if (key < arr[mid]) {"},{stage:9,text:"        end = mid - 1;"},{stage:8,text:"      } else {"},{stage:9,text:"        start = mid + 1;"},{stage:8,text:"      }"},{stage:7,text:"    } else {"},{stage:10,text:"      if (key > arr[mid]) {"},{stage:11,text:"        end = mid - 1;"},{stage:10,text:"      } else {"},{stage:11,text:"        start = mid + 1;"},{stage:10,text:"      }"},{stage:7,text:"    }"},{stage:3,text:"  }"},{stage:0,text:""},{stage:12,text:"  return -1;"},{stage:0,text:"}"},{stage:0,text:""}]},110:{problemID:110,problemName:"Bitonic Array Maximum",problemText:"Find the maximum value in a given Bitonic array. An array is considered bitonic if it is monotonically increasing and then monotonically decreasing. Monotonically increasing or decreasing means that for any index i in the array arr[i] != arr[i+1].",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_max_in_bitonic_array([1, 3, 8, 12, 4, 2]);",expected:12},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_max_in_bitonic_array([3, 8, 3, 1]);",expected:8},{id:3,name:"example 3",inherit:[],code:"",evaluate:"find_max_in_bitonic_array([1, 3, 8, 12]);",expected:12},{id:4,name:"example 4",inherit:[],code:"",evaluate:"find_max_in_bitonic_array([10, 9, 8]);",expected:10}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/RMyRR6wZoYK"],tags:["Binary Search",d],solution:[{stage:0,text:""},{stage:0,text:"function find_max_in_bitonic_array(arr) {"},{stage:1,text:"  let start = 0;"},{stage:2,text:"  let end = arr.length - 1;"},{stage:0,text:""},{stage:-3,text:"  // we are explicitly working towards start === end"},{stage:3,text:"  while (start < end) {"},{stage:4,text:"    let mid = Math.floor((start + end) / 2);"},{stage:0,text:""},{stage:-5,text:"    // if the next element in the array is smaller than the current element"},{stage:-5,text:"    // then the array is decreasing (already at or past maximum value)"},{stage:5,text:"    if (arr[mid] > arr[mid + 1]) {"},{stage:-6,text:"      // re-set at mid rather than (mid + 1), because it is still possible"},{stage:-6,text:"      // that this element could be the maximum value"},{stage:6,text:"      end = mid;"},{stage:5,text:"    } else {"},{stage:-7,text:"      // if the next element is larger, then the maximum element is yet to come"},{stage:-7,text:"      // reset the start index to be one more than the middle index"},{stage:7,text:"      start = mid + 1;"},{stage:5,text:"    }"},{stage:3,text:"  }"},{stage:0,text:""},{stage:-8,text:"  // return the value, not the index"},{stage:8,text:"  return arr[start];"},{stage:0,text:"}"},{stage:0,text:""}]},111:{problemID:111,problemName:"Reverse Sub List",problemText:"Given the head of a LinkedList and two positions \u2018p\u2019 and \u2018q\u2019, reverse the LinkedList from position \u2018p\u2019 to \u2018q\u2019.",testCases:[{id:1,name:"example 1",inherit:[],code:"const head = new Node(1);\n      head.next = new Node(2);\n      head.next.next = new Node(3);\n      head.next.next.next = new Node(4);\n      head.next.next.next.next = new Node(5);",evaluate:"reverse_sub_list(head, 2, 4).convert();",expected:JSON.stringify([1,4,3,2,5])}],setupCode:"\n  function Node(value) {\n    this.value = value;\n    this.next = null;\n  }\n\n  Node.prototype.convert = function () {\n    const arr = [];\n    let node = this;\n    while (node) {\n      arr.push(node.value);\n      node = node.next;\n    }\n    return arr;\n  };",source:["https://www.educative.io/courses/grokking-the-coding-interview/qVANqMonoB2"],tags:[c,d],solution:[{stage:0,text:""},{stage:-1,text:"class Node {"},{stage:-1,text:"  constructor(value, next = null) {"},{stage:-1,text:"    this.value = value;"},{stage:-1,text:"    this.next = next;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function reverse_sub_list(head, p, q) {"},{stage:1,text:"  if (p === q) {"},{stage:1,text:"    return head;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:2,text:"  let current = head;"},{stage:2,text:"  let previous = null;"},{stage:2,text:"  let i = 0;"},{stage:3,text:"  while (current !== null && i < p - 1) {"},{stage:4,text:"    previous = current;"},{stage:4,text:"    current = current.next;"},{stage:4,text:"    i += 1;"},{stage:3,text:"  }"},{stage:0,text:""},{stage:5,text:"  const last_node_of_first_part = previous;"},{stage:5,text:"  const last_node_of_sub_list = current;"},{stage:6,text:"  let next = null;"},{stage:6,text:"  i = 0;"},{stage:0,text:""},{stage:7,text:"  while (current !== null && i < q - p + 1) {"},{stage:8,text:"    next = current.next;"},{stage:8,text:"    current.next = previous;"},{stage:9,text:"    previous = current;"},{stage:9,text:"    current = next;"},{stage:9,text:"    i += 1;"},{stage:7,text:"  }"},{stage:0,text:""},{stage:10,text:"  if (last_node_of_first_part !== null) {"},{stage:11,text:"    last_node_of_first_part.next = previous;"},{stage:10,text:"  } else {"},{stage:12,text:"    head = previous;"},{stage:10,text:"  }"},{stage:0,text:""},{stage:13,text:"  last_node_of_sub_list.next = current;"},{stage:13,text:"  return head;"},{stage:0,text:"}"},{stage:0,text:""}]},112:{problemID:112,problemName:"Subsets (distinct)",problemText:"Given a set with distinct elements, find all of its distinct subsets.\n  \n  Example:\n   - Input: [1, 3]\n   - Output: [], [1], [3], [1,3]",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"standardize(find_subsets([1, 3]));",expected:JSON.stringify(["","1","1-3","3"])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"standardize(find_subsets([1, 5, 3]));",expected:JSON.stringify(["","1","1-3","1-3-5","1-5","3","3-5","5"])}],setupCode:"\n  function standardize(arr) {\n    return arr\n      .map(d => {\n        return d.sort((a, b) => a - b).join('-');\n      })\n      .sort();\n  }",source:["https://www.educative.io/courses/grokking-the-coding-interview/gx2OqlvEnWG"],tags:[b,d],solution:[{stage:0,text:""},{stage:0,text:"function find_subsets(nums) {"},{stage:1,text:"  const subsets = [];"},{stage:0,text:""},{stage:2,text:"  subsets.push([]);"},{stage:3,text:"  for (let i = 0; i < nums.length; i++) {"},{stage:4,text:"    let currentNumber = nums[i];"},{stage:4,text:"    const n = subsets.length;"},{stage:5,text:"    for (let j = 0; j < n; j++) {"},{stage:6,text:"      const set1 = subsets[j].slice(0);"},{stage:7,text:"      set1.push(currentNumber);"},{stage:7,text:"      subsets.push(set1);"},{stage:5,text:"    }"},{stage:3,text:"  }"},{stage:0,text:""},{stage:8,text:"  return subsets;"},{stage:0,text:"}"},{stage:0,text:""}]},113:{problemID:113,problemName:"Subsets with Duplicates",problemText:"Given a set of numbers that might contain duplicates, find all of its distinct subsets.\n\nExample 1:\n\n - Input: [1, 3, 3]\n - Output: [], [1], [3], [1,3], [3,3], [1,3,3]",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"standardize(find_subsets([1, 3, 3]));",expected:JSON.stringify(["","1","1-3","1-3-3","3","3-3"])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"standardize(find_subsets([1, 5, 3, 3]));",expected:JSON.stringify(["","1","1-3","1-3-3","1-3-3-5","1-3-5","1-5","3","3-3","3-3-5","3-5","5"])}],setupCode:"\n  function standardize(arr) {\n    return arr\n      .map(d => {\n        return d.sort((a, b) => a - b).join('-');\n      })\n      .sort();\n  }",source:["https://www.educative.io/courses/grokking-the-coding-interview/7npk3V3JQNr"],tags:[b,d],solution:[{stage:0,text:""},{stage:0,text:"function find_subsets(nums) {"},{stage:0,text:""},{stage:1,text:"  nums.sort();"},{stage:1,text:"  const subsets = [];"},{stage:1,text:"  subsets.push([]);"},{stage:2,text:"  let startIndex = 0;"},{stage:2,text:"  let endIndex = 0;"},{stage:0,text:""},{stage:3,text:"  for (let i = 0; i < nums.length; i++) {"},{stage:4,text:"    startIndex = 0;"},{stage:0,text:""},{stage:4,text:"    if (i > 0 && nums[i] === nums[i - 1]) {"},{stage:5,text:"      startIndex = endIndex + 1;"},{stage:4,text:"    }"},{stage:6,text:"    endIndex = subsets.length - 1;"},{stage:7,text:"    for (let j = startIndex; j < endIndex + 1; j++) {"},{stage:8,text:"      const set1 = subsets[j].slice(0);"},{stage:8,text:"      set1.push(nums[i]);"},{stage:9,text:"      subsets.push(set1);"},{stage:7,text:"    }"},{stage:3,text:"  }"},{stage:0,text:""},{stage:10,text:"  return subsets;"},{stage:0,text:"}"},{stage:0,text:""}]},114:{problemID:114,problemName:"Top K Numbers",problemText:"Given an unsorted array of numbers, find the \u2018K\u2019 largest numbers in it.  Return them as an array sorted lowest to highest.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_k_largest_numbers([3, 1, 5, 12, 2, 11], 3);",expected:JSON.stringify([5,11,12])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_k_largest_numbers([5, 12, 11, -1, 12], 3);",expected:JSON.stringify([11,12,12])}],setupCode:"".concat(A),source:["https://www.educative.io/courses/grokking-the-coding-interview/RM535yM9DW0"],tags:[u,d],solution:[{stage:0,text:""},{stage:-1,text:"class MinHeap {"},{stage:-1,text:"  /*"},{stage:-1,text:"    add(item: Number)"},{stage:-1,text:"    poll() Number"},{stage:-1,text:"    length() Number"},{stage:-1,text:"  */"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function find_k_largest_numbers(nums, k) {"},{stage:1,text:"  const minHeap = new MinHeap();"},{stage:2,text:"  for (let i = 0; i < k; i++) {"},{stage:3,text:"    minHeap.add(nums[i]);"},{stage:2,text:"  }"},{stage:0,text:""},{stage:4,text:"  for (let i = k; i < nums.length; i++) {"},{stage:5,text:"    if (nums[i] > minHeap.peek()) {"},{stage:6,text:"      minHeap.poll();"},{stage:6,text:"      minHeap.add(nums[i]);"},{stage:5,text:"    }"},{stage:4,text:"  }"},{stage:0,text:""},{stage:7,text:"  let arr = [];"},{stage:8,text:"  while (minHeap.length()) {"},{stage:9,text:"    arr.push(minHeap.poll());"},{stage:8,text:"  }"},{stage:0,text:""},{stage:10,text:"  return arr;"},{stage:0,text:"}"},{stage:0,text:""}]},115:{problemID:115,problemName:"Find Kth Smallest Number",problemText:"Given an unsorted array of numbers, find Kth smallest number in it.\n\nPlease note that it is the Kth smallest number in the sorted order, not the Kth distinct element.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_Kth_smallest_number([1, 5, 12, 2, 11, 5], 3);",expected:5},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_Kth_smallest_number([1, 5, 12, 2, 11, 5], 4);",expected:5},{id:3,name:"example 3",inherit:[],code:"",evaluate:"find_Kth_smallest_number([5, 12, 11, -1, 12], 3);",expected:11}],setupCode:"".concat(J),source:["https://www.educative.io/courses/grokking-the-coding-interview/gxxPGn8vE8G"],tags:[u,d],solution:[{stage:0,text:""},{stage:-1,text:"class MaxHeap {"},{stage:-1,text:"  /*"},{stage:-1,text:"    add(item: Number)"},{stage:-1,text:"    poll() Number"},{stage:-1,text:"    peek() Number"},{stage:-1,text:"  */"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:""},{stage:0,text:"function find_Kth_smallest_number(nums, k) {"},{stage:0,text:""},{stage:1,text:"  const maxHeap = new MaxHeap();"},{stage:2,text:"  for (let i = 0; i < k; i++) {"},{stage:3,text:"    maxHeap.add(nums[i]);"},{stage:2,text:"  }"},{stage:0,text:""},{stage:4,text:"  for (let i = k; i < nums.length; i++) {"},{stage:5,text:"    if (nums[i] < maxHeap.peek()) {"},{stage:6,text:"      maxHeap.poll();"},{stage:6,text:"      maxHeap.add(nums[i]);"},{stage:5,text:"    }"},{stage:4,text:"  }"},{stage:0,text:""},{stage:7,text:"  return maxHeap.peek();"},{stage:0,text:"}"},{stage:0,text:""}]},116:{problemID:116,problemName:"Find K Closest Points to Origin",problemText:"Given an array of *Points* in on a 2d plane, find and return the `k` closest points to the origin.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"extractIds(find_closest_points(\n        [new Point('a', 1, 3), new Point('b', 3, 4), new Point('c', 2, -1)],\n        2,\n      ));",expected:JSON.stringify(["a","c"])}],setupCode:"".concat("\nclass MaxHeap {\n    constructor() {\n      this.heapContainer = [];\n    }\n  \n    // child utils\n    getLeftChildIndex(parentIndex) {\n      return 2 * parentIndex + 1;\n    }\n  \n    getRightChildIndex(parentIndex) {\n      return 2 * parentIndex + 2;\n    }\n  \n    hasLeftChild(parentIndex) {\n      return this.getLeftChildIndex(parentIndex) < this.heapContainer.length;\n    }\n  \n    hasRightChild(parentIndex) {\n      return this.getRightChildIndex(parentIndex) < this.heapContainer.length;\n    }\n  \n    leftChild(parentIndex) {\n      return this.heapContainer[this.getLeftChildIndex(parentIndex)];\n    }\n  \n    rightChild(parentIndex) {\n      return this.heapContainer[this.getRightChildIndex(parentIndex)];\n    }\n  \n    // parent utils\n    getParentIndex(childIndex) {\n      return Math.floor((childIndex - 1) / 2);\n    }\n  \n    hasParent(childIndex) {\n      return this.getParentIndex(childIndex) >= 0;\n    }\n  \n    parent(childIndex) {\n      return this.heapContainer[this.getParentIndex(childIndex)];\n    }\n  \n    // peek\n    peek() {\n      if (this.heapContainer.length === 0) {\n        return null;\n      }\n  \n      return this.heapContainer[0];\n    }\n  \n    // poll\n    poll() {\n      if (this.heapContainer.length === 0) {\n        return null;\n      }\n  \n      if (this.heapContainer.length === 1) {\n        return this.heapContainer.pop();\n      }\n  \n      const item = this.heapContainer[0];\n  \n      // Move the last element from the end to the head.\n      this.heapContainer[0] = this.heapContainer.pop();\n      this.heapifyDown();\n  \n      return item;\n    }\n  \n    // add\n    add(item) {\n      this.heapContainer.push(item);\n      this.heapifyUp();\n      return this;\n    }\n  \n    // heapify up for min heap and max heap\n    heapifyUp(customStartIndex) {\n      // Take the last element (last in array or the bottom left in a tree)\n      // in the heap container and lift it up until it is in the correct\n      // order with respect to its parent element.\n      let currentIndex = customStartIndex || this.heapContainer.length - 1;\n  \n      while (\n        this.hasParent(currentIndex) &&\n        !(this.parent(currentIndex).distance() >= this.heapContainer[currentIndex].distance())\n      ) {\n        this.swap(currentIndex, this.getParentIndex(currentIndex));\n        currentIndex = this.getParentIndex(currentIndex);\n      }\n    }\n  \n    // heapify down for min heap or max heap\n    heapifyDown(customStartIndex = 0) {\n      // Compare the parent element to its children and swap parent with the appropriate\n      // child (smallest child for MinHeap, largest child for MaxHeap).\n      // Do the same for next children after swap.\n      let currentIndex = customStartIndex;\n      let nextIndex = null;\n  \n      while (this.hasLeftChild(currentIndex)) {\n        if (\n          this.hasRightChild(currentIndex) &&\n          this.rightChild(currentIndex).distance() >= this.leftChild(currentIndex).distance()\n        ) {\n          nextIndex = this.getRightChildIndex(currentIndex);\n        } else {\n          nextIndex = this.getLeftChildIndex(currentIndex);\n        }\n  \n        if (this.heapContainer[currentIndex].distance() >= this.heapContainer[nextIndex].distance()) {\n          break;\n        }\n  \n        this.swap(currentIndex, nextIndex);\n        currentIndex = nextIndex;\n      }\n    }\n  \n    // no, but added as utility\n    swap(indexOne, indexTwo) {\n      const tmp = this.heapContainer[indexTwo];\n      this.heapContainer[indexTwo] = this.heapContainer[indexOne];\n      this.heapContainer[indexOne] = tmp;\n    }\n  \n    length() {\n      return this.heapContainer.length;\n    }\n  }\n"," \n  \n  function extractIds(arr) {\n    return arr.map(d => d.id);\n  }\n  \n  class Point {\n    constructor(id, x, y) {\n      this.id = id;\n      this.x = x;\n      this.y = y;\n    }\n  \n    distance() {\n      return this.x * this.x + this.y * this.y;\n    }\n  }\n  "),lcid:973,source:["https://www.educative.io/courses/grokking-the-coding-interview/3YxNVYwNR5p","https://leetcode.com/problems/k-closest-points-to-origin/"],tags:[u,d],solution:[{stage:0,text:""},{stage:-1,text:"class MaxHeap {"},{stage:-1,text:"  /*"},{stage:-1,text:"    add(item: Point)"},{stage:-1,text:"    peek() Point"},{stage:-1,text:"    poll() Point"},{stage:-1,text:"    length() Number"},{stage:-1,text:"  */"},{stage:-1,text:"}"},{stage:-1,text:""},{stage:-1,text:"class Point {"},{stage:-1,text:"  constructor(id, x, y) {"},{stage:-1,text:"    this.id = id;"},{stage:-1,text:"    this.x = x;"},{stage:-1,text:"    this.y = y;"},{stage:-1,text:"  }"},{stage:-1,text:""},{stage:-1,text:"  distance() {"},{stage:-1,text:"    return this.x * this.x + this.y * this.y;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function find_closest_points(points, k) {"},{stage:1,text:"  const maxHeap = new MaxHeap();"},{stage:0,text:""},{stage:2,text:"  for (let i = 0; i < k; i++) {"},{stage:3,text:"    maxHeap.add(points[i]);"},{stage:2,text:"  }"},{stage:0,text:""},{stage:4,text:"  for (let i = k; i < points.length; i++) {"},{stage:5,text:"    if (points[i].distance() < maxHeap.peek().distance()) {"},{stage:6,text:"      maxHeap.poll();"},{stage:6,text:"      maxHeap.add(points[i]);"},{stage:5,text:"    }"},{stage:4,text:"  }"},{stage:0,text:""},{stage:7,text:"  const arr = [];"},{stage:0,text:""},{stage:8,text:"  while (maxHeap.length()) {"},{stage:9,text:"    arr.push(maxHeap.poll());"},{stage:8,text:"  }"},{stage:0,text:""},{stage:10,text:"  return arr;"},{stage:0,text:"}"},{stage:0,text:""}]},117:{problemID:117,problemName:"Connect Ropes",problemText:"Given \u2018N\u2019 ropes with different lengths, we need to connect these ropes into one big rope with minimum cost. The cost of connecting two ropes is equal to the sum of their lengths.\n  \nExample 1:\n\n - Input: [1, 3, 11, 5]\n - Output: 33\n - Explanation: First connect 1+3(=4), then 4+5(=9), and then 9+11(=20). So the total cost is 33 (4+9+20)\n\n ",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"minimum_cost_to_connect_ropes([1, 3, 11, 5]);",expected:33},{id:2,name:"example 2",inherit:[],code:"",evaluate:"minimum_cost_to_connect_ropes([3, 4, 5, 6]);",expected:36},{id:3,name:"example 3",inherit:[],code:"",evaluate:"minimum_cost_to_connect_ropes([1, 3, 11, 5, 2]);",expected:42}],setupCode:"".concat(A),source:["https://www.educative.io/courses/grokking-the-coding-interview/qVZmZJVxPY0"],tags:[u,d],solution:[{stage:0,text:""},{stage:-1,text:"class MinHeap {"},{stage:-1,text:"  /*"},{stage:-1,text:"    add(item: Number)"},{stage:-1,text:"    poll() Number"},{stage:-1,text:"    length() Number"},{stage:-1,text:"  */"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function minimum_cost_to_connect_ropes(ropeLengths) {"},{stage:0,text:""},{stage:1,text:"  const minHeap = new MinHeap();"},{stage:0,text:""},{stage:2,text:"  ropeLengths.forEach(len => {"},{stage:3,text:"    minHeap.add(len);"},{stage:2,text:"  });"},{stage:0,text:""},{stage:4,text:"  let result = 0;"},{stage:4,text:"  while (minHeap.length() > 1) {"},{stage:5,text:"    const temp = minHeap.poll() + minHeap.poll();"},{stage:5,text:"    result += temp;"},{stage:6,text:"    minHeap.add(temp);"},{stage:4,text:"  }"},{stage:0,text:""},{stage:7,text:"  return result;"},{stage:0,text:"}"},{stage:0,text:""}]},118:{problemID:118,problemName:"Topological Sort",problemText:"Given a directed graph, find the topological ordering of its vertices.\n  \nExample:\n\nInput: Vertices=4, Edges=[3, 2], [3, 0], [2, 0], [2, 1]\n",testCases:[{id:1,name:"example 1",inherit:[],code:"const result = stringify(\n        topological_sort(4, [\n          [3, 2],\n          [3, 0],\n          [2, 0],\n          [2, 1],\n        ]),\n      );",evaluate:"['3,2,0,1', '3,2,1,0'].includes(result);",expected:!0},{id:2,name:"example 2",inherit:[],code:"const result = stringify(\n        topological_sort(5, [\n          [4, 2],\n          [4, 3],\n          [2, 0],\n          [2, 1],\n          [3, 1],\n        ]),\n      );",evaluate:"['4,2,3,0,1','4,3,2,0,1','4,3,2,1,0','4,2,3,1,0','4,2,0,3,1'].includes(result);",expected:!0},{id:3,name:"example 3",inherit:[],code:"const result = stringify(\n        topological_sort(7, [\n          [6, 4],\n          [6, 2],\n          [5, 3],\n          [5, 4],\n          [3, 0],\n          [3, 1],\n          [3, 2],\n          [4, 1],\n        ]),\n      );",evaluate:"['5,6,3,4,0,1,2','6,5,3,4,0,1,2','5,6,4,3,0,2,1','6,5,4,3,0,1,2','5,6,3,4,0,2,1','5,6,3,4,1,2,0'].includes(result);",expected:!0}],setupCode:"\n  function stringify(arr) {\n    return arr.join(',');\n  }\n  ",source:["https://www.educative.io/courses/grokking-the-coding-interview/m25rBmwLV00"],tags:[d,"Topological Sort"],solution:[{stage:0,text:""},{stage:0,text:"function topological_sort(vertices, edges) {"},{stage:0,text:""},{stage:1,text:"  const sortedOrder = [];"},{stage:2,text:"  if (vertices <= 0) {"},{stage:2,text:"    return sortedOrder;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:3,text:"  const inDegree = Array(vertices).fill(0);"},{stage:4,text:"  const graph = Array(vertices)"},{stage:4,text:"    .fill(0)"},{stage:4,text:"    .map(() => Array());"},{stage:0,text:""},{stage:5,text:"  edges.forEach(edge => {"},{stage:6,text:"    let parent = edge[0];"},{stage:6,text:"    let child = edge[1];"},{stage:7,text:"    graph[parent].push(child);"},{stage:7,text:"    inDegree[child]++;"},{stage:5,text:"  });"},{stage:0,text:""},{stage:8,text:"  const sources = [];"},{stage:8,text:"  for (let i = 0; i < inDegree.length; i++) {"},{stage:9,text:"    if (inDegree[i] === 0) {"},{stage:10,text:"      sources.push(i);"},{stage:9,text:"    }"},{stage:8,text:"  }"},{stage:0,text:""},{stage:11,text:"  while (sources.length > 0) {"},{stage:12,text:"    const vertex = sources.shift();"},{stage:12,text:"    sortedOrder.push(vertex);"},{stage:13,text:"    graph[vertex].forEach(child => {"},{stage:14,text:"      inDegree[child] -= 1;"},{stage:15,text:"      if (inDegree[child] === 0) {"},{stage:15,text:"        sources.push(child);"},{stage:15,text:"      }"},{stage:13,text:"    });"},{stage:11,text:"  }"},{stage:0,text:""},{stage:16,text:"  if (sortedOrder.length !== vertices) {"},{stage:16,text:"    return [];"},{stage:16,text:"  }"},{stage:0,text:""},{stage:17,text:"  return sortedOrder;"},{stage:0,text:"}"},{stage:0,text:""}]},119:{problemID:119,problemName:"Binary Tree Level Order Traversal",problemText:"Given a binary tree, populate an array to represent its level-by-level traversal. You should populate the values of all nodes of each level from left to right in separate sub-arrays.",testCases:[{id:1,name:"example 1",inherit:[],code:"const root = new TreeNode(12);\n      root.left = new TreeNode(7);\n      root.right = new TreeNode(1);\n      root.left.left = new TreeNode(9);\n      root.right.left = new TreeNode(10);\n      root.right.right = new TreeNode(5);",evaluate:"traverse(root);",expected:JSON.stringify([[12],[7,1],[9,10,5]])}],setupCode:"".concat(K),source:["https://www.educative.io/courses/grokking-the-coding-interview/xV7E64m4lnz"],tags:[h,m,d],solution:[{stage:0,text:""},{stage:-1,text:"class TreeNode {"},{stage:-1,text:"  constructor(val) {"},{stage:-1,text:"    this.val = val;"},{stage:-1,text:"    this.left = null;"},{stage:-1,text:"    this.right = null;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function traverse(root) {"},{stage:1,text:"  const result = [];"},{stage:2,text:"  if (root === null) {"},{stage:2,text:"    return result;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:3,text:"  const queue = [];"},{stage:3,text:"  queue.push(root);"},{stage:4,text:"  while (queue.length > 0) {"},{stage:5,text:"    const levelSize = queue.length;"},{stage:5,text:"    let currentLevel = [];"},{stage:6,text:"    for (let i = 0; i < levelSize; i++) {"},{stage:7,text:"      let currentNode = queue.shift();"},{stage:7,text:"      currentLevel.push(currentNode.val);"},{stage:8,text:"      if (currentNode.left !== null) {"},{stage:8,text:"        queue.push(currentNode.left);"},{stage:8,text:"      }"},{stage:9,text:"      if (currentNode.right !== null) {"},{stage:9,text:"        queue.push(currentNode.right);"},{stage:9,text:"      }"},{stage:6,text:"    }"},{stage:10,text:"    result.push(currentLevel);"},{stage:4,text:"  }"},{stage:0,text:""},{stage:11,text:"  return result;"},{stage:0,text:"}"},{stage:0,text:""}]},120:{problemID:120,problemName:"Reverse Level Order Traversal",problemText:"Given a binary tree, populate an array to represent its level-by-level traversal in reverse order, i.e., the lowest level comes first. You should populate the values of all nodes in each level from left to right in separate sub-arrays.",testCases:[{id:1,name:"example 1",inherit:[],code:"const root = new TreeNode(12);\n      root.left = new TreeNode(7);\n      root.right = new TreeNode(1);\n      root.left.left = new TreeNode(9);\n      root.right.left = new TreeNode(10);\n      root.right.right = new TreeNode(5);",evaluate:"traverse(root);",expected:JSON.stringify([[9,10,5],[7,1],[12]])}],setupCode:"".concat(K),source:["https://www.educative.io/courses/grokking-the-coding-interview/m2N6GwARL8r"],tags:[h,m,d],solution:[{stage:0,text:""},{stage:-1,text:"class TreeNode {"},{stage:-1,text:"  constructor(val) {"},{stage:-1,text:"    this.val = val;"},{stage:-1,text:"    this.left = null;"},{stage:-1,text:"    this.right = null;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function traverse(root) {"},{stage:1,text:"  const result = [];"},{stage:2,text:"  if (root === null) {"},{stage:2,text:"    return result;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:3,text:"  const queue = [];"},{stage:3,text:"  queue.push(root);"},{stage:4,text:"  while (queue.length > 0) {"},{stage:5,text:"    let levelSize = queue.length;"},{stage:5,text:"    let currentLevel = [];"},{stage:6,text:"    for (let i = 0; i < levelSize; i++) {"},{stage:7,text:"      let currentNode = queue.shift();"},{stage:7,text:"      currentLevel.push(currentNode.val);"},{stage:8,text:"      if (currentNode.left !== null) {"},{stage:8,text:"        queue.push(currentNode.left);"},{stage:8,text:"      }"},{stage:9,text:"      if (currentNode.right !== null) {"},{stage:9,text:"        queue.push(currentNode.right);"},{stage:9,text:"      }"},{stage:6,text:"    }"},{stage:0,text:""},{stage:10,text:"    result.unshift(currentLevel);"},{stage:4,text:"  }"},{stage:0,text:""},{stage:11,text:"  return result;"},{stage:0,text:"}"},{stage:0,text:""}]},121:{problemID:121,problemName:"Level Averages",problemText:"Given a binary tree, populate an array to represent the averages of all of its levels.",testCases:[{id:1,name:"example 1",inherit:[],code:"const root = new TreeNode(12);\n      root.left = new TreeNode(7);\n      root.right = new TreeNode(1);\n      root.left.left = new TreeNode(9);\n      root.left.right = new TreeNode(2);\n      root.right.left = new TreeNode(10);\n      root.right.right = new TreeNode(5);",evaluate:"find_level_averages(root);",expected:JSON.stringify([12,4,6.5])}],setupCode:"".concat(K),source:["https://www.educative.io/courses/grokking-the-coding-interview/YQWkA2l67GW"],tags:[h,m,d],solution:[{stage:0,text:""},{stage:-1,text:"class TreeNode {"},{stage:-1,text:"  constructor(val) {"},{stage:-1,text:"    this.val = val;"},{stage:-1,text:"    this.left = null;"},{stage:-1,text:"    this.right = null;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function find_level_averages(root) {"},{stage:1,text:"  const result = [];"},{stage:2,text:"  if (root === null) {"},{stage:2,text:"    return result;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:3,text:"  const queue = [];"},{stage:3,text:"  queue.push(root);"},{stage:4,text:"  while (queue.length > 0) {"},{stage:5,text:"    let levelSize = queue.length;"},{stage:5,text:"    let levelSum = 0.0;"},{stage:6,text:"    for (let i = 0; i < levelSize; i++) {"},{stage:7,text:"      let currentNode = queue.shift();"},{stage:7,text:"      levelSum += currentNode.val;"},{stage:8,text:"      if (currentNode.left !== null) {"},{stage:8,text:"        queue.push(currentNode.left);"},{stage:8,text:"      }"},{stage:9,text:"      if (currentNode.right !== null) {"},{stage:9,text:"        queue.push(currentNode.right);"},{stage:9,text:"      }"},{stage:6,text:"    }"},{stage:0,text:""},{stage:10,text:"    result.push(levelSum / levelSize);"},{stage:4,text:"  }"},{stage:0,text:""},{stage:11,text:"  return result;"},{stage:0,text:"}"},{stage:0,text:""}]},122:{problemID:122,problemName:"Minimum Depth Binary Tree",problemText:"Find the minimum depth of a binary tree. The minimum depth is the number of nodes along the shortest path from the root node to the nearest leaf node.",testCases:[{id:1,name:"example 1",inherit:[],code:"const root = new TreeNode(12);\n      root.left = new TreeNode(7);\n      root.right = new TreeNode(1);\n      root.right.left = new TreeNode(10);\n      root.right.right = new TreeNode(5);",evaluate:"find_minimum_depth(root);",expected:2},{id:2,name:"example 2",inherit:[1],code:"root.left.left = new TreeNode(9);\n      root.right.left.left = new TreeNode(11);",evaluate:"find_minimum_depth(root);",expected:3}],setupCode:"".concat(K),source:["https://www.educative.io/courses/grokking-the-coding-interview/3jwVx84OMkO"],tags:[h,m,d],solution:[{stage:0,text:""},{stage:-1,text:"class TreeNode {"},{stage:-1,text:"  constructor(val) {"},{stage:-1,text:"    this.val = val;"},{stage:-1,text:"    this.left = null;"},{stage:-1,text:"    this.right = null;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function find_minimum_depth(root) {"},{stage:1,text:"  if (root === null) {"},{stage:1,text:"    return 0;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:2,text:"  const queue = [];"},{stage:2,text:"  queue.push(root);"},{stage:3,text:"  let minimumTreeDepth = 0;"},{stage:4,text:"  while (queue.length > 0) {"},{stage:5,text:"    minimumTreeDepth += 1;"},{stage:5,text:"    let levelSize = queue.length;"},{stage:6,text:"    for (let i = 0; i < levelSize; i++) {"},{stage:7,text:"      let currentNode = queue.shift();"},{stage:8,text:"      if (currentNode.left === null && currentNode.right === null) {"},{stage:9,text:"        return minimumTreeDepth;"},{stage:8,text:"      }"},{stage:0,text:""},{stage:10,text:"      if (currentNode.left !== null) {"},{stage:10,text:"        queue.push(currentNode.left);"},{stage:10,text:"      }"},{stage:11,text:"      if (currentNode.right !== null) {"},{stage:11,text:"        queue.push(currentNode.right);"},{stage:11,text:"      }"},{stage:6,text:"    }"},{stage:4,text:"  }"},{stage:0,text:""},{stage:12,text:"  return 0;"},{stage:0,text:"}"},{stage:0,text:""}]},123:{problemID:123,problemName:"Level Order Successor",problemText:"Given a binary tree and a node, find the level order successor of the given node in the tree. The level order successor is the node that appears right after the given node in the level order traversal.",testCases:[{id:1,name:"example 1",inherit:[],code:"const root = new TreeNode(12);\n      root.left = new TreeNode(7);\n      root.right = new TreeNode(1);\n      root.left.left = new TreeNode(9);\n      root.right.left = new TreeNode(10);\n      root.right.right = new TreeNode(5);",evaluate:"find_successor(root, 12).val;",expected:7},{id:2,name:"example 2",inherit:[1],code:"",evaluate:"find_successor(root, 9).val;",expected:10}],setupCode:"".concat(K),source:["https://www.educative.io/courses/grokking-the-coding-interview/7nO4VmA74Lr"],tags:[h,m,d],solution:[{stage:0,text:""},{stage:-1,text:"class TreeNode {"},{stage:-1,text:"  constructor(val) {"},{stage:-1,text:"    this.val = val;"},{stage:-1,text:"    this.left = null;"},{stage:-1,text:"    this.right = null;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function find_successor(root, key) {"},{stage:1,text:"  if (root === null) {"},{stage:1,text:"    return null;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:2,text:"  const queue = [];"},{stage:2,text:"  queue.push(root);"},{stage:3,text:"  while (queue.length > 0) {"},{stage:4,text:"    let currentNode = queue.shift();"},{stage:5,text:"    if (currentNode.left !== null) {"},{stage:5,text:"      queue.push(currentNode.left);"},{stage:5,text:"    }"},{stage:6,text:"    if (currentNode.right !== null) {"},{stage:6,text:"      queue.push(currentNode.right);"},{stage:6,text:"    }"},{stage:7,text:"    if (currentNode.val === key) {"},{stage:7,text:"      break;"},{stage:7,text:"    }"},{stage:3,text:"  }"},{stage:0,text:""},{stage:8,text:"  if (queue.length > 0) {"},{stage:8,text:"    return queue[0];"},{stage:8,text:"  }"},{stage:0,text:""},{stage:9,text:"  return null;"},{stage:0,text:"}"},{stage:0,text:""}]},124:{problemID:124,problemName:"Binary Tree Path Sum",problemText:"Given a binary tree `root` and a number `sum`, find if the tree has a path from root-to-leaf such that the sum of all the node values of that path equals `sum`.",testCases:[{id:1,name:"example 1",inherit:[],code:"const root = new TreeNode(12);\n      root.left = new TreeNode(7);\n      root.right = new TreeNode(1);\n      root.left.left = new TreeNode(9);\n      root.right.left = new TreeNode(10);\n      root.right.right = new TreeNode(5);",evaluate:"hasPath(root, 23);",expected:!0},{id:2,name:"example 2",inherit:[1],code:"",evaluate:"hasPath(root, 16);",expected:!1}],setupCode:"".concat(K),source:["https://www.educative.io/courses/grokking-the-coding-interview/RMlGwgpoKKY"],tags:[h,f,d,"Recursion"],solution:[{stage:0,text:""},{stage:-1,text:"class TreeNode {"},{stage:-1,text:"  constructor(val, left = null, right = null) {"},{stage:-1,text:"    this.val = val;"},{stage:-1,text:"    this.left = left;"},{stage:-1,text:"    this.right = right;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function hasPath(root, sum) {"},{stage:0,text:""},{stage:-1,text:"  // base case: no node"},{stage:1,text:"  if (root === null) {"},{stage:2,text:"    return false;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:-3,text:"  // base case 2: value at node === remaining sum, and it is a leaf node"},{stage:3,text:"  if (root.val === sum && root.left === null && root.right === null) {"},{stage:4,text:"    return true;"},{stage:3,text:"  }"},{stage:0,text:""},{stage:-6,text:"  // if either condition is true, return true"},{stage:6,text:"  return hasPath(root.left, sum - root.val) || hasPath(root.right, sum - root.val);"},{stage:0,text:"}"},{stage:0,text:""}]},125:{problemID:125,problemName:"Find Median In Stream",problemText:"Design a class to calculate the median of a number stream. The class should have the following two methods:\n\n - **insertNum** (int num): stores the number in the class\n - **findMedian** (): returns the median of all numbers inserted in the class\n\nIf the count of numbers inserted in the class is even, the median will be the average of the middle two numbers.",testCases:[{id:1,name:"example 1",inherit:[],code:"const medianOfAStream = new MedianOfAStream();medianOfAStream.insert_num(3);medianOfAStream.insert_num(1);",evaluate:"medianOfAStream.find_median();",expected:3},{id:2,name:"example 2",inherit:[1],code:"medianOfAStream.insert_num(5);",evaluate:"medianOfAStream.find_median();",expected:3},{id:3,name:"example 3",inherit:[1,2],code:"medianOfAStream.insert_num(4);",evaluate:"medianOfAStream.find_median();",expected:3.5}],setupCode:"".concat(A," ").concat(J),source:["https://www.educative.io/courses/grokking-the-coding-interview/3Yj2BmpyEy4"],tags:[u,d],solution:[{stage:0,text:""},{stage:-1,text:"class MinHeap {"},{stage:-1,text:"  /*"},{stage:-1,text:"    add(item: Number)"},{stage:-1,text:"    poll(): Number"},{stage:-1,text:"    length(): Number"},{stage:-1,text:"  */"},{stage:-1,text:"}"},{stage:-1,text:""},{stage:-1,text:"class MaxHeap {"},{stage:-1,text:"  /*"},{stage:-1,text:"    add(item: Number)"},{stage:-1,text:"    poll(): Number"},{stage:-1,text:"    length(): Number"},{stage:-1,text:"  */"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"class MedianOfAStream {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.maxHeap = new MaxHeap();"},{stage:0,text:"    this.minHeap = new MinHeap();"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  insert_num(num) {"},{stage:1,text:"    if (this.maxHeap.length() === 0 || this.maxHeap.peek() >= num) {"},{stage:2,text:"      this.maxHeap.add(num);"},{stage:1,text:"    } else {"},{stage:3,text:"      this.minHeap.add(num);"},{stage:1,text:"    }"},{stage:0,text:""},{stage:4,text:"    if (this.maxHeap.length() > this.minHeap.length + 1) {"},{stage:5,text:"      this.minHeap.add(this.maxHeap.poll());"},{stage:4,text:"    } else if (this.maxHeap.length() < this.minHeap.length()) {"},{stage:6,text:"      this.maxHeap.add(this.minHeap.poll());"},{stage:4,text:"    }"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  find_median() {"},{stage:7,text:"    if (this.maxHeap.length() === this.minHeap.length()) {"},{stage:8,text:"      return this.maxHeap.peek() / 2.0 + this.minHeap.peek() / 2.0;"},{stage:7,text:"    }"},{stage:0,text:""},{stage:9,text:"    return this.maxHeap.peek();"},{stage:0,text:"  }"},{stage:0,text:"}"},{stage:0,text:""}]},126:{problemID:126,problemName:"Pair with Target Sum",problemText:"Given an array of sorted numbers and a target sum, find a pair in the array whose sum is equal to the given target.\n\nWrite a function to return the indices of the two numbers (i.e. the pair) such that they add up to the given target.\n  ",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"pair_with_target_sum([1, 2, 3, 4, 6], 6);",expected:JSON.stringify([1,3])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"pair_with_target_sum([2, 5, 9, 11], 11);",expected:JSON.stringify([0,2])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/xog6q15W9GP"],tags:["Two Pointers",d],solution:[{stage:0,text:""},{stage:0,text:"function pair_with_target_sum(arr, targetSum) {"},{stage:1,text:"  let left = 0;"},{stage:1,text:"  let right = arr.length - 1;"},{stage:2,text:"  while (left < right) {"},{stage:3,text:"    const currentSum = arr[left] + arr[right];"},{stage:4,text:"    if (currentSum === targetSum) {"},{stage:4,text:"      return [left, right];"},{stage:4,text:"    }"},{stage:0,text:""},{stage:5,text:"    if (targetSum > currentSum) {"},{stage:6,text:"      left += 1;"},{stage:5,text:"    } else {"},{stage:6,text:"      right -= 1;"},{stage:5,text:"    }"},{stage:2,text:"  }"},{stage:0,text:""},{stage:7,text:"  return [-1, -1];"},{stage:0,text:"}"},{stage:0,text:""}]},127:{problemID:127,problemName:"Remove Duplicates in Sorted Array",problemText:"Given an array of sorted numbers, remove all duplicates from it. You should not use any extra space; after removing the duplicates in-place return the length of the subarray that has no duplicate in it.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"remove_duplicates([2, 3, 3, 3, 6, 9, 9]);",expected:4},{id:2,name:"example 2",inherit:[],code:"",evaluate:"remove_duplicates([2, 2, 2, 11]);",expected:2}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/mEEA22L5mNA"],tags:["Two Pointers",d],solution:[{stage:0,text:""},{stage:0,text:"function remove_duplicates(arr) {"},{stage:1,text:"  let nextNonDuplicate = 1;"},{stage:0,text:""},{stage:1,text:"  let i = 1;"},{stage:2,text:"  while (i < arr.length) {"},{stage:3,text:"    if (arr[nextNonDuplicate - 1] !== arr[i]) {"},{stage:4,text:"      arr[nextNonDuplicate] = arr[i];"},{stage:4,text:"      nextNonDuplicate += 1;"},{stage:3,text:"    }"},{stage:5,text:"    i += 1;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:5,text:"  return nextNonDuplicate;"},{stage:0,text:"}"},{stage:0,text:""}]},128:{problemID:128,problemName:"Squaring Sorted Array",problemText:"Given a sorted array, create a new array containing squares of all the numbers of the input array in the sorted order.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"make_squares([-2, -1, 0, 2, 3]);",expected:JSON.stringify([0,1,4,4,9])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"make_squares([-3, -1, 0, 1, 2]);",expected:JSON.stringify([0,1,1,4,9])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/R1ppNG3nV9R"],tags:["Two Pointers",d],solution:[{stage:0,text:""},{stage:0,text:"function make_squares(arr) {"},{stage:1,text:"  const n = arr.length;"},{stage:1,text:"  let squares = Array(n).fill(0);"},{stage:2,text:"  let highestSquareIdx = n - 1;"},{stage:2,text:"  let left = 0;"},{stage:2,text:"  let right = n - 1;"},{stage:0,text:""},{stage:3,text:"  while (left <= right) {"},{stage:4,text:"    let leftSquare = arr[left] * arr[left];"},{stage:4,text:"    let rightSquare = arr[right] * arr[right];"},{stage:5,text:"    if (leftSquare > rightSquare) {"},{stage:6,text:"      squares[highestSquareIdx] = leftSquare;"},{stage:6,text:"      left += 1;"},{stage:5,text:"    } else {"},{stage:7,text:"      squares[highestSquareIdx] = rightSquare;"},{stage:7,text:"      right -= 1;"},{stage:5,text:"    }"},{stage:0,text:""},{stage:8,text:"    highestSquareIdx -= 1;"},{stage:3,text:"  }"},{stage:0,text:""},{stage:9,text:"  return squares;"},{stage:0,text:"}"},{stage:0,text:""}]},129:{problemID:129,problemName:"Find the Corrupt Pair",problemText:"We are given an unsorted array containing \u2018n\u2019 numbers taken from the range 1 to \u2018n\u2019. The array originally contained all the numbers from 1 to \u2018n\u2019, but due to a data error, one of the numbers got duplicated which also resulted in one number going missing. Find both these numbers.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_corrupt_numbers([3, 1, 2, 5, 2]);",expected:JSON.stringify([2,4])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_corrupt_numbers([3, 1, 2, 3, 6, 4]);",expected:JSON.stringify([3,5])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/N7Vw2GBQr6D"],tags:["Cyclic Sort",d],solution:[{stage:0,text:""},{stage:0,text:"function find_corrupt_numbers(nums) {"},{stage:1,text:"  let i = 0;"},{stage:2,text:"  while (i < nums.length) {"},{stage:3,text:"    const j = nums[i] - 1;"},{stage:4,text:"    if (nums[i] !== nums[j]) {"},{stage:5,text:"      [nums[i], nums[j]] = [nums[j], nums[i]];"},{stage:4,text:"    } else {"},{stage:5,text:"      i += 1;"},{stage:4,text:"    }"},{stage:2,text:"  }"},{stage:0,text:""},{stage:6,text:"  for (i = 0; i < nums.length; i++) {"},{stage:7,text:"    if (nums[i] !== i + 1) {"},{stage:8,text:"      return [nums[i], i + 1];"},{stage:7,text:"    }"},{stage:6,text:"  }"},{stage:9,text:"  return [-1, -1];"},{stage:0,text:"}"},{stage:0,text:""}]},130:{problemID:130,problemName:"Find the Smallest Missing Positive Number",problemText:"Given an unsorted array containing numbers, find the smallest missing positive number in it.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_first_smallest_missing_positive([-3, 1, 5, 4, 2]);",expected:3},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_first_smallest_missing_positive([3, -2, 0, 1, 2]);",expected:4},{id:3,name:"example 3",inherit:[],code:"",evaluate:"find_first_smallest_missing_positive([3, 2, 5, 1]);",expected:4}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/R1GXQ071GQ0"],tags:["Cyclic Sort",d],solution:[{stage:0,text:""},{stage:0,text:"function find_first_smallest_missing_positive(nums) {"},{stage:1,text:"  let i = 0;"},{stage:1,text:"  let n = nums.length;"},{stage:2,text:"  while (i < n) {"},{stage:3,text:"    let j = nums[i] - 1;"},{stage:4,text:"    if (nums[i] > 0 && nums[i] <= n && nums[i] !== nums[j]) {"},{stage:5,text:"      [nums[i], nums[j]] = [nums[j], nums[i]];"},{stage:4,text:"    } else {"},{stage:6,text:"      i += 1;"},{stage:4,text:"    }"},{stage:2,text:"  }"},{stage:0,text:""},{stage:7,text:"  for (let i = 0; i < n; i++) {"},{stage:8,text:"    if (nums[i] !== i + 1) {"},{stage:9,text:"      return i + 1;"},{stage:8,text:"    }"},{stage:7,text:"  }"},{stage:0,text:""},{stage:10,text:"  return nums.length + 1;"},{stage:0,text:"}"},{stage:0,text:""}]},131:{problemID:131,problemName:"Find the First K Missing Positive Numbers",problemText:"Given an unsorted array containing numbers and a number \u2018k\u2019, find the first \u2018k\u2019 missing positive numbers in the array.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_first_k_missing_positive([3, -1, 4, 5, 5], 3);",expected:JSON.stringify([1,2,6])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_first_k_missing_positive([2, 3, 4], 3);",expected:JSON.stringify([1,5,6])},{id:3,name:"example 3",inherit:[],code:"",evaluate:"find_first_k_missing_positive([-2, -3, 4], 2);",expected:JSON.stringify([1,2])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/g286M2Gk3YY"],tags:["Cyclic Sort",d],solution:[{stage:0,text:""},{stage:0,text:"function find_first_k_missing_positive(nums, k) {"},{stage:1,text:"  const n = nums.length;"},{stage:1,text:"  let i = 0;"},{stage:0,text:""},{stage:2,text:"  while (i < n) {"},{stage:3,text:"    const j = nums[i] - 1;"},{stage:4,text:"    if (nums[i] > 0 && nums[i] <= n && nums[i] !== nums[j]) {"},{stage:5,text:"      [nums[i], nums[j]] = [nums[j], nums[i]];"},{stage:4,text:"    } else {"},{stage:6,text:"      i += 1;"},{stage:4,text:"    }"},{stage:2,text:"  }"},{stage:0,text:""},{stage:7,text:"  const missingNumbers = [];"},{stage:7,text:"  const extraNumbers = new Set();"},{stage:8,text:"  for (let i = 0; i < n; i++) {"},{stage:9,text:"    if (missingNumbers.length < k) {"},{stage:10,text:"      if (nums[i] !== i + 1) {"},{stage:11,text:"        missingNumbers.push(i + 1);"},{stage:11,text:"        extraNumbers.add(nums[i]);"},{stage:10,text:"      }"},{stage:9,text:"    }"},{stage:8,text:"  }"},{stage:0,text:""},{stage:12,text:"  i = 1;"},{stage:13,text:"  while (missingNumbers.length < k) {"},{stage:14,text:"    const candidateNumber = i + n;"},{stage:15,text:"    if (!extraNumbers.has(candidateNumber)) {"},{stage:16,text:"      missingNumbers.push(candidateNumber);"},{stage:15,text:"    }"},{stage:17,text:"    i += 1;"},{stage:13,text:"  }"},{stage:18,text:"  return missingNumbers;"},{stage:0,text:"}"},{stage:0,text:""}]},132:{problemID:132,problemName:"Start of Linked List Cycle",problemText:"Given the head of a Singly LinkedList that contains a cycle, write a function to find the starting node of the cycle.",testCases:[{id:1,name:"example 1",inherit:[],code:"const head = new Node(1);\n      head.next = new Node(2);\n      head.next.next = new Node(3);\n      head.next.next.next = new Node(4);\n      head.next.next.next.next = new Node(5);\n      head.next.next.next.next.next = new Node(6);\n      head.next.next.next.next.next.next = head.next.next;",evaluate:"find_cycle_start(head).value;",expected:3},{id:2,name:"example 2",inherit:[1],code:"head.next.next.next.next.next.next = head.next.next.next;",evaluate:"find_cycle_start(head).value;",expected:4},{id:3,name:"example 3",inherit:[1,2],code:"head.next.next.next.next.next.next = head;",evaluate:"find_cycle_start(head).value;",expected:1}],setupCode:"\n  class Node {\n    constructor(value, next = null) {\n      this.value = value;\n      this.next = next;\n    }\n  }\n  ",source:["https://www.educative.io/courses/grokking-the-coding-interview/N7pvEn86YrN"],tags:[w,d],solution:[{stage:0,text:""},{stage:-1,text:"class Node {"},{stage:-1,text:"  constructor(value, next = null) {"},{stage:-1,text:"    this.value = value;"},{stage:-1,text:"    this.next = next;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function find_cycle_start(head) {"},{stage:1,text:"  let cycle_length = 0;"},{stage:0,text:""},{stage:2,text:"  let slow = head;"},{stage:2,text:"  let fast = head;"},{stage:0,text:""},{stage:3,text:"  while (fast !== null && fast.next !== null) {"},{stage:4,text:"    fast = fast.next.next;"},{stage:4,text:"    slow = slow.next;"},{stage:0,text:""},{stage:5,text:"    if (slow === fast) {"},{stage:6,text:"      cycle_length = calculate_cycle_length(slow);"},{stage:6,text:"      break;"},{stage:5,text:"    }"},{stage:3,text:"  }"},{stage:0,text:""},{stage:8,text:"  return find_start(head, cycle_length);"},{stage:0,text:"}"},{stage:0,text:""},{stage:7,text:"function calculate_cycle_length(slow) {"},{stage:9,text:"  let current = slow;"},{stage:9,text:"  let cycle_length = 0;"},{stage:0,text:""},{stage:10,text:"  while (true) {"},{stage:11,text:"    current = current.next;"},{stage:11,text:"    cycle_length += 1;"},{stage:12,text:"    if (current === slow) {"},{stage:12,text:"      break;"},{stage:12,text:"    }"},{stage:10,text:"  }"},{stage:0,text:""},{stage:13,text:"  return cycle_length;"},{stage:7,text:"}"},{stage:0,text:""},{stage:14,text:"function find_start(head, cycle_length) {"},{stage:15,text:"  let pointer1 = head;"},{stage:15,text:"  let pointer2 = head;"},{stage:0,text:""},{stage:16,text:"  while (cycle_length > 0) {"},{stage:17,text:"    pointer2 = pointer2.next;"},{stage:17,text:"    cycle_length -= 1;"},{stage:16,text:"  }"},{stage:0,text:""},{stage:18,text:"  while (pointer1 !== pointer2) {"},{stage:19,text:"    pointer1 = pointer1.next;"},{stage:19,text:"    pointer2 = pointer2.next;"},{stage:18,text:"  }"},{stage:0,text:""},{stage:20,text:"  return pointer1;"},{stage:14,text:"}"},{stage:0,text:""}]},133:{problemID:133,problemName:"Happy Number",problemText:"Any number will be called a happy number if, after repeatedly replacing it with a number equal to the sum of the square of all of its digits, leads us to number \u20181\u2019. All other (not-happy) numbers will never reach \u20181\u2019. Instead, they will be stuck in a cycle of numbers which does not include \u20181\u2019.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_happy_number(23);",expected:!0},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_happy_number(12);",expected:!1}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/39q3ZWq27jM"],tags:[w,d],solution:[{stage:0,text:""},{stage:0,text:"function find_happy_number(num) {"},{stage:1,text:"  let slow = num;"},{stage:1,text:"  let fast = num;"},{stage:0,text:""},{stage:2,text:"  while (true) {"},{stage:3,text:"    slow = find_square_sum(slow);"},{stage:3,text:"    fast = find_square_sum(find_square_sum(fast));"},{stage:0,text:""},{stage:9,text:"    if (slow === fast) {"},{stage:10,text:"      break;"},{stage:9,text:"    }"},{stage:2,text:"  }"},{stage:0,text:""},{stage:11,text:"  return slow === 1;"},{stage:0,text:"}"},{stage:0,text:""},{stage:4,text:"function find_square_sum(num) {"},{stage:5,text:"  let sum = 0;"},{stage:6,text:"  while (num > 0) {"},{stage:7,text:"    let digit = num % 10;"},{stage:7,text:"    sum += digit * digit;"},{stage:7,text:"    num = Math.floor(num / 10);"},{stage:6,text:"  }"},{stage:0,text:""},{stage:8,text:"  return sum;"},{stage:4,text:"}"},{stage:0,text:""}]},134:{problemID:134,problemName:"Palindrome Linked List",problemText:"Given the head of a Singly LinkedList, write a method to check if the LinkedList is a palindrome or not.\n  \n  Your algorithm should use constant space and the input LinkedList should be in the original form once the algorithm is finished. The algorithm should have O(N)O(N) time complexity where \u2018N\u2019 is the number of nodes in the LinkedList.\n  ",testCases:[{id:1,name:"example 1",inherit:[],code:"const head = new Node(2);\n      head.next = new Node(4);\n      head.next.next = new Node(6);\n      head.next.next.next = new Node(4);\n      head.next.next.next.next = new Node(2);\n      ",evaluate:"is_palindromic_linked_list(head);",expected:!0},{id:2,name:"example 2",inherit:[1],code:"head.next.next.next.next.next = new Node(2);",evaluate:"is_palindromic_linked_list(head);",expected:!1}],setupCode:"\n  class Node {\n    constructor(value, next = null) {\n      this.value = value;\n      this.next = next;\n    }\n  }\n  ",source:["https://www.educative.io/courses/grokking-the-coding-interview/JERG3q0p912"],tags:[w,d],solution:[{stage:0,text:""},{stage:-1,text:"class Node {"},{stage:-1,text:"  constructor(value, next = null) {"},{stage:-1,text:"    this.value = value;"},{stage:-1,text:"    this.next = next;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function is_palindromic_linked_list(head) {"},{stage:1,text:"  if (head === null || head.next === null) {"},{stage:1,text:"    return true;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:2,text:"  let slow = head;"},{stage:2,text:"  let fast = head;"},{stage:3,text:"  while (fast !== null && fast.next !== null) {"},{stage:4,text:"    slow = slow.next;"},{stage:4,text:"    fast = fast.next.next;"},{stage:3,text:"  }"},{stage:0,text:""},{stage:5,text:"  let headSecondHalf = reverse(slow);"},{stage:12,text:"  let copyHeadSecondHalf = headSecondHalf;"},{stage:0,text:""},{stage:13,text:"  while (head !== null && headSecondHalf !== null) {"},{stage:14,text:"    if (head.value !== headSecondHalf.value) {"},{stage:14,text:"      break;"},{stage:14,text:"    }"},{stage:0,text:""},{stage:15,text:"    head = head.next;"},{stage:15,text:"    headSecondHalf = headSecondHalf.next;"},{stage:13,text:"  }"},{stage:0,text:""},{stage:16,text:"  reverse(copyHeadSecondHalf);"},{stage:0,text:""},{stage:17,text:"  if (head === null || headSecondHalf === null) {"},{stage:18,text:"    return true;"},{stage:17,text:"  }"},{stage:0,text:""},{stage:18,text:"  return false;"},{stage:0,text:"}"},{stage:0,text:""},{stage:6,text:"function reverse(head) {"},{stage:7,text:"  let prev = null;"},{stage:0,text:""},{stage:8,text:"  while (head !== null) {"},{stage:9,text:"    let next = head.next;"},{stage:9,text:"    head.next = prev;"},{stage:10,text:"    prev = head;"},{stage:10,text:"    head = next;"},{stage:8,text:"  }"},{stage:0,text:""},{stage:11,text:"  return prev;"},{stage:6,text:"}"},{stage:0,text:""}]},135:{problemID:135,problemName:"Rearrange a LinkedList",problemText:"Given the head of a Singly LinkedList, write a method to modify the LinkedList such that the nodes from the second half of the LinkedList are inserted alternately to the nodes from the first half in reverse order. So if the LinkedList has nodes 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> null, your method should return 1 -> 6 -> 2 -> 5 -> 3 -> 4 -> null.\n\n  Your algorithm should not use any extra space and the input LinkedList should be modified in-place.",testCases:[{id:1,name:"example 1",inherit:[],code:"var head = new Node(2);\n      head.next = new Node(4);\n      head.next.next = new Node(6);\n      head.next.next.next = new Node(8);\n      head.next.next.next.next = new Node(10);\n      head.next.next.next.next.next = new Node(12);\n      reorder(head);",evaluate:"printList(head);",expected:JSON.stringify([2,12,4,10,6,8])}],setupCode:"\n  class Node {\n    constructor(value, next = null) {\n      this.value = value;\n      this.next = next;\n    }\n  }\n  function printList(list) {\n    let arr = [];\n    while(list) {\n      arr.push(list.value);\n      list = list.next;\n    }\n    return arr;\n  }\n  ",source:["https://www.educative.io/courses/grokking-the-coding-interview/qAo438WozV7"],tags:[w,d],solution:[{stage:0,text:""},{stage:-1,text:"class Node {"},{stage:-1,text:"  constructor(value, next = null) {"},{stage:-1,text:"    this.value = value;"},{stage:-1,text:"    this.next = next;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function reorder(head) {"},{stage:1,text:"  if (head === null || head.next === null) {"},{stage:1,text:"    return;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:2,text:"  let slow = head;"},{stage:2,text:"  let fast = head;"},{stage:3,text:"  while (fast !== null && fast.next !== null) {"},{stage:4,text:"    slow = slow.next;"},{stage:4,text:"    fast = fast.next.next;"},{stage:3,text:"  }"},{stage:0,text:""},{stage:5,text:"  let headSecondHalf = reverse(slow);"},{stage:5,text:"  let headFirstHalf = head;"},{stage:0,text:""},{stage:12,text:"  while (headFirstHalf !== null && headSecondHalf !== null) {"},{stage:13,text:"    let temp = headFirstHalf.next;"},{stage:13,text:"    headFirstHalf.next = headSecondHalf;"},{stage:13,text:"    headFirstHalf = temp;"},{stage:0,text:""},{stage:14,text:"    temp = headSecondHalf.next;"},{stage:14,text:"    headSecondHalf.next = headFirstHalf;"},{stage:14,text:"    headSecondHalf = temp;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:15,text:"  if (headFirstHalf !== null) {"},{stage:15,text:"    headFirstHalf.next = null;"},{stage:15,text:"  }"},{stage:12,text:"}"},{stage:0,text:""},{stage:6,text:"function reverse(head) {"},{stage:7,text:"  let prev = null;"},{stage:0,text:""},{stage:8,text:"  while (head !== null) {"},{stage:9,text:"    let next = head.next;"},{stage:9,text:"    head.next = prev;"},{stage:10,text:"    prev = head;"},{stage:10,text:"    head = next;"},{stage:8,text:"  }"},{stage:11,text:"  return prev;"},{stage:6,text:"}"},{stage:0,text:""}]},136:{problemID:136,problemName:"Cycle in a Circular Array",problemText:"We are given an array containing positive and negative numbers. Suppose the array contains a number \u2018M\u2019 at a particular index. Now, if \u2018M\u2019 is positive we will move forward \u2018M\u2019 indices and if \u2018M\u2019 is negative move backwards \u2018M\u2019 indices. You should assume that the array is circular which means two things:\n\n  If, while moving forward, we reach the end of the array, we will jump to the first element to continue the movement.\n\n  If, while moving backward, we reach the beginning of the array, we will jump to the last element to continue the movement.\n\n  Write a method to determine if the array has a cycle. The cycle should have more than one element and should follow one direction which means the cycle should not contain both forward and backward movements.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"circular_array_loop_exists([1, 2, -1, 2, 2]);",expected:!0},{id:2,name:"example 2",inherit:[],code:"",evaluate:"circular_array_loop_exists([2, 2, -1, 2]);",expected:!0},{id:3,name:"example 3",inherit:[],code:"",evaluate:"circular_array_loop_exists([2, 1, -1, -2]);",expected:!1}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/NE67J9YMj3m"],tags:[w,d],solution:[{stage:0,text:""},{stage:0,text:"function circular_array_loop_exists(arr) {"},{stage:1,text:"  for (let i = 0; i < arr.length; i++) {"},{stage:2,text:"    let isForward = arr[i] >= 0;"},{stage:2,text:"    let slow = i;"},{stage:2,text:"    let fast = i;"},{stage:0,text:""},{stage:3,text:"    while (true) {"},{stage:4,text:"      slow = find_next_index(arr, isForward, slow);"},{stage:4,text:"      fast = find_next_index(arr, isForward, fast);"},{stage:0,text:""},{stage:12,text:"      if (fast !== -1) {"},{stage:12,text:"        fast = find_next_index(arr, isForward, fast);"},{stage:12,text:"      }"},{stage:0,text:""},{stage:13,text:"      if (slow === -1 || fast === -1 || slow === fast) {"},{stage:13,text:"        break;"},{stage:13,text:"      }"},{stage:3,text:"    }"},{stage:0,text:""},{stage:14,text:"    if (slow !== -1 && slow === fast) {"},{stage:14,text:"      return true;"},{stage:14,text:"    }"},{stage:1,text:"  }"},{stage:0,text:""},{stage:15,text:"  return false;"},{stage:0,text:"}"},{stage:0,text:""},{stage:5,text:"function find_next_index(arr, isForward, currentIndex) {"},{stage:6,text:"  let direction = arr[currentIndex] >= 0;"},{stage:0,text:""},{stage:7,text:"  if (isForward !== direction) {"},{stage:7,text:"    return -1;"},{stage:7,text:"  }"},{stage:0,text:""},{stage:8,text:"  let nextIndex = (currentIndex + arr[currentIndex]) % arr.length;"},{stage:9,text:"  if (nextIndex < 0) {"},{stage:9,text:"    nextIndex += arr.length;"},{stage:9,text:"  }"},{stage:0,text:""},{stage:10,text:"  if (nextIndex === currentIndex) {"},{stage:10,text:"    nextIndex = -1;"},{stage:10,text:"  }"},{stage:0,text:""},{stage:11,text:"  return nextIndex;"},{stage:5,text:"}"},{stage:0,text:""}]},137:{problemID:137,problemName:"Intervals Intersection",problemText:"Given two lists of intervals, find the intersection of these two lists. Each list consists of disjoint intervals sorted on their start time.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"mapInterval(merge(\n        [new Interval(1, 3), new Interval(5, 6), new Interval(7, 9)],\n        [new Interval(2, 3), new Interval(5, 7)],\n      ));",expected:JSON.stringify([[2,3],[5,6],[7,7]])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"mapInterval(merge(\n            [new Interval(1, 3), new Interval(5, 7), new Interval(9, 12)],\n            [new Interval(5, 10)],\n          ));",expected:JSON.stringify([[5,7],[9,10]])}],setupCode:"\n  class Interval {\n    constructor(start, end) {\n      this.start = start;\n      this.end = end;\n    }\n  }\n  \nfunction mapInterval(intervals) {\n    return intervals.map(i => {\n      return [i.start, i.end];\n    });\n  }\n  ",source:["https://www.educative.io/courses/grokking-the-coding-interview/JExVVqRAN9D"],tags:["Merge Intervals",d],solution:[{stage:0,text:""},{stage:-1,text:"class Interval {"},{stage:-1,text:"  constructor(start, end) {"},{stage:-1,text:"    this.start = start;"},{stage:-1,text:"    this.end = end;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function merge(intervals_a, intervals_b) {"},{stage:1,text:"  let result = [];"},{stage:1,text:"  let i = 0;"},{stage:1,text:"  let j = 0;"},{stage:0,text:""},{stage:2,text:"  while (i < intervals_a.length && j < intervals_b.length) {"},{stage:3,text:"    let a_overlaps_b ="},{stage:3,text:"      intervals_a[i].start >= intervals_b[j].start && intervals_a[i].start <= intervals_b[j].end;"},{stage:0,text:""},{stage:4,text:"    let b_overlaps_a ="},{stage:4,text:"      intervals_b[j].start >= intervals_a[i].start && intervals_b[j].start <= intervals_a[i].end;"},{stage:0,text:""},{stage:5,text:"    if (a_overlaps_b || b_overlaps_a) {"},{stage:6,text:"      result.push("},{stage:6,text:"        new Interval("},{stage:6,text:"          Math.max(intervals_a[i].start, intervals_b[j].start),"},{stage:6,text:"          Math.min(intervals_a[i].end, intervals_b[j].end)"},{stage:6,text:"        )"},{stage:6,text:"      );"},{stage:5,text:"    }"},{stage:0,text:""},{stage:7,text:"    if (intervals_a[i].end < intervals_b[j].end) {"},{stage:8,text:"      i += 1;"},{stage:7,text:"    } else {"},{stage:8,text:"      j += 1;"},{stage:7,text:"    }"},{stage:2,text:"  }"},{stage:0,text:""},{stage:9,text:"  return result;"},{stage:0,text:"}"},{stage:0,text:""}]},138:{problemID:138,problemName:"Conflicting Appointments",problemText:"Given an array of intervals representing \u2018N\u2019 appointments, find out if a person can attend all the appointments.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"can_attend_all_appointments([\n        new Interval(1, 4),\n        new Interval(2, 5),\n        new Interval(7, 9),\n      ]);",expected:!1},{id:2,name:"example 2",inherit:[],code:"",evaluate:"can_attend_all_appointments([\n        new Interval(6, 7),\n        new Interval(2, 4),\n        new Interval(8, 12),\n      ]);",expected:!0},{id:3,name:"example 3",inherit:[],code:"",evaluate:"can_attend_all_appointments([\n        new Interval(4, 5),\n        new Interval(2, 3),\n        new Interval(3, 6),\n      ]);",expected:!1}],setupCode:"class Interval {\n    constructor(start, end) {\n      this.start = start;\n      this.end = end;\n    }\n  }",source:["https://www.educative.io/courses/grokking-the-coding-interview/qVV79nGVgAG"],tags:["Merge Intervals",d],solution:[{stage:0,text:""},{stage:-1,text:"class Interval {"},{stage:-1,text:"  constructor(start, end) {"},{stage:-1,text:"    this.start = start;"},{stage:-1,text:"    this.end = end;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function can_attend_all_appointments(intervals) {"},{stage:1,text:"  intervals.sort((a, b) => a.start - b.start);"},{stage:0,text:""},{stage:2,text:"  for (let i = 1; i < intervals.length; i++) {"},{stage:3,text:"    if (intervals[i].start < intervals[i - 1].end) {"},{stage:4,text:"      return false;"},{stage:3,text:"    }"},{stage:2,text:"  }"},{stage:5,text:"  return true;"},{stage:0,text:"}"},{stage:0,text:""}]},139:{problemID:139,problemName:"Minimum Meeting Rooms",problemText:"Given a list of intervals representing the start and end time of \u2018N\u2019 meetings, find the minimum number of rooms required to hold all the meetings.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"min_meeting_rooms([new Meeting(1, 4), new Meeting(2, 5), new Meeting(7, 9)]);",expected:2},{id:2,name:"example 2",inherit:[],code:"",evaluate:"min_meeting_rooms([new Meeting(6, 7), new Meeting(2, 4), new Meeting(8, 12)]);",expected:1},{id:3,name:"example 3",inherit:[],code:"",evaluate:"min_meeting_rooms([new Meeting(1, 4), new Meeting(2, 3), new Meeting(3, 6)]);",expected:2},{id:4,name:"example 4",inherit:[],code:"",evaluate:"min_meeting_rooms([\n        new Meeting(4, 5),\n        new Meeting(2, 3),\n        new Meeting(2, 4),\n        new Meeting(3, 5),\n      ]);",expected:2}],setupCode:"\n  ".concat(G,"\n  class Meeting {\n    constructor(start, end) {\n      this.start = start;\n      this.end = end;\n    }\n  }\n  "),source:["https://www.educative.io/courses/grokking-the-coding-interview/JQMAmrVPL7l"],tags:["Merge Intervals",d],solution:[{stage:0,text:""},{stage:-1,text:"class Meeting {"},{stage:-1,text:"  constructor(start, end) {"},{stage:-1,text:"    this.start = start;"},{stage:-1,text:"    this.end = end;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function min_meeting_rooms(meetings) {"},{stage:1,text:"  meetings.sort((a, b) => a.start - b.start);"},{stage:2,text:"  let minRooms = 0;"},{stage:2,text:"  let minHeap = new Heap((a, b) => a.end <= b.end);"},{stage:0,text:""},{stage:3,text:"  for (let i = 0; i < meetings.length; i++) {"},{stage:4,text:"    while (minHeap.length() > 0 && meetings[i].start >= minHeap.peek().end) {"},{stage:5,text:"      minHeap.poll();"},{stage:4,text:"    }"},{stage:0,text:""},{stage:6,text:"    minHeap.add(meetings[i]);"},{stage:7,text:"    minRooms = Math.max(minRooms, minHeap.length());"},{stage:3,text:"  }"},{stage:8,text:"  return minRooms;"},{stage:0,text:"}"},{stage:0,text:""}]},140:{problemID:140,problemName:"Maximum CPU Load",problemText:"We are given a list of Jobs. Each job has a Start time, an End time, and a CPU load when it is running. Our goal is to find the maximum CPU load at any time if all the jobs are running on the same machine.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_max_cpu_load([new Job(1, 4, 3), new Job(2, 5, 4), new Job(7, 9, 6)]);",expected:7},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_max_cpu_load([new Job(6, 7, 10), new Job(2, 4, 11), new Job(8, 12, 15)]);",expected:15},{id:3,name:"example 3",inherit:[],code:"",evaluate:"find_max_cpu_load([new Job(1, 4, 2), new Job(2, 4, 1), new Job(3, 6, 5)]);",expected:8}],setupCode:"\n  ".concat(G,"\n  class Job {\n    constructor(start, end, cpuLoad) {\n      this.start = start;\n      this.end = end;\n      this.cpuLoad = cpuLoad;\n    }\n  }\n  "),source:["https://www.educative.io/courses/grokking-the-coding-interview/YVwln9kYxV2"],tags:["Merge Intervals",d],solution:[{stage:0,text:""},{stage:-1,text:"class Job {"},{stage:-1,text:"  constructor(start, end, cpuLoad) {"},{stage:-1,text:"    this.start = start;"},{stage:-1,text:"    this.end = end;"},{stage:-1,text:"    this.cpuLoad = cpuLoad;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function find_max_cpu_load(jobs) {"},{stage:1,text:"  jobs.sort((a, b) => a.start - b.start);"},{stage:0,text:""},{stage:2,text:"  let maxCPULoad = 0;"},{stage:2,text:"  let currentCPULoad = 0;"},{stage:3,text:"  const minHeap = new Heap((a, b) => a.end <= b.end);"},{stage:0,text:""},{stage:4,text:"  for (let j = 0; j < jobs.length; j++) {"},{stage:5,text:"    while (minHeap.length() > 0 && jobs[j].start >= minHeap.peek().end) {"},{stage:6,text:"      currentCPULoad -= minHeap.poll().cpuLoad;"},{stage:5,text:"    }"},{stage:0,text:""},{stage:7,text:"    minHeap.add(jobs[j]);"},{stage:8,text:"    currentCPULoad += jobs[j].cpuLoad;"},{stage:9,text:"    maxCPULoad = Math.max(maxCPULoad, currentCPULoad);"},{stage:4,text:"  }"},{stage:0,text:""},{stage:10,text:"  return maxCPULoad;"},{stage:0,text:"}"},{stage:0,text:""}]},141:{problemID:141,problemName:"Employee Free Time",problemText:"For \u2018K\u2019 employees, we are given a list of intervals representing the working hours of each employee. Our goal is to find out if there is a free interval that is common to all employees. You can assume that each list of employee working hours is sorted on the start time.",testCases:[{id:1,name:"example 1",inherit:[],code:"let input = [\n        [new Interval(1, 3), new Interval(5, 6)],\n        [new Interval(2, 3), new Interval(6, 8)],\n      ];",evaluate:"mapInterval(find_employee_free_time(input));",expected:JSON.stringify([[3,5]])},{id:2,name:"example 2",inherit:[],code:"let input = [[new Interval(1, 3), new Interval(9, 12)], [new Interval(2, 4)], [new Interval(6, 8)]];",evaluate:"mapInterval(find_employee_free_time(input));",expected:JSON.stringify([[4,6],[8,9]])},{id:3,name:"example 3",inherit:[],code:"let input = [[new Interval(1, 3)], [new Interval(2, 4)], [new Interval(3, 5), new Interval(7, 9)]];",evaluate:"mapInterval(find_employee_free_time(input));",expected:JSON.stringify([[5,7]])}],setupCode:"\n  ".concat(G,"\n  class Interval {\n    constructor(start, end) {\n      this.start = start;\n      this.end = end;\n    }\n  }\n  class EmployeeInterval {\n    constructor(interval, employeeIndex, intervalIndex) {\n      this.interval = interval;\n      this.employeeIndex = employeeIndex;\n      this.intervalIndex = intervalIndex;\n    }\n  }\n  function mapInterval(intervals) {\n    return intervals.map(i => {\n      return [i.start, i.end];\n    });\n  }\n  "),source:["https://www.educative.io/courses/grokking-the-coding-interview/RLwKZWgMJ1q"],tags:["Merge Intervals",d],solution:[{stage:0,text:""},{stage:-1,text:"class Interval {"},{stage:-1,text:"  constructor(start, end) {"},{stage:-1,text:"    this.start = start;"},{stage:-1,text:"    this.end = end;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:-1,text:"class EmployeeInterval {"},{stage:-1,text:"  constructor(interval, employeeIndex, intervalIndex) {"},{stage:-1,text:"    this.interval = interval;"},{stage:-1,text:"    this.employeeIndex = employeeIndex;"},{stage:-1,text:"    this.intervalIndex = intervalIndex;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function find_employee_free_time(schedule) {"},{stage:1,text:"  let n = schedule.length;"},{stage:1,text:"  let result = [];"},{stage:2,text:"  if (schedule === null || n === 0) {"},{stage:2,text:"    return result;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:3,text:"  let minHeap = new Heap((a, b) => a.interval.start <= b.interval.start);"},{stage:4,text:"  for (let i = 0; i < n; i++) {"},{stage:5,text:"    minHeap.add(new EmployeeInterval(schedule[i][0], i, 0));"},{stage:4,text:"  }"},{stage:0,text:""},{stage:6,text:"  let previousInterval = minHeap.peek().interval;"},{stage:7,text:"  while (minHeap.length() > 0) {"},{stage:8,text:"    const queueTop = minHeap.poll();"},{stage:9,text:"    if (previousInterval.end < queueTop.interval.start) {"},{stage:10,text:"      result.push(new Interval(previousInterval.end, queueTop.interval.start));"},{stage:11,text:"      previousInterval = queueTop.interval;"},{stage:9,text:"    } else {"},{stage:12,text:"      if (previousInterval.end < queueTop.interval.end) {"},{stage:13,text:"        previousInterval = queueTop.interval;"},{stage:12,text:"      }"},{stage:9,text:"    }"},{stage:0,text:""},{stage:14,text:"    const employeeSchedule = schedule[queueTop.employeeIndex];"},{stage:15,text:"    if (employeeSchedule.length > queueTop.intervalIndex + 1) {"},{stage:16,text:"      minHeap.add("},{stage:16,text:"        new EmployeeInterval("},{stage:16,text:"          employeeSchedule[queueTop.intervalIndex + 1],"},{stage:16,text:"          queueTop.employeeIndex,"},{stage:16,text:"          queueTop.intervalIndex + 1"},{stage:16,text:"        )"},{stage:16,text:"      );"},{stage:15,text:"    }"},{stage:7,text:"  }"},{stage:0,text:""},{stage:17,text:"  return result;"},{stage:0,text:"}"},{stage:0,text:""}]},142:{problemID:142,problemName:"Reverse Every K Element Sublist",problemText:"Given the head of a LinkedList and a number \u2018k\u2019, reverse every \u2018k\u2019 sized sub-list starting from the head.\n\n  If, in the end, you are left with a sub-list with less than \u2018k\u2019 elements, reverse it too.",testCases:[{id:1,name:"example 1",inherit:[],code:"const head = new Node(1);\n      head.next = new Node(2);\n      head.next.next = new Node(3);\n      head.next.next.next = new Node(4);\n      head.next.next.next.next = new Node(5);\n      head.next.next.next.next.next = new Node(6);\n      head.next.next.next.next.next.next = new Node(7);\n      head.next.next.next.next.next.next.next = new Node(8);",evaluate:"reverse_every_k_elements(head, 3).convert();",expected:JSON.stringify([3,2,1,6,5,4,8,7])}],setupCode:"\n  class Node {\n    constructor(value, next = null) {\n      this.value = value;\n      this.next = next;\n    }\n  }\n  Node.prototype.convert = function () {\n    const arr = [];\n    let node = this;\n    while (node) {\n      arr.push(node.value);\n      node = node.next;\n    }\n    return arr;\n  };\n  ",source:["https://www.educative.io/courses/grokking-the-coding-interview/RMZylvkGznR"],tags:[c,d],solution:[{stage:0,text:""},{stage:-1,text:"class Node {"},{stage:-1,text:"  constructor(value, next = null) {"},{stage:-1,text:"    this.value = value;"},{stage:-1,text:"    this.next = next;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function reverse_every_k_elements(head, k) {"},{stage:1,text:"  if (k <= 1 || head === null) {"},{stage:2,text:"    return head;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:3,text:"  let current = head;"},{stage:3,text:"  let previous = null;"},{stage:4,text:"  while (true) {"},{stage:5,text:"    const last_node_of_previous_part = previous;"},{stage:5,text:"    const last_node_of_sub_list = current;"},{stage:6,text:"    let next = null;"},{stage:6,text:"    let i = 0;"},{stage:7,text:"    while (current !== null && i < k) {"},{stage:8,text:"      next = current.next;"},{stage:8,text:"      current.next = previous;"},{stage:9,text:"      previous = current;"},{stage:9,text:"      current = next;"},{stage:10,text:"      i += 1;"},{stage:7,text:"    }"},{stage:0,text:""},{stage:11,text:"    if (last_node_of_previous_part !== null) {"},{stage:12,text:"      last_node_of_previous_part.next = previous;"},{stage:11,text:"    } else {"},{stage:13,text:"      head = previous;"},{stage:11,text:"    }"},{stage:0,text:""},{stage:14,text:"    last_node_of_sub_list.next = current;"},{stage:0,text:""},{stage:15,text:"    if (current === null) {"},{stage:16,text:"      break;"},{stage:15,text:"    }"},{stage:17,text:"    previous = last_node_of_sub_list;"},{stage:4,text:"  }"},{stage:0,text:""},{stage:18,text:"  return head;"},{stage:0,text:"}"},{stage:0,text:""}]},143:{problemID:143,problemName:"Reverse alternating K-element Sub-list",problemText:"Given the head of a LinkedList and a number \u2018k\u2019, reverse every alternating \u2018k\u2019 sized sub-list starting from the head.\n\n  If, in the end, you are left with a sub-list with less than \u2018k\u2019 elements, reverse it too.",testCases:[{id:1,name:"example 1",inherit:[],code:"const head = new Node(1);\n      head.next = new Node(2);\n      head.next.next = new Node(3);\n      head.next.next.next = new Node(4);\n      head.next.next.next.next = new Node(5);\n      head.next.next.next.next.next = new Node(6);\n      head.next.next.next.next.next.next = new Node(7);\n      head.next.next.next.next.next.next.next = new Node(8);",evaluate:"reverse_alternate_k_elements(head, 2).convert();",expected:JSON.stringify([2,1,3,4,6,5,7,8])}],setupCode:"\n  class Node {\n    constructor(value, next = null) {\n      this.value = value;\n      this.next = next;\n    }\n  }\n  \n  Node.prototype.convert = function () {\n    const arr = [];\n    let node = this;\n    while (node) {\n      arr.push(node.value);\n      node = node.next;\n    }\n    return arr;\n  };\n  ",source:["https://www.educative.io/courses/grokking-the-coding-interview/q2lZKgLm980"],tags:[c,d],solution:[{stage:0,text:""},{stage:-1,text:"class Node {"},{stage:-1,text:"  constructor(value, next = null) {"},{stage:-1,text:"    this.value = value;"},{stage:-1,text:"    this.next = next;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function reverse_alternate_k_elements(head, k) {"},{stage:1,text:"  if (k <= 1 || head === null) {"},{stage:2,text:"    return head;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:3,text:"  let current = head;"},{stage:3,text:"  let previous = null;"},{stage:0,text:""},{stage:4,text:"  while (current !== null) {"},{stage:5,text:"    const last_node_of_previous_part = previous;"},{stage:5,text:"    const last_node_of_sub_list = current;"},{stage:6,text:"    let next = null;"},{stage:0,text:""},{stage:7,text:"    let i = 0;"},{stage:8,text:"    while (current !== null && i < k) {"},{stage:9,text:"      next = current.next;"},{stage:9,text:"      current.next = previous;"},{stage:10,text:"      previous = current;"},{stage:10,text:"      current = next;"},{stage:11,text:"      i += 1;"},{stage:8,text:"    }"},{stage:0,text:""},{stage:12,text:"    if (last_node_of_previous_part !== null) {"},{stage:13,text:"      last_node_of_previous_part.next = previous;"},{stage:12,text:"    } else {"},{stage:14,text:"      head = previous;"},{stage:12,text:"    }"},{stage:0,text:""},{stage:15,text:"    last_node_of_sub_list.next = current;"},{stage:0,text:""},{stage:16,text:"    i = 0;"},{stage:17,text:"    while (current !== null && i < k) {"},{stage:18,text:"      previous = current;"},{stage:18,text:"      current = current.next;"},{stage:19,text:"      i += 1;"},{stage:17,text:"    }"},{stage:4,text:"  }"},{stage:0,text:""},{stage:20,text:"  return head;"},{stage:0,text:"}"},{stage:0,text:""}]},144:{problemID:144,problemName:"Rotate a Linked List",problemText:"Given the head of a Singly LinkedList and a number \u2018k\u2019, rotate the LinkedList to the right by \u2018k\u2019 nodes.",testCases:[{id:1,name:"example 1",inherit:[],code:"const head = new Node(1);\n      head.next = new Node(2);\n      head.next.next = new Node(3);\n      head.next.next.next = new Node(4);\n      head.next.next.next.next = new Node(5);\n      head.next.next.next.next.next = new Node(6);",evaluate:"rotate(head, 3).convert();",expected:JSON.stringify([4,5,6,1,2,3])}],setupCode:"\n  class Node {\n    constructor(value, next = null) {\n      this.value = value;\n      this.next = next;\n    }\n  }\n  \n  Node.prototype.convert = function () {\n    const arr = [];\n    let node = this;\n    while (node) {\n      arr.push(node.value);\n      node = node.next;\n    }\n    return arr;\n  };\n  ",source:["https://www.educative.io/courses/grokking-the-coding-interview/mErolRNQ00R"],tags:[c,d],solution:[{stage:0,text:""},{stage:-1,text:"class Node {"},{stage:-1,text:"  constructor(value, next = null) {"},{stage:-1,text:"    this.value = value;"},{stage:-1,text:"    this.next = next;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function rotate(head, rotations) {"},{stage:1,text:"  if (head === null || head.next === null || rotations <= 0) {"},{stage:2,text:"    return head;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:3,text:"  let last_node = head;"},{stage:3,text:"  let list_length = 1;"},{stage:4,text:"  while (last_node.next !== null) {"},{stage:5,text:"    last_node = last_node.next;"},{stage:5,text:"    list_length += 1;"},{stage:4,text:"  }"},{stage:0,text:""},{stage:6,text:"  last_node.next = head;"},{stage:6,text:"  rotations %= list_length;"},{stage:7,text:"  let skip_length = list_length - rotations;"},{stage:7,text:"  let last_node_of_rotated_list = head;"},{stage:8,text:"  for (let i = 0; i < skip_length - 1; i++) {"},{stage:9,text:"    last_node_of_rotated_list = last_node_of_rotated_list.next;"},{stage:8,text:"  }"},{stage:0,text:""},{stage:10,text:"  head = last_node_of_rotated_list.next;"},{stage:11,text:"  last_node_of_rotated_list.next = null;"},{stage:12,text:"  return head;"},{stage:0,text:"}"},{stage:0,text:""}]},145:{problemID:145,problemName:"Zigzag Traversal",problemText:"Given a binary tree, populate an array to represent its zigzag level order traversal. You should populate the values of all nodes of the first level from left to right, then right to left for the next level and keep alternating in the same manner for the following levels.  The return array should be an array of arrays, with each tree level represented by an array.",testCases:[{id:1,name:"example 1",inherit:[],code:"const root = new TreeNode(12);\n      root.left = new TreeNode(7);\n      root.right = new TreeNode(1);\n      root.left.left = new TreeNode(9);\n      root.right.left = new TreeNode(10);\n      root.right.right = new TreeNode(5);\n      root.right.left.left = new TreeNode(20);\n      root.right.left.right = new TreeNode(17);",evaluate:"traverse(root);",expected:JSON.stringify([[12],[1,7],[9,10,5],[17,20]])}],setupCode:"\n  class TreeNode {\n    constructor(val) {\n      this.val = val;\n      this.left = null;\n      this.right = null;\n    }\n  }\n  ",source:["https://www.educative.io/courses/grokking-the-coding-interview/qVA27MMYYn0"],tags:[h,d],solution:[{stage:0,text:""},{stage:-1,text:"class TreeNode {"},{stage:-1,text:"  constructor(val) {"},{stage:-1,text:"    this.val = val;"},{stage:-1,text:"    this.left = null;"},{stage:-1,text:"    this.right = null;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function traverse(root) {"},{stage:1,text:"  const result = [];"},{stage:2,text:"  if (root === null) {"},{stage:3,text:"    return result;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:4,text:"  const queue = [];"},{stage:4,text:"  queue.push(root);"},{stage:5,text:"  let leftToRight = true;"},{stage:6,text:"  while (queue.length > 0) {"},{stage:7,text:"    let levelSize = queue.length;"},{stage:7,text:"    let currentLevel = [];"},{stage:8,text:"    for (let i = 0; i < levelSize; i++) {"},{stage:9,text:"      let currentNode = queue.shift();"},{stage:10,text:"      if (leftToRight) {"},{stage:11,text:"        currentLevel.push(currentNode.val);"},{stage:10,text:"      } else {"},{stage:12,text:"        currentLevel.unshift(currentNode.val);"},{stage:10,text:"      }"},{stage:0,text:""},{stage:13,text:"      if (currentNode.left !== null) {"},{stage:14,text:"        queue.push(currentNode.left);"},{stage:13,text:"      }"},{stage:15,text:"      if (currentNode.right !== null) {"},{stage:16,text:"        queue.push(currentNode.right);"},{stage:15,text:"      }"},{stage:8,text:"    }"},{stage:0,text:""},{stage:17,text:"    result.push(currentLevel);"},{stage:17,text:"    leftToRight = !leftToRight;"},{stage:6,text:"  }"},{stage:0,text:""},{stage:18,text:"  return result;"},{stage:0,text:"}"},{stage:0,text:""}]},146:{problemID:146,problemName:"Connect Level Order Siblings",problemText:"Given a binary tree, connect each node with its level order successor. The last node of each level should point to a null node.",testCases:[{id:1,name:"example 1",inherit:[],code:"const root = new TreeNode(12);\n      root.left = new TreeNode(7);\n      root.right = new TreeNode(1);\n      root.left.left = new TreeNode(9);\n      root.right.left = new TreeNode(10);\n      root.right.right = new TreeNode(5);\n      connect_level_order_siblings(root);",evaluate:"printLevelOrder(root);",expected:JSON.stringify([[12],[7,1],[9,10,5]])}],setupCode:"\n  class TreeNode {\n    constructor(val) {\n      this.val = val;\n      this.left = null;\n      this.right = null;\n      this.next = null;\n    }\n  }\n  \n  function printLevelOrder(root) {\n    const arr = [];\n    let nextLevelRoot = root;\n    while (nextLevelRoot !== null) {\n      let temp = [];\n      let current = nextLevelRoot;\n      nextLevelRoot = null;\n      while (current != null) {\n        temp.push(current.val);\n        if (nextLevelRoot === null) {\n          if (current.left !== null) {\n            nextLevelRoot = current.left;\n          } else if (current.right !== null) {\n            nextLevelRoot = current.right;\n          }\n        }\n        current = current.next;\n      }\n      arr.push(temp);\n    }\n    return arr;\n  }\n  ",source:["https://www.educative.io/courses/grokking-the-coding-interview/m2YYxXDOJ03"],tags:[h,d],solution:[{stage:0,text:""},{stage:-1,text:"class TreeNode {"},{stage:-1,text:"  constructor(val) {"},{stage:-1,text:"    this.val = val;"},{stage:-1,text:"    this.left = null;"},{stage:-1,text:"    this.right = null;"},{stage:-1,text:"    this.next = null;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function connect_level_order_siblings(root) {"},{stage:1,text:"  if (root === null) {"},{stage:2,text:"    return;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:3,text:"  const queue = [];"},{stage:3,text:"  queue.push(root);"},{stage:4,text:"  while (queue.length > 0) {"},{stage:5,text:"    let previousNode = null;"},{stage:5,text:"    let levelSize = queue.length;"},{stage:0,text:""},{stage:6,text:"    for (let i = 0; i < levelSize; i++) {"},{stage:7,text:"      let currentNode = queue.shift();"},{stage:8,text:"      if (previousNode !== null) {"},{stage:9,text:"        previousNode.next = currentNode;"},{stage:8,text:"      }"},{stage:0,text:""},{stage:10,text:"      previousNode = currentNode;"},{stage:11,text:"      if (currentNode.left !== null) {"},{stage:12,text:"        queue.push(currentNode.left);"},{stage:11,text:"      }"},{stage:13,text:"      if (currentNode.right !== null) {"},{stage:14,text:"        queue.push(currentNode.right);"},{stage:13,text:"      }"},{stage:0,text:""},{stage:6,text:"    }"},{stage:4,text:"  }"},{stage:0,text:"}"},{stage:0,text:""}]},147:{problemID:147,problemName:"Connect All Level Order Siblings",problemText:"Given a binary tree, connect each node with its level order successor. The last node of each level should point to the first node of the next level.",testCases:[{id:1,name:"example 1",inherit:[],code:"const root = new TreeNode(12);\n      root.left = new TreeNode(7);\n      root.right = new TreeNode(1);\n      root.left.left = new TreeNode(9);\n      root.right.left = new TreeNode(10);\n      root.right.right = new TreeNode(5);\n      connect_all_siblings(root);",evaluate:"printTree(root);",expected:JSON.stringify([12,7,1,9,10,5])}],setupCode:"\n  class TreeNode {\n    constructor(val) {\n      this.val = val;\n      this.left = null;\n      this.right = null;\n      this.next = null;\n    }\n  }\n  \n  function printTree(root) {\n    const arr = [];\n    let current = root;\n    while (current !== null) {\n      arr.push(current.val);\n      current = current.next;\n    }\n    return arr;\n  }\n  ",source:["https://www.educative.io/courses/grokking-the-coding-interview/qVxy1qop77p"],tags:[h,d],solution:[{stage:0,text:""},{stage:-1,text:"class TreeNode {"},{stage:-1,text:"  constructor(val) {"},{stage:-1,text:"    this.val = val;"},{stage:-1,text:"    this.left = null;"},{stage:-1,text:"    this.right = null;"},{stage:-1,text:"    this.next = null;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function connect_all_siblings(root) {"},{stage:1,text:"  if (root === null) {"},{stage:2,text:"    return;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:3,text:"  const queue = [];"},{stage:3,text:"  queue.push(root);"},{stage:4,text:"  let currentNode = null;"},{stage:4,text:"  let previousNode = null;"},{stage:0,text:""},{stage:5,text:"  while (queue.length > 0) {"},{stage:6,text:"    currentNode = queue.shift();"},{stage:7,text:"    if (previousNode !== null) {"},{stage:8,text:"      previousNode.next = currentNode;"},{stage:7,text:"    }"},{stage:0,text:""},{stage:9,text:"    previousNode = currentNode;"},{stage:10,text:"    if (currentNode.left !== null) {"},{stage:11,text:"      queue.push(currentNode.left);"},{stage:10,text:"    }"},{stage:12,text:"    if (currentNode.right !== null) {"},{stage:13,text:"      queue.push(currentNode.right);"},{stage:12,text:"    }"},{stage:5,text:"  }"},{stage:0,text:"}"},{stage:0,text:""}]},148:{problemID:148,problemName:"Right View of a Binary Tree",problemText:"Given a binary tree, return an array containing nodes in its right view. The right view of a binary tree is the set of nodes visible when the tree is seen from the right side.",testCases:[{id:1,name:"example 1",inherit:[],code:"const root = new TreeNode(12);\n      root.left = new TreeNode(7);\n      root.right = new TreeNode(1);\n      root.left.left = new TreeNode(9);\n      root.right.left = new TreeNode(10);\n      root.right.right = new TreeNode(5);\n      root.left.left.left = new TreeNode(3);",evaluate:"printRight(tree_right_view(root));",expected:JSON.stringify([12,1,5,3])}],setupCode:"\n  class TreeNode {\n    constructor(val) {\n      this.val = val;\n      this.left = null;\n      this.right = null;\n    }\n  }\n  function printRight(result) {\n    const arr = [];\n    for (let i = 0; i < result.length; i++) {\n      arr.push(result[i].val);\n    }\n    return arr;\n  }\n  ",source:["https://www.educative.io/courses/grokking-the-coding-interview/gxVWnvZjMn9"],tags:[h,d],solution:[{stage:0,text:""},{stage:-1,text:"class TreeNode {"},{stage:-1,text:"  constructor(val) {"},{stage:-1,text:"    this.val = val;"},{stage:-1,text:"    this.left = null;"},{stage:-1,text:"    this.right = null;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function tree_right_view(root) {"},{stage:1,text:"  let result = [];"},{stage:2,text:"  if (root === null) {"},{stage:3,text:"    return result;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:4,text:"  const queue = [];"},{stage:4,text:"  queue.push(root);"},{stage:5,text:"  while (queue.length > 0) {"},{stage:6,text:"    const levelSize = queue.length;"},{stage:7,text:"    for (let i = 0; i < levelSize; i++) {"},{stage:8,text:"      let currentNode = queue.shift();"},{stage:0,text:""},{stage:9,text:"      if (i === levelSize - 1) {"},{stage:10,text:"        result.push(currentNode);"},{stage:9,text:"      }"},{stage:0,text:""},{stage:11,text:"      if (currentNode.left !== null) {"},{stage:12,text:"        queue.push(currentNode.left);"},{stage:11,text:"      }"},{stage:0,text:""},{stage:13,text:"      if (currentNode.right !== null) {"},{stage:14,text:"        queue.push(currentNode.right);"},{stage:13,text:"      }"},{stage:7,text:"    }"},{stage:5,text:"  }"},{stage:0,text:""},{stage:15,text:"  return result;"},{stage:0,text:"}"},{stage:0,text:""}]},149:{problemID:149,problemName:"All Paths for a Sum",problemText:"Given a binary tree `root` and a number `sum`, find all paths **from root-to-leaf** such that the sum of all the node values of each path equals `sum`.",testCases:[{id:1,name:"example 1",inherit:[],code:"const root = new TreeNode(12);\n      root.left = new TreeNode(7);\n      root.right = new TreeNode(1);\n      root.left.left = new TreeNode(4);\n      root.right.left = new TreeNode(10);\n      root.right.right = new TreeNode(5);",evaluate:"printPaths(find_paths(root, 23));",expected:JSON.stringify([[12,7,4],[12,1,10]])}],setupCode:"\n  class TreeNode {\n    constructor(val, left = null, right = null) {\n      this.val = val;\n      this.left = left;\n      this.right = right;\n    }\n  }\n\n  function printPaths(result) {\n    const arr = [];\n    for (let i = 0; i < result.length; i++) {\n      arr.push(result[i]);\n    }\n    return arr;\n  }\n  ",source:["https://www.educative.io/courses/grokking-the-coding-interview/B815A0y2Ajn"],tags:[f,d,"Recursion",h],solution:[{stage:0,text:""},{stage:-1,text:"class TreeNode {"},{stage:-1,text:"  constructor(val, left = null, right = null) {"},{stage:-1,text:"    this.val = val;"},{stage:-1,text:"    this.left = left;"},{stage:-1,text:"    this.right = right;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function find_paths(root, sum) {"},{stage:1,text:"  const allPaths = [];"},{stage:2,text:"  find_paths_recursive(root, sum, [], allPaths);"},{stage:0,text:""},{stage:3,text:"  return allPaths;"},{stage:0,text:"}"},{stage:0,text:""},{stage:4,text:"function find_paths_recursive(currentNode, sum, currentPath, allPaths) {"},{stage:5,text:"  if (currentNode === null) {"},{stage:6,text:"    return;"},{stage:5,text:"  }"},{stage:0,text:""},{stage:-7,text:"  // add node to current path"},{stage:7,text:"  currentPath.push(currentNode.val);"},{stage:0,text:""},{stage:-8,text:"  // the question looks for root to LEAF.  So only continue if its a leaf (no right and left)"},{stage:8,text:"  if (currentNode.val === sum && currentNode.left === null && currentNode.right === null) {"},{stage:-9,text:"    // found a match.  add the current path to the list of all paths."},{stage:9,text:"    allPaths.push(JSON.parse(JSON.stringify(currentPath)));"},{stage:8,text:"  } else {"},{stage:-10,text:"    // no match (or not a leaf) explore left and right subtrees"},{stage:10,text:"    find_paths_recursive(currentNode.left, sum - currentNode.val, currentPath, allPaths);"},{stage:11,text:"    find_paths_recursive(currentNode.right, sum - currentNode.val, currentPath, allPaths);"},{stage:8,text:"  }"},{stage:0,text:""},{stage:-12,text:"  // remove the node from the path for backtracking"},{stage:12,text:"  currentPath.pop();"},{stage:4,text:"}"},{stage:0,text:""}]},150:{problemID:150,problemName:"Sum of Path Numbers",problemText:"Given a binary tree where each node can only have a digit (0-9) value, each **root-to-leaf** path will represent a number. Find the total sum of all the numbers represented by all paths.",testCases:[{id:1,name:"example 1",inherit:[],code:"const root = new TreeNode(1);\n      root.left = new TreeNode(0);\n      root.right = new TreeNode(1);\n      root.left.left = new TreeNode(1);\n      root.right.left = new TreeNode(6);\n      root.right.right = new TreeNode(5);",evaluate:"find_sum_of_path_numbers(root);",expected:332}],setupCode:"\n  class TreeNode {\n    constructor(val, left = null, right = null) {\n      this.val = val;\n      this.left = left;\n      this.right = right;\n    }\n  }\n  ",source:["https://www.educative.io/courses/grokking-the-coding-interview/YQ5o5vEXP69"],tags:[f,d,"Recursion",h],solution:[{stage:0,text:""},{stage:-1,text:"class TreeNode {"},{stage:-1,text:"  constructor(val, left = null, right = null) {"},{stage:-1,text:"    this.val = val;"},{stage:-1,text:"    this.left = left;"},{stage:-1,text:"    this.right = right;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function find_sum_of_path_numbers(root) {"},{stage:0,text:""},{stage:-1,text:"  // second argument is the sum of all found paths, starts with a value of 0"},{stage:1,text:"  return find_root_to_leaf_path_numbers(root, 0);"},{stage:0,text:"}"},{stage:0,text:""},{stage:2,text:"function find_root_to_leaf_path_numbers(currentNode, pathSum) {"},{stage:3,text:"  if (currentNode === null) {"},{stage:-4,text:"    // still must return a value here"},{stage:4,text:"    return 0;"},{stage:3,text:"  }"},{stage:0,text:""},{stage:-5,text:"  // the next node shifts the current path number to the left (so we multiply by 10)"},{stage:5,text:"  pathSum = 10 * pathSum + currentNode.val;"},{stage:0,text:""},{stage:-6,text:"  // if we're at a leaf node, we can go no further.  return the sum."},{stage:6,text:"  if (currentNode.left === null && currentNode.right === null) {"},{stage:7,text:"    return pathSum;"},{stage:6,text:"  }"},{stage:0,text:""},{stage:-8,text:"  // add sum of paths at all leaf nodes"},{stage:8,text:"  return ("},{stage:10,text:"    find_root_to_leaf_path_numbers(currentNode.left, pathSum) +"},{stage:10,text:"    find_root_to_leaf_path_numbers(currentNode.right, pathSum)"},{stage:8,text:"  );"},{stage:2,text:"}"},{stage:0,text:""}]},151:{problemID:151,problemName:"Path With Given Sequence",problemText:"Given a binary tree and a number sequence (array), find if the sequence is present as a root-to-leaf path in the given tree.",testCases:[{id:1,name:"example 1",inherit:[],code:"const root = new TreeNode(1);\n      root.left = new TreeNode(0);\n      root.right = new TreeNode(1);\n      root.left.left = new TreeNode(1);\n      root.right.left = new TreeNode(6);\n      root.right.right = new TreeNode(5);",evaluate:"find_path(root, [1, 0, 7]);",expected:!1},{id:2,name:"example 2",inherit:[1],code:"",evaluate:"find_path(root, [1, 1, 6]);",expected:!0}],setupCode:"\n  class TreeNode {\n    constructor(val, left = null, right = null) {\n      this.val = val;\n      this.left = left;\n      this.right = right;\n    }\n  }\n  ",source:["https://www.educative.io/courses/grokking-the-coding-interview/m280XNlPOkn"],tags:[f,d,"Recursion",h],solution:[{stage:0,text:""},{stage:-1,text:"class TreeNode {"},{stage:-1,text:"  constructor(val, left = null, right = null) {"},{stage:-1,text:"    this.val = val;"},{stage:-1,text:"    this.left = left;"},{stage:-1,text:"    this.right = right;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function find_path(root, sequence) {"},{stage:1,text:"  if (root === null) {"},{stage:-2,text:"    // we can still return true if the sequence is empty and the root is null"},{stage:2,text:"    return sequence.length === 0;"},{stage:1,text:"  }"},{stage:0,text:""},{stage:-3,text:"  // last argument is the sequenceIndex, the particular character in 'sequence' that we're looking for"},{stage:3,text:"  return find_path_recursive(root, sequence, 0);"},{stage:0,text:"}"},{stage:0,text:""},{stage:4,text:"function find_path_recursive(currentNode, sequence, sequenceIndex) {"},{stage:0,text:""},{stage:-5,text:"  // base case: we were looking for a character, but the node is null"},{stage:5,text:"  if (currentNode === null) {"},{stage:6,text:"    return false;"},{stage:5,text:"  }"},{stage:0,text:""},{stage:7,text:"  const seqLen = sequence.length;"},{stage:0,text:""},{stage:-8,text:"  // if sequenceIndex exceeds the length of sequence, we can return early"},{stage:-8,text:"  // if the character found is not the same as the character at the sequenceIndex, we can also return early"},{stage:8,text:"  if (sequenceIndex >= seqLen || currentNode.val !== sequence[sequenceIndex]) {"},{stage:9,text:"    return false;"},{stage:8,text:"  }"},{stage:0,text:""},{stage:-10,text:"  // give we have the correct character at the correct index, if it is a leaf node, and"},{stage:-10,text:"  // if the sequenceIndex is the last chacter of the sequence, then a match has been found"},{stage:10,text:"  if (currentNode.left === null && currentNode.right === null && sequenceIndex === seqLen - 1) {"},{stage:11,text:"    return true;"},{stage:10,text:"  }"},{stage:0,text:""},{stage:-12,text:"  // otherwise, explore the left and right subtrees, making sure to increment the sequenceIndex"},{stage:12,text:"  return ("},{stage:13,text:"    find_path_recursive(currentNode.left, sequence, sequenceIndex + 1) ||"},{stage:13,text:"    find_path_recursive(currentNode.right, sequence, sequenceIndex + 1)"},{stage:12,text:"  );"},{stage:4,text:"}"},{stage:0,text:""}]},152:{problemID:152,problemName:"Count Paths for a Sum",problemText:"Given a binary tree and a number `sum`, find all paths in the tree such that the sum of all the node values of each path equals `sum`. Please note that the paths can start or end at any node but all paths must follow direction from parent to child (top to bottom).",testCases:[{id:1,name:"example 1",inherit:[],code:"const root = new TreeNode(12);\n      root.left = new TreeNode(7);\n      root.right = new TreeNode(1);\n      root.left.left = new TreeNode(4);\n      root.right.left = new TreeNode(10);\n      root.right.right = new TreeNode(5);",evaluate:"count_paths(root, 11);",expected:2}],setupCode:"\n  class TreeNode {\n    constructor(val, left = null, right = null) {\n      this.val = val;\n      this.left = left;\n      this.right = right;\n    }\n  }\n  ",source:["https://www.educative.io/courses/grokking-the-coding-interview/xV2J7jvN1or"],tags:[f,d,"Recursion",h],solution:[{stage:0,text:""},{stage:-1,text:"class TreeNode {"},{stage:-1,text:"  constructor(val, left = null, right = null) {"},{stage:-1,text:"    this.val = val;"},{stage:-1,text:"    this.left = left;"},{stage:-1,text:"    this.right = right;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function count_paths(root, sum) {"},{stage:0,text:""},{stage:1,text:"  return count_paths_recursive(root, sum, []);"},{stage:0,text:"}"},{stage:0,text:""},{stage:2,text:"function count_paths_recursive(currentNode, sum, currentPath) {"},{stage:3,text:"  if (currentNode === null) {"},{stage:4,text:"    return 0;"},{stage:3,text:"  }"},{stage:0,text:""},{stage:5,text:"  currentPath.push(currentNode.val);"},{stage:6,text:"  let pathCount = 0;"},{stage:6,text:"  let pathSum = 0;"},{stage:0,text:""},{stage:-7,text:"  // iterate backwards..."},{stage:-7,text:"  // find the sums of all sub-paths ending at the current node"},{stage:7,text:"  for (let i = currentPath.length - 1; i >= 0; i--) {"},{stage:8,text:"    pathSum += currentPath[i];"},{stage:9,text:"    if (pathSum === sum) {"},{stage:10,text:"      pathCount += 1;"},{stage:9,text:"    }"},{stage:7,text:"  }"},{stage:0,text:""},{stage:-11,text:"  // traverse left and right subtrees and add them to pathCount"},{stage:11,text:"  pathCount += count_paths_recursive(currentNode.left, sum, currentPath);"},{stage:12,text:"  pathCount += count_paths_recursive(currentNode.right, sum, currentPath);"},{stage:0,text:""},{stage:-13,text:"  // remove current node from current path to backtrack"},{stage:13,text:"  currentPath.pop();"},{stage:14,text:"  return pathCount;"},{stage:2,text:"}"},{stage:0,text:""}]},153:{problemID:153,problemName:"Tree Diameter",problemText:"Given a binary tree, find the length of its diameter. The diameter of a tree is the number of **nodes** on the longest path between any two leaf nodes. The diameter of a tree may or may not pass through the root.  Another way to think of the diameter is the sum of a node's left and right subtree heights, plus itself.\n\n  Note: Assume that there are at least two leaf nodes in the given tree.",testCases:[{id:1,name:"example 1",inherit:[],code:"const treeDiameter = new TreeDiameter();\n      const root = new TreeNode(1);\n      root.left = new TreeNode(2);\n      root.right = new TreeNode(3);\n      root.left.left = new TreeNode(4);\n      root.right.left = new TreeNode(5);\n      root.right.right = new TreeNode(6);",evaluate:"treeDiameter.find_diameter(root);",expected:5},{id:2,name:"example 2",inherit:[1],code:"root.left.left = null;\n      root.right.left.left = new TreeNode(7);\n      root.right.left.right = new TreeNode(8);\n      root.right.right.left = new TreeNode(9);\n      root.right.left.right.left = new TreeNode(10);\n      root.right.right.left.left = new TreeNode(11);",evaluate:"treeDiameter.find_diameter(root);",expected:7}],setupCode:"\n  class TreeNode {\n    constructor(val, left = null, right = null) {\n      this.val = val;\n      this.left = left;\n      this.right = right;\n    }\n  }\n  ",lcid:543,source:["https://www.educative.io/courses/grokking-the-coding-interview/JYVW7l2L4EJ","https://leetcode.com/problems/diameter-of-binary-tree/"],tags:[f,d,h,"Recursion"],solution:[{stage:0,text:""},{stage:-1,text:"class TreeNode {"},{stage:-1,text:"  constructor(val, left = null, right = null) {"},{stage:-1,text:"    this.val = val;"},{stage:-1,text:"    this.left = left;"},{stage:-1,text:"    this.right = right;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"class TreeDiameter {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.treeDiameter = 0;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  find_diameter(root) {"},{stage:0,text:"    this.calculate_height(root);"},{stage:0,text:"    return this.treeDiameter;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  calculate_height(currentNode) {"},{stage:0,text:""},{stage:-1,text:"    // base case: no node.  Height of subtree is 0."},{stage:1,text:"    if (currentNode === null) {"},{stage:2,text:"      return 0;"},{stage:1,text:"    }"},{stage:0,text:""},{stage:-3,text:"    // calculate heights of left and right subtrees"},{stage:3,text:"    const leftTreeHeight = this.calculate_height(currentNode.left);"},{stage:4,text:"    const rightTreeHeight = this.calculate_height(currentNode.right);"},{stage:0,text:""},{stage:-5,text:"    // update the overall tree diameter if the calculated diameter"},{stage:-5,text:"    // is higher than any previous calculated diameter"},{stage:5,text:"    const diameter = leftTreeHeight + rightTreeHeight + 1;"},{stage:6,text:"    this.treeDiameter = Math.max(this.treeDiameter, diameter);"},{stage:0,text:""},{stage:-7,text:"    // return the height of this subtree as the maximum of either"},{stage:-7,text:"    // the left or the right subtrees, plus the node itself"},{stage:7,text:"    return Math.max(leftTreeHeight, rightTreeHeight) + 1;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},154:{problemID:154,problemName:"Path with Maximum Sum",problemText:"Find the path with the maximum sum in a given binary tree. Write a function that returns the maximum sum.\n\n  A path can be defined as a sequence of nodes between any two nodes and doesn\u2019t necessarily pass through the root. The path must contain at least one node.",testCases:[{id:1,name:"example 1",inherit:[],code:"const maximumPathSum = new MaximumPathSum();\n      let root = new TreeNode(1);\n      root.left = new TreeNode(2);\n      root.right = new TreeNode(3);",evaluate:"maximumPathSum.find_maximum_path_sum(root);",expected:6},{id:2,name:"example 2",inherit:[1],code:"root.left.left = new TreeNode(1);\n      root.left.right = new TreeNode(3);\n      root.right.left = new TreeNode(5);\n      root.right.right = new TreeNode(6);\n      root.right.left.left = new TreeNode(7);\n      root.right.left.right = new TreeNode(8);\n      root.right.right.left = new TreeNode(9);",evaluate:"maximumPathSum.find_maximum_path_sum(root);",expected:31},{id:3,name:"example 3",inherit:[],code:"const maximumPathSum = new MaximumPathSum();\n      let root = new TreeNode(-1);\n      root.left = new TreeNode(-3);",evaluate:"maximumPathSum.find_maximum_path_sum(root);",expected:-1}],setupCode:"\n  class TreeNode {\n    constructor(val, left = null, right = null) {\n      this.val = val;\n      this.left = left;\n      this.right = right;\n    }\n  }\n  ",source:["https://www.educative.io/courses/grokking-the-coding-interview/xVPgnOvWVJq"],tags:[f,d,h,"Recursion"],solution:[{stage:0,text:""},{stage:-1,text:"class TreeNode {"},{stage:-1,text:"  constructor(val, left = null, right = null) {"},{stage:-1,text:"    this.val = val;"},{stage:-1,text:"    this.left = left;"},{stage:-1,text:"    this.right = right;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"class MaximumPathSum {"},{stage:0,text:""},{stage:0,text:"  find_maximum_path_sum(root) {"},{stage:0,text:"    this.globalMaximumSum = -Infinity;"},{stage:0,text:"    this.find_maximum_path_sum_recursive(root);"},{stage:0,text:"    return this.globalMaximumSum;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  find_maximum_path_sum_recursive(currentNode) {"},{stage:0,text:""},{stage:-1,text:"    // base case: no node."},{stage:1,text:"    if (currentNode === null) {"},{stage:2,text:"      return 0;"},{stage:1,text:"    }"},{stage:0,text:""},{stage:-3,text:"    // calculate the max sums of the left and the right subtrees"},{stage:3,text:"    let maxPathSumFromLeft = this.find_maximum_path_sum_recursive(currentNode.left);"},{stage:4,text:"    let maxPathSumFromRight = this.find_maximum_path_sum_recursive(currentNode.right);"},{stage:0,text:""},{stage:-5,text:"    // take the maximum value.  this will cut the path if at any point"},{stage:-5,text:"    // the sum of a string of nodes is less than 0"},{stage:5,text:"    maxPathSumFromLeft = Math.max(maxPathSumFromLeft, 0);"},{stage:6,text:"    maxPathSumFromRight = Math.max(maxPathSumFromRight, 0);"},{stage:0,text:""},{stage:-7,text:"    // path sum is left subtree + right subtree + node value itself"},{stage:7,text:"    const localMaximumSum = maxPathSumFromLeft + maxPathSumFromRight + currentNode.val;"},{stage:0,text:""},{stage:-8,text:"    // update the global maximum if new value > old"},{stage:8,text:"    this.globalMaximumSum = Math.max(this.globalMaximumSum, localMaximumSum);"},{stage:0,text:""},{stage:-9,text:"    // for the recursive calls, return the maximum of the left or right subtrees + the node value itself"},{stage:9,text:"    return Math.max(maxPathSumFromLeft, maxPathSumFromRight) + currentNode.val;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},155:{problemID:155,problemName:"Sliding Window Median",problemText:"Given an array of numbers and a number \u2018k\u2019, find the median of all the \u2018k\u2019 sized sub-arrays (or windows) of the array.",testCases:[{id:1,name:"example 1",inherit:[],code:"let slidingWindowMedian = new SlidingWindowMedian();",evaluate:"slidingWindowMedian.find_sliding_window_median([1, 2, -1, 3, 5], 2);",expected:JSON.stringify([1.5,.5,1,4])},{id:2,name:"example 2",inherit:[],code:"let slidingWindowMedian = new SlidingWindowMedian();",evaluate:"slidingWindowMedian.find_sliding_window_median([1, 2, -1, 3, 5], 3);",expected:JSON.stringify([1,2,3])}],setupCode:"".concat(G),source:["https://www.educative.io/courses/grokking-the-coding-interview/3Y9jm7XRrXO"],tags:[u,d],solution:[{stage:0,text:""},{stage:-1,text:""},{stage:-1,text:"// Heap Class Provided"},{stage:-1,text:""},{stage:-1,text:"// add(item: number) :void"},{stage:-1,text:"// peek() :number"},{stage:-1,text:"// poll() :number"},{stage:-1,text:"// remove(item: number) :void"},{stage:-1,text:"// length() :number"},{stage:0,text:""},{stage:0,text:"class SlidingWindowMedian {"},{stage:0,text:"  constructor() {"},{stage:0,text:"    this.maxHeap = new Heap((a, b) => a >= b);"},{stage:0,text:"    this.minHeap = new Heap((a, b) => a <= b);"},{stage:0,text:"  }"},{stage:0,text:""},{stage:0,text:"  find_sliding_window_median(nums, k) {"},{stage:1,text:"    const result = Array(nums.length - k + 1).fill(0.0);"},{stage:2,text:"    for (let i = 0; i < nums.length; i++) {"},{stage:3,text:"      if (this.maxHeap.length() === 0 || nums[i] <= this.maxHeap.peek()) {"},{stage:4,text:"        this.maxHeap.add(nums[i]);"},{stage:3,text:"      } else {"},{stage:5,text:"        this.minHeap.add(nums[i]);"},{stage:3,text:"      }"},{stage:0,text:""},{stage:6,text:"      this.rebalance_heaps();"},{stage:0,text:""},{stage:11,text:"      if (i - k + 1 >= 0) {"},{stage:12,text:"        if (this.maxHeap.length() === this.minHeap.length()) {"},{stage:13,text:"          result[i - k + 1] = this.maxHeap.peek() / 2.0 + this.minHeap.peek() / 2.0;"},{stage:12,text:"        } else {"},{stage:14,text:"          result[i - k + 1] = this.maxHeap.peek();"},{stage:12,text:"        }"},{stage:0,text:""},{stage:15,text:"        const elementToBeRemoved = nums[i - k + 1];"},{stage:16,text:"        if (elementToBeRemoved <= this.maxHeap.peek()) {"},{stage:17,text:"          this.maxHeap.remove(elementToBeRemoved, (a, b) => a === b);"},{stage:16,text:"        } else {"},{stage:18,text:"          this.minHeap.remove(elementToBeRemoved, (a, b) => a === b);"},{stage:16,text:"        }"},{stage:0,text:""},{stage:19,text:"        this.rebalance_heaps();"},{stage:11,text:"      }"},{stage:2,text:"    }"},{stage:0,text:""},{stage:20,text:"    return result;"},{stage:0,text:"  }"},{stage:0,text:""},{stage:7,text:"  rebalance_heaps() {"},{stage:8,text:"    if (this.maxHeap.length() > this.minHeap.length() + 1) {"},{stage:9,text:"      this.minHeap.add(this.maxHeap.poll());"},{stage:8,text:"    } else if (this.maxHeap.length() < this.minHeap.length()) {"},{stage:10,text:"      this.maxHeap.add(this.minHeap.poll());"},{stage:8,text:"    }"},{stage:7,text:"  }"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""}]},156:{problemID:156,problemName:"Maximize Capital",problemText:"Given a set of investment projects with their respective profits, we need to find the most profitable projects. We are given an initial capital and are allowed to invest only in a fixed number of projects. Our goal is to choose projects that give us the maximum profit. Write a function that returns the maximum total capital after selecting the most profitable projects.\n\n  We can start an investment project only when we have the required capital. Once a project is selected, we can assume that its profit has become our capital.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_maximum_capital([0, 1, 2], [1, 2, 3], 2, 1);",expected:6},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_maximum_capital([0, 1, 2, 3], [1, 2, 3, 5], 3, 0);",expected:8}],setupCode:"".concat(G),source:["https://www.educative.io/courses/grokking-the-coding-interview/B6x69OLX4jY"],tags:[u,d],solution:[{stage:0,text:""},{stage:-1,text:""},{stage:-1,text:"// Heap Class Provided"},{stage:-1,text:""},{stage:-1,text:"// add(item: number) :void"},{stage:-1,text:"// peek() :number"},{stage:-1,text:"// poll() :number"},{stage:-1,text:"// remove(item: number) :void"},{stage:-1,text:"// length() :number"},{stage:0,text:""},{stage:0,text:"function find_maximum_capital(capital, profits, numberOfProjects, initialCapital) {"},{stage:1,text:"  const minCapitalHeap = new Heap((a, b) => a[0] <= b[0]);"},{stage:2,text:"  const maxProfitHeap = new Heap((a, b) => a[0] >= b[0]);"},{stage:0,text:""},{stage:3,text:"  for (let i = 0; i < profits.length; i++) {"},{stage:4,text:"    minCapitalHeap.add([capital[i], i]);"},{stage:3,text:"  }"},{stage:0,text:""},{stage:5,text:"  let availableCapital = initialCapital;"},{stage:6,text:"  for (let i = 0; i < numberOfProjects; i++) {"},{stage:7,text:"    while (minCapitalHeap.length() > 0 && minCapitalHeap.peek()[0] <= availableCapital) {"},{stage:8,text:"      const [capital, index] = minCapitalHeap.poll();"},{stage:9,text:"      maxProfitHeap.add([profits[index], index]);"},{stage:7,text:"    }"},{stage:0,text:""},{stage:10,text:"    if (maxProfitHeap.length() === 0) {"},{stage:11,text:"      break;"},{stage:10,text:"    }"},{stage:0,text:""},{stage:12,text:"    availableCapital += maxProfitHeap.poll()[0];"},{stage:6,text:"  }"},{stage:0,text:""},{stage:13,text:"  return availableCapital;"},{stage:0,text:"}"},{stage:0,text:""}]},157:{problemID:157,problemName:"Next Interval",problemText:"Given an array of intervals, find the next interval of each interval. In a list of intervals, for an interval \u2018i\u2019 its next interval \u2018j\u2019 will have the smallest \u2018start\u2019 greater than or equal to the \u2018end\u2019 of \u2018i\u2019.\n\n  Write a function to return an array containing indices of the next interval of each input interval. If there is no next interval of a given interval, return -1. It is given that none of the intervals have the same start point.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_next_interval([new Interval(2, 3), new Interval(3, 4), new Interval(5, 6)]);",expected:JSON.stringify([1,2,-1])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_next_interval([new Interval(3, 4), new Interval(1, 5), new Interval(4, 6)]);",expected:JSON.stringify([2,-1,-1])}],setupCode:"\n  ".concat(G,"\n  class Interval {\n    constructor(start, end) {\n      this.start = start;\n      this.end = end;\n    }\n  }\n  "),source:["https://www.educative.io/courses/grokking-the-coding-interview/gkkmqXO6zrY"],tags:[u,d],solution:[{stage:0,text:""},{stage:-1,text:""},{stage:-1,text:"// Heap Class Provided"},{stage:-1,text:""},{stage:-1,text:"// add(item: number) :void"},{stage:-1,text:"// peek() :number"},{stage:-1,text:"// poll() :number"},{stage:-1,text:"// remove(item: number) :void"},{stage:-1,text:"// length() :number"},{stage:-1,text:""},{stage:-1,text:"class Interval {"},{stage:-1,text:"  constructor(start, end) {"},{stage:-1,text:"    this.start = start;"},{stage:-1,text:"    this.end = end;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:-1,text:""},{stage:0,text:""},{stage:0,text:"function find_next_interval(intervals) {"},{stage:1,text:"  const n = intervals.length;"},{stage:0,text:""},{stage:2,text:"  const maxStartHeap = new Heap((a, b) => a[0] >= b[0]);"},{stage:3,text:"  const maxEndHeap = new Heap((a, b) => a[0] >= b[0]);"},{stage:0,text:""},{stage:4,text:"  const result = Array(n).fill(0);"},{stage:5,text:"  for (let endIndex = 0; endIndex < n; endIndex++) {"},{stage:6,text:"    maxStartHeap.add([intervals[endIndex].start, endIndex]);"},{stage:7,text:"    maxEndHeap.add([intervals[endIndex].end, endIndex]);"},{stage:5,text:"  }"},{stage:0,text:""},{stage:8,text:"  for (let i = 0; i < n; i++) {"},{stage:9,text:"    const [topEnd, endIndex] = maxEndHeap.poll();"},{stage:10,text:"    result[endIndex] = -1;"},{stage:11,text:"    if (maxStartHeap.peek()[0] >= topEnd) {"},{stage:12,text:"      let [topStart, startIndex] = maxStartHeap.poll();"},{stage:13,text:"      while (maxStartHeap.length() > 0 && maxStartHeap.peek()[0] >= topEnd) {"},{stage:14,text:"        [topStart, startIndex] = maxStartHeap.poll();"},{stage:13,text:"      }"},{stage:15,text:"      result[endIndex] = startIndex;"},{stage:16,text:"      maxStartHeap.add([topStart, startIndex]);"},{stage:11,text:"    }"},{stage:8,text:"  }"},{stage:0,text:""},{stage:17,text:"  return result;"},{stage:0,text:"}"},{stage:0,text:""}]},158:{problemID:158,problemName:"Triplet Sum to Zero",problemText:"Given an array of unsorted numbers, find all unique triplets in it that add up to zero.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"search_triplets([-3, 0, 1, 2, -1, 1, -2]);",expected:JSON.stringify([[-3,1,2],[-2,0,2],[-2,1,1],[-1,0,1]])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"search_triplets([-5, 2, -1, -2, 3]);",expected:JSON.stringify([[-5,2,3],[-2,-1,3]])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/gxk639mrr5r"],tags:["Two Pointers",d],solution:[{stage:0,text:""},{stage:0,text:"function search_triplets(arr) {"},{stage:1,text:"  arr.sort((a, b) => a - b);"},{stage:2,text:"  const triplets = [];"},{stage:0,text:""},{stage:3,text:"  for (let i = 0; i < arr.length; i++) {"},{stage:4,text:"    if (i > 0 && arr[i] === arr[i - 1]) {"},{stage:5,text:"      continue;"},{stage:4,text:"    }"},{stage:6,text:"    search_pair(arr, -arr[i], i + 1, triplets);"},{stage:3,text:"  }"},{stage:0,text:""},{stage:7,text:"  return triplets;"},{stage:0,text:"}"},{stage:0,text:""},{stage:8,text:"function search_pair(arr, target_sum, left, triplets) {"},{stage:9,text:"  let right = arr.length - 1;"},{stage:0,text:""},{stage:10,text:"  while (left < right) {"},{stage:11,text:"    const current_sum = arr[left] + arr[right];"},{stage:12,text:"    if (current_sum === target_sum) {"},{stage:13,text:"      triplets.push([-target_sum, arr[left], arr[right]]);"},{stage:14,text:"      left += 1;"},{stage:14,text:"      right -= 1;"},{stage:15,text:"      while (left < right && arr[left] === arr[left - 1]) {"},{stage:16,text:"        left += 1;"},{stage:15,text:"      }"},{stage:17,text:"      while (left < right && arr[right] === arr[right + 1]) {"},{stage:18,text:"        right -= 1;"},{stage:17,text:"      }"},{stage:12,text:"    } else if (target_sum > current_sum) {"},{stage:19,text:"      left += 1;"},{stage:12,text:"    } else {"},{stage:20,text:"      right -= 1;"},{stage:12,text:"    }"},{stage:0,text:""},{stage:10,text:"  }"},{stage:0,text:""},{stage:8,text:"}"},{stage:0,text:""}]},159:{problemID:159,problemName:"Triplet Sum Close To Target",problemText:"Given an array of unsorted numbers and a target number, find a triplet in the array whose sum is as close to the target number as possible, return the sum of the triplet. If there are more than one such triplet, return the sum of the triplet with the smallest sum.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"triplet_sum_close_to_target([-2, 0, 1, 2], 2);",expected:1},{id:2,name:"example 2",inherit:[],code:"",evaluate:"triplet_sum_close_to_target([-3, -1, 1, 2], 1);",expected:0},{id:3,name:"example 3",inherit:[],code:"",evaluate:"triplet_sum_close_to_target([1, 0, 1, 1], 100);",expected:3}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/3YlQz7PE7OA"],tags:["Two Pointers",d],solution:[{stage:0,text:""},{stage:0,text:"function triplet_sum_close_to_target(arr, targetSum) {"},{stage:1,text:"  arr.sort((a, b) => a - b);"},{stage:2,text:"  let smallest_difference = Infinity;"},{stage:0,text:""},{stage:3,text:"  for (let i = 0; i < arr.length - 2; i++) {"},{stage:4,text:"    let left = i + 1;"},{stage:4,text:"    let right = arr.length - 1;"},{stage:0,text:""},{stage:5,text:"    while (left < right) {"},{stage:6,text:"      const target_diff = targetSum - arr[i] - arr[left] - arr[right];"},{stage:7,text:"      if (target_diff === 0) {"},{stage:8,text:"        return targetSum - target_diff;"},{stage:7,text:"      }"},{stage:0,text:""},{stage:9,text:"      if (Math.abs(target_diff) < Math.abs(smallest_difference)) {"},{stage:10,text:"        smallest_difference = target_diff;"},{stage:9,text:"      }"},{stage:0,text:""},{stage:11,text:"      if ("},{stage:12,text:"        Math.abs(target_diff) < Math.abs(smallest_difference) ||"},{stage:12,text:"        (Math.abs(target_diff) === Math.abs(smallest_difference) &&"},{stage:12,text:"          target_diff > smallest_difference)"},{stage:11,text:"      ) {"},{stage:13,text:"        smallest_difference = target_diff;"},{stage:11,text:"      }"},{stage:0,text:""},{stage:14,text:"      if (target_diff > 0) {"},{stage:15,text:"        left += 1;"},{stage:14,text:"      } else {"},{stage:16,text:"        right -= 1;"},{stage:14,text:"      }"},{stage:0,text:""},{stage:5,text:"    }"},{stage:3,text:"  }"},{stage:0,text:""},{stage:17,text:"  return targetSum - smallest_difference;"},{stage:0,text:"}"},{stage:0,text:""}]},160:{problemID:160,problemName:"Triplets with Smaller Sum",problemText:"Given an array arr of unsorted numbers and a target sum, count all triplets in it such that arr[i] + arr[j] + arr[k] < target where i, j, and k are three different indices. Write a function to return the count of such triplets.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"triplet_with_smaller_sum([-1, 0, 2, 3], 3);",expected:2},{id:2,name:"example 2",inherit:[],code:"",evaluate:"triplet_with_smaller_sum([-1, 4, 2, 1, 3], 5);",expected:4}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/mElknO5OKBO"],tags:["Two Pointers",d],solution:[{stage:0,text:""},{stage:0,text:"function triplet_with_smaller_sum(arr, target) {"},{stage:1,text:"  arr.sort((a, b) => a - b);"},{stage:2,text:"  let count = 0;"},{stage:0,text:""},{stage:3,text:"  for (let i = 0; i < arr.length - 2; i++) {"},{stage:4,text:"    count += search_pair(arr, target - arr[i], i);"},{stage:3,text:"  }"},{stage:0,text:""},{stage:5,text:"  return count;"},{stage:0,text:"}"},{stage:0,text:""},{stage:6,text:"function search_pair(arr, target_sum, first) {"},{stage:7,text:"  let count = 0;"},{stage:8,text:"  let left = first + 1;"},{stage:8,text:"  let right = arr.length - 1;"},{stage:0,text:""},{stage:9,text:"  while (left < right) {"},{stage:10,text:"    if (arr[left] + arr[right] < target_sum) {"},{stage:11,text:"      count += right - left;"},{stage:11,text:"      left += 1;"},{stage:10,text:"    } else {"},{stage:12,text:"      right -= 1;"},{stage:10,text:"    }"},{stage:9,text:"  }"},{stage:0,text:""},{stage:13,text:"  return count;"},{stage:6,text:"}"},{stage:0,text:""}]},161:{problemID:161,problemName:"Subarrays with Product less than Target",problemText:"Given an array with positive numbers and a target number, find all of its contiguous subarrays whose product is less than the target number.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_subarrays([2, 5, 3, 10], 30);",expected:JSON.stringify([[2],[5],[2,5],[3],[5,3],[10]])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_subarrays([8, 2, 6, 5], 50);",expected:JSON.stringify([[8],[2],[8,2],[6],[2,6],[5],[6,5]])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/RMV1GV1yPYz"],tags:["Two Pointers",d],solution:[{stage:0,text:""},{stage:0,text:"function find_subarrays(arr, target) {"},{stage:1,text:"  let result = [];"},{stage:1,text:"  let product = 1;"},{stage:2,text:"  let left = 0;"},{stage:0,text:""},{stage:3,text:"  for (let right = 0; right < arr.length; right++) {"},{stage:4,text:"    product *= arr[right];"},{stage:5,text:"    while (product >= target && left < arr.length) {"},{stage:6,text:"      product /= arr[left];"},{stage:6,text:"      left += 1;"},{stage:5,text:"    }"},{stage:0,text:""},{stage:7,text:"    const tempList = [];"},{stage:8,text:"    for (let i = right; i > left - 1; i--) {"},{stage:9,text:"      tempList.unshift(arr[i]);"},{stage:10,text:"      result.push(JSON.parse(JSON.stringify(tempList)));"},{stage:8,text:"    }"},{stage:3,text:"  }"},{stage:0,text:""},{stage:11,text:"  return result;"},{stage:0,text:"}"},{stage:0,text:""}]},162:{problemID:162,problemName:"Dutch National Flag Problem",problemText:"Given an array containing 0s, 1s and 2s, sort the array in-place. You should treat numbers of the array as objects, hence, we can\u2019t count 0s, 1s, and 2s to recreate the array.\n\n  The flag of the Netherlands consists of three colors: red, white and blue; and since our input array also consists of three different numbers that is why it is called Dutch National Flag problem.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"let arr = [1, 0, 2, 1, 0]; dutch_flag_sort(arr); arr;",expected:JSON.stringify([0,0,1,1,2])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"let arr = [2, 2, 0, 1, 2, 0]; dutch_flag_sort(arr); arr;",expected:JSON.stringify([0,0,1,2,2,2])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/RMBxV6jz6Q0"],tags:["Two Pointers",d],solution:[{stage:0,text:""},{stage:0,text:"function dutch_flag_sort(arr) {"},{stage:1,text:"  let low = 0;"},{stage:1,text:"  let high = arr.length - 1;"},{stage:2,text:"  let i = 0;"},{stage:0,text:""},{stage:3,text:"  while (i <= high) {"},{stage:4,text:"    if (arr[i] === 0) {"},{stage:5,text:"      [arr[i], arr[low]] = [arr[low], arr[i]];"},{stage:6,text:"      i += 1;"},{stage:6,text:"      low += 1;"},{stage:4,text:"    } else if (arr[i] === 1) {"},{stage:7,text:"      i += 1;"},{stage:4,text:"    } else {"},{stage:8,text:"      [arr[i], arr[high]] = [arr[high], arr[i]];"},{stage:9,text:"      high -= 1;"},{stage:4,text:"    }"},{stage:3,text:"  }"},{stage:0,text:"}"},{stage:0,text:""}]},163:{problemID:163,problemName:"Quadruple Sum to Target",problemText:"Given an array of unsorted numbers and a target number, find all unique quadruplets in it, whose sum is equal to the target number.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"search_quadruplets([4, 1, 2, -1, 1, -3], 1);",expected:JSON.stringify([[-3,-1,1,4],[-3,1,1,2]])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"search_quadruplets([2, 0, -1, 1, -2, 2], 2);",expected:JSON.stringify([[-2,0,2,2],[-1,0,1,2]])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/B6XOq8KlkWo"],tags:["Two Pointers",d],solution:[{stage:0,text:""},{stage:0,text:"function search_quadruplets(arr, target) {"},{stage:1,text:"  arr.sort((a, b) => a - b);"},{stage:1,text:"  const quadruplets = [];"},{stage:0,text:""},{stage:2,text:"  for (let i = 0; i < arr.length - 3; i++) {"},{stage:3,text:"    if (i > 0 && arr[i] === arr[i - 1]) {"},{stage:4,text:"      continue;"},{stage:3,text:"    }"},{stage:5,text:"    for (let j = i + 1; j < arr.length - 2; j++) {"},{stage:6,text:"      if (j > i + 1 && arr[j] === arr[j - 1]) {"},{stage:7,text:"        continue;"},{stage:6,text:"      }"},{stage:8,text:"      search_pairs(arr, target, i, j, quadruplets);"},{stage:5,text:"    }"},{stage:2,text:"  }"},{stage:9,text:"  return quadruplets;"},{stage:0,text:"}"},{stage:0,text:""},{stage:10,text:"function search_pairs(arr, targetSum, first, second, quadruplets) {"},{stage:11,text:"  let left = second + 1;"},{stage:11,text:"  let right = arr.length - 1;"},{stage:0,text:""},{stage:12,text:"  while (left < right) {"},{stage:13,text:"    let sum = arr[first] + arr[second] + arr[left] + arr[right];"},{stage:14,text:"    if (sum === targetSum) {"},{stage:15,text:"      quadruplets.push([arr[first], arr[second], arr[left], arr[right]]);"},{stage:16,text:"      left += 1;"},{stage:16,text:"      right -= 1;"},{stage:17,text:"      while (left < right && arr[left] === arr[left - 1]) {"},{stage:18,text:"        left += 1;"},{stage:17,text:"      }"},{stage:19,text:"      while (left < right && arr[right] === arr[right + 1]) {"},{stage:20,text:"        right -= 1;"},{stage:19,text:"      }"},{stage:14,text:"    } else if (sum < targetSum) {"},{stage:21,text:"      left += 1;"},{stage:14,text:"    } else {"},{stage:22,text:"      right -= 1;"},{stage:14,text:"    }"},{stage:0,text:""},{stage:12,text:"  }"},{stage:0,text:""},{stage:10,text:"}"},{stage:0,text:""}]},164:{problemID:164,problemName:"Comparing Strings Containing Backspaces",problemText:"Given two strings containing backspaces (identified by the character \u2018#\u2019), check if the two strings are equal.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"backspace_compare('xy#z', 'xzz#');",expected:!0},{id:2,name:"example 2",inherit:[],code:"",evaluate:"backspace_compare('xy#z', 'xyz#');",expected:!1},{id:3,name:"example 3",inherit:[],code:"",evaluate:"backspace_compare('xp#', 'xyz##');",expected:!0},{id:4,name:"example 4",inherit:[],code:"",evaluate:"backspace_compare('xywrrmp', 'xywrrmu#p');",expected:!0}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/xVKE8MJDlzq"],tags:["Two Pointers",d],solution:[{stage:0,text:""},{stage:0,text:"function backspace_compare(str1, str2) {"},{stage:1,text:"  let index1 = str1.length - 1;"},{stage:1,text:"  let index2 = str2.length - 1;"},{stage:0,text:""},{stage:2,text:"  while (index1 >= 0 || index2 >= 0) {"},{stage:3,text:"    let i1 = get_next_valid_char_index(str1, index1);"},{stage:4,text:"    let i2 = get_next_valid_char_index(str2, index2);"},{stage:5,text:"    if (i1 < 0 && i2 < 0) {"},{stage:6,text:"      return true;"},{stage:5,text:"    }"},{stage:7,text:"    if (i1 < 0 || i2 < 0) {"},{stage:8,text:"      return false;"},{stage:7,text:"    }"},{stage:9,text:"    if (str1[i1] !== str2[i2]) {"},{stage:10,text:"      return false;"},{stage:9,text:"    }"},{stage:0,text:""},{stage:11,text:"    index1 = i1 - 1;"},{stage:11,text:"    index2 = i2 - 1;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:12,text:"  return true;"},{stage:0,text:"}"},{stage:0,text:""},{stage:13,text:"function get_next_valid_char_index(str, index) {"},{stage:14,text:"  let backspaceCount = 0;"},{stage:15,text:"  while (index >= 0) {"},{stage:16,text:"    if (str[index] === '#') {"},{stage:17,text:"      backspaceCount += 1;"},{stage:16,text:"    } else if (backspaceCount > 0) {"},{stage:18,text:"      backspaceCount -= 1;"},{stage:16,text:"    } else {"},{stage:19,text:"      break;"},{stage:16,text:"    }"},{stage:0,text:""},{stage:20,text:"    index -= 1;"},{stage:15,text:"  }"},{stage:0,text:""},{stage:21,text:"  return index;"},{stage:13,text:"}"},{stage:0,text:""}]},165:{problemID:165,problemName:"Minimum Window Sort",problemText:"Given an array, find the length of the smallest subarray in it which when sorted will sort the whole array.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"shortest_window_sort([1, 2, 5, 3, 7, 10, 9, 12]);",expected:5},{id:2,name:"example 2",inherit:[],code:"",evaluate:"shortest_window_sort([1, 3, 2, 0, -1, 7, 10]);",expected:5},{id:3,name:"example 3",inherit:[],code:"",evaluate:"shortest_window_sort([1, 2, 3]);",expected:0},{id:4,name:"example 4",inherit:[],code:"",evaluate:"shortest_window_sort([3, 2, 1]);",expected:3}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/gxL951y9xj3"],tags:["Two Pointers",d],solution:[{stage:0,text:""},{stage:0,text:"function shortest_window_sort(arr) {"},{stage:1,text:"  let low = 0;"},{stage:1,text:"  let high = arr.length - 1;"},{stage:0,text:""},{stage:2,text:"  while (low < arr.length - 1 && arr[low] <= arr[low + 1]) {"},{stage:3,text:"    low += 1;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:4,text:"  if (low === arr.length - 1) {"},{stage:5,text:"    return 0;"},{stage:4,text:"  }"},{stage:0,text:""},{stage:6,text:"  while (high > 0 && arr[high] >= arr[high - 1]) {"},{stage:7,text:"    high -= 1;"},{stage:6,text:"  }"},{stage:0,text:""},{stage:8,text:"  let subarrayMax = -Infinity;"},{stage:8,text:"  let subarrayMin = Infinity;"},{stage:0,text:""},{stage:9,text:"  for (let k = low; k < high + 1; k++) {"},{stage:10,text:"    subarrayMax = Math.max(subarrayMax, arr[k]);"},{stage:11,text:"    subarrayMin = Math.min(subarrayMin, arr[k]);"},{stage:9,text:"  }"},{stage:0,text:""},{stage:12,text:"  while (low > 0 && arr[low - 1] > subarrayMin) {"},{stage:13,text:"    low -= 1;"},{stage:12,text:"  }"},{stage:0,text:""},{stage:14,text:"  while (high < arr.length - 1 && arr[high + 1] < subarrayMax) {"},{stage:15,text:"    high += 1;"},{stage:14,text:"  }"},{stage:0,text:""},{stage:16,text:"  return high - low + 1;"},{stage:0,text:"}"},{stage:0,text:""}]},166:{problemID:166,problemName:"Permutations - Iterative",problemText:"Given a set of distinct numbers, find all of its permutations.\n\n  Permutation is defined as the re-arranging of the elements of the set. For example, {1, 2, 3} has the following six permutations:\n  \n  {1, 2, 3}\n  {1, 3, 2}\n  {2, 1, 3}\n  {2, 3, 1}\n  {3, 1, 2}\n  {3, 2, 1}\n  \n  If a set has \u2018n\u2019 distinct elements it will have n! permutations.  \n  \n  Solve iteratively!",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_permutations([1, 3, 5]);",expected:JSON.stringify([[5,3,1],[3,5,1],[3,1,5],[5,1,3],[1,5,3],[1,3,5]])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/B8R83jyN3KY"],tags:[b,d],solution:[{stage:0,text:""},{stage:0,text:"function find_permutations(nums) {"},{stage:1,text:"  let numsLength = nums.length;"},{stage:1,text:"  let result = [];"},{stage:2,text:"  let permutations = [];"},{stage:2,text:"  permutations.push([]);"},{stage:0,text:""},{stage:3,text:"  for (let i = 0; i < nums.length; i++) {"},{stage:4,text:"    const currentNumber = nums[i];"},{stage:4,text:"    const n = permutations.length;"},{stage:0,text:""},{stage:5,text:"    for (let p = 0; p < n; p++) {"},{stage:6,text:"      const oldPermutation = permutations.shift();"},{stage:0,text:""},{stage:7,text:"      for (let j = 0; j < oldPermutation.length + 1; j++) {"},{stage:8,text:"        const newPermutation = oldPermutation.slice(0);"},{stage:8,text:"        newPermutation.splice(j, 0, currentNumber);"},{stage:9,text:"        if (newPermutation.length === numsLength) {"},{stage:10,text:"          result.push(newPermutation);"},{stage:9,text:"        } else {"},{stage:11,text:"          permutations.push(newPermutation);"},{stage:9,text:"        }"},{stage:7,text:"      }"},{stage:5,text:"    }"},{stage:3,text:"  }"},{stage:0,text:""},{stage:12,text:"  return result;"},{stage:0,text:"}"},{stage:0,text:""}]},167:{problemID:167,problemName:"Permutations - Recursive",problemText:"Given a set of distinct numbers, find all of its permutations.\n\n  Permutation is defined as the re-arranging of the elements of the set. For example, {1, 2, 3} has the following six permutations:\n  \n  {1, 2, 3}\n  {1, 3, 2}\n  {2, 1, 3}\n  {2, 3, 1}\n  {3, 1, 2}\n  {3, 2, 1}\n  \n  If a set has \u2018n\u2019 distinct elements it will have n! permutations.  \n  \n  Solve recursively!",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"generate_permutations([1, 3, 5]);",expected:JSON.stringify([[5,3,1],[3,5,1],[3,1,5],[5,1,3],[1,5,3],[1,3,5]])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/B8R83jyN3KY"],tags:[b,d],solution:[{stage:0,text:""},{stage:0,text:"function generate_permutations(nums) {"},{stage:1,text:"  const result = [];"},{stage:2,text:"  generate_permutations_recursive(nums, 0, [], result);"},{stage:0,text:""},{stage:3,text:"  return result;"},{stage:0,text:"}"},{stage:0,text:""},{stage:4,text:"function generate_permutations_recursive(nums, index, currentPermutation, result) {"},{stage:5,text:"  if (index === nums.length) {"},{stage:6,text:"    result.push(currentPermutation);"},{stage:5,text:"  } else {"},{stage:7,text:"    for (let i = 0; i < currentPermutation.length + 1; i++) {"},{stage:8,text:"      let newPermutation = currentPermutation.slice(0);"},{stage:9,text:"      newPermutation.splice(i, 0, nums[index]);"},{stage:10,text:"      generate_permutations_recursive(nums, index + 1, newPermutation, result);"},{stage:7,text:"    }"},{stage:5,text:"  }"},{stage:0,text:""},{stage:4,text:"}"},{stage:0,text:""}]},168:{problemID:168,problemName:"String Permutations By Changing Case",problemText:"Given a string, find all of its permutations preserving the character sequence but changing case.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_letter_case_string_permutations('ad52');",expected:JSON.stringify(["ad52","Ad52","aD52","AD52"])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_letter_case_string_permutations('ab7c');",expected:JSON.stringify(["ab7c","Ab7c","aB7c","AB7c","ab7C","Ab7C","aB7C","AB7C"])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/xVlKmyX542P"],tags:[b,d],solution:[{stage:0,text:""},{stage:0,text:"function find_letter_case_string_permutations(str) {"},{stage:1,text:"  const permutations = [];"},{stage:1,text:"  permutations.push(str);"},{stage:0,text:""},{stage:2,text:"  for (let i = 0; i < str.length; i++) {"},{stage:3,text:"    if (isNaN(parseInt(str[i], 10))) {"},{stage:4,text:"      const n = permutations.length;"},{stage:5,text:"      for (let j = 0; j < n; j++) {"},{stage:6,text:"        const chs = permutations[j].split('');"},{stage:7,text:"        if (chs[i] === chs[i].toLowerCase()) {"},{stage:8,text:"          chs[i] = chs[i].toUpperCase();"},{stage:7,text:"        } else {"},{stage:9,text:"          chs[i] = chs[i].toLowerCase();"},{stage:7,text:"        }"},{stage:10,text:"        permutations.push(chs.join(''));"},{stage:5,text:"      }"},{stage:0,text:""},{stage:3,text:"    }"},{stage:0,text:""},{stage:2,text:"  }"},{stage:0,text:""},{stage:11,text:"  return permutations;"},{stage:0,text:"}"},{stage:0,text:""}]},169:{problemID:169,problemName:"Balanced Parentheses - Iterative",problemText:"For a given number \u2018N\u2019, write a function to generate all combination of \u2018N\u2019 pairs of balanced parentheses.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"generate_valid_parentheses(2);",expected:JSON.stringify(["(())","()()"])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"generate_valid_parentheses(3);",expected:JSON.stringify(["((()))","(()())","(())()","()(())","()()()"])}],setupCode:"\n  class ParenthesesString {\n    constructor(str, openCount, closeCount) {\n      this.str = str;\n      this.openCount = openCount;\n      this.closeCount = closeCount;\n    }\n  }",source:["https://www.educative.io/courses/grokking-the-coding-interview/NEXBg8YA5A2"],tags:[b,d],solution:[{stage:0,text:""},{stage:-1,text:"class ParenthesesString {"},{stage:-1,text:"  constructor(str, openCount, closeCount) {"},{stage:-1,text:"    this.str = str;"},{stage:-1,text:"    this.openCount = openCount;"},{stage:-1,text:"    this.closeCount = closeCount;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function generate_valid_parentheses(num) {"},{stage:1,text:"  let result = [];"},{stage:1,text:"  let queue = [];"},{stage:2,text:"  queue.push(new ParenthesesString('', 0, 0));"},{stage:3,text:"  while (queue.length > 0) {"},{stage:4,text:"    const ps = queue.shift();"},{stage:5,text:"    if (ps.openCount === num && ps.closeCount === num) {"},{stage:6,text:"      result.push(ps.str);"},{stage:5,text:"    } else {"},{stage:7,text:"      if (ps.openCount < num) {"},{stage:8,text:"        queue.push(new ParenthesesString(ps.str + '(', ps.openCount + 1, ps.closeCount));"},{stage:7,text:"      }"},{stage:9,text:"      if (ps.openCount > ps.closeCount) {"},{stage:10,text:"        queue.push(new ParenthesesString(ps.str + ')', ps.openCount, ps.closeCount + 1));"},{stage:9,text:"      }"},{stage:5,text:"    }"},{stage:3,text:"  }"},{stage:0,text:""},{stage:11,text:"  return result;"},{stage:0,text:"}"},{stage:0,text:""}]},170:{problemID:170,problemName:"Balanced Parentheses - Recursive",problemText:"For a given number \u2018N\u2019, write a function to generate all combination of \u2018N\u2019 pairs of balanced parentheses.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"generate_valid_parentheses_start(2);",expected:JSON.stringify(["(())","()()"])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"generate_valid_parentheses_start(3);",expected:JSON.stringify(["((()))","(()())","(())()","()(())","()()()"])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/NEXBg8YA5A2"],tags:[b,d],solution:[{stage:0,text:""},{stage:0,text:"function generate_valid_parentheses_start(num) {"},{stage:1,text:"  const result = [];"},{stage:2,text:"  const parenthesesString = Array(2 * num);"},{stage:3,text:"  generate_valid_parentheses_rec(num, 0, 0, parenthesesString, 0, result);"},{stage:0,text:""},{stage:4,text:"  return result;"},{stage:0,text:"}"},{stage:0,text:""},{stage:5,text:"function generate_valid_parentheses_rec("},{stage:5,text:"  num,"},{stage:5,text:"  openCount,"},{stage:5,text:"  closeCount,"},{stage:5,text:"  parenthesesString,"},{stage:5,text:"  index,"},{stage:5,text:"  result"},{stage:5,text:") {"},{stage:0,text:""},{stage:6,text:"  if (openCount === num && closeCount === num) {"},{stage:7,text:"    result.push(parenthesesString.join(''));"},{stage:6,text:"  } else {"},{stage:7,text:"    if (openCount < num) {"},{stage:9,text:"      parenthesesString[index] = '(';"},{stage:10,text:"      generate_valid_parentheses_rec("},{stage:10,text:"        num,"},{stage:10,text:"        openCount + 1,"},{stage:10,text:"        closeCount,"},{stage:10,text:"        parenthesesString,"},{stage:10,text:"        index + 1,"},{stage:10,text:"        result"},{stage:10,text:"      );"},{stage:7,text:"    }"},{stage:0,text:""},{stage:8,text:"    if (openCount > closeCount) {"},{stage:11,text:"      parenthesesString[index] = ')';"},{stage:12,text:"      generate_valid_parentheses_rec("},{stage:12,text:"        num,"},{stage:12,text:"        openCount,"},{stage:12,text:"        closeCount + 1,"},{stage:12,text:"        parenthesesString,"},{stage:12,text:"        index + 1,"},{stage:12,text:"        result"},{stage:12,text:"      );"},{stage:8,text:"    }"},{stage:0,text:""},{stage:6,text:"  }"},{stage:0,text:""},{stage:5,text:"}"},{stage:0,text:""}]},171:{problemID:171,problemName:"Unique Generalized Abbreviations",problemText:"Solve Iteratively.\n  \n  Given a word, write a function to generate all of its unique generalized abbreviations.\n\n  Generalized abbreviation of a word can be generated by replacing each substring of the word by the count of characters in the substring. Take the example of \u201cab\u201d which has four substrings: \u201c\u201d, \u201ca\u201d, \u201cb\u201d, and \u201cab\u201d. After replacing these substrings in the actual word by the count of characters we get all the generalized abbreviations: \u201cab\u201d, \u201c1b\u201d, \u201ca1\u201d, and \u201c2\u201d.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"generate_generalized_abbreviation('BAT');",expected:JSON.stringify(["3","2T","1A1","1AT","B2","B1T","BA1","BAT"])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"generate_generalized_abbreviation('code');",expected:JSON.stringify(["4","3e","2d1","2de","1o2","1o1e","1od1","1ode","c3","c2e","c1d1","c1de","co2","co1e","cod1","code"])}],setupCode:"\n  class AbbreviatedWord {\n    constructor(str, start, count) {\n      this.str = str;\n      this.start = start;\n      this.count = count;\n    }\n  }\n  ",source:["https://www.educative.io/courses/grokking-the-coding-interview/NEOZDEg5PlN"],tags:[b,d],solution:[{stage:0,text:""},{stage:-1,text:"class AbbreviatedWord {"},{stage:-1,text:"  constructor(str, start, count) {"},{stage:-1,text:"    this.str = str;"},{stage:-1,text:"    this.start = start;"},{stage:-1,text:"    this.count = count;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function generate_generalized_abbreviation(word) {"},{stage:1,text:"  let wordLen = word.length;"},{stage:1,text:"  const result = [];"},{stage:1,text:"  const queue = [];"},{stage:2,text:"  queue.push(new AbbreviatedWord('', 0, 0));"},{stage:0,text:""},{stage:3,text:"  while (queue.length > 0) {"},{stage:4,text:"    const abWord = queue.shift();"},{stage:5,text:"    if (abWord.start === wordLen) {"},{stage:6,text:"      if (abWord.count !== 0) {"},{stage:7,text:"        abWord.str += abWord.count;"},{stage:6,text:"      }"},{stage:8,text:"      result.push(abWord.str);"},{stage:5,text:"    } else {"},{stage:9,text:"      queue.push(new AbbreviatedWord(abWord.str, abWord.start + 1, abWord.count + 1));"},{stage:0,text:""},{stage:10,text:"      if (abWord.count !== 0) {"},{stage:11,text:"        abWord.str += abWord.count;"},{stage:10,text:"      }"},{stage:0,text:""},{stage:12,text:"      let newWord = abWord.str + word[abWord.start];"},{stage:13,text:"      queue.push(new AbbreviatedWord(newWord, abWord.start + 1, 0));"},{stage:5,text:"    }"},{stage:3,text:"  }"},{stage:0,text:""},{stage:14,text:"  return result;"},{stage:0,text:"}"},{stage:0,text:""}]},172:{problemID:172,problemName:"Unique Generalized Abbreviations",problemText:"Solve Recursively.\n  \n  Given a word, write a function to generate all of its unique generalized abbreviations.\n\n  Generalized abbreviation of a word can be generated by replacing each substring of the word by the count of characters in the substring. Take the example of \u201cab\u201d which has four substrings: \u201c\u201d, \u201ca\u201d, \u201cb\u201d, and \u201cab\u201d. After replacing these substrings in the actual word by the count of characters we get all the generalized abbreviations: \u201cab\u201d, \u201c1b\u201d, \u201ca1\u201d, and \u201c2\u201d.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"generate_generalized_abbreviation_start('BAT');",expected:JSON.stringify(["3","2T","1A1","1AT","B2","B1T","BA1","BAT"])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"generate_generalized_abbreviation_start('code');",expected:JSON.stringify(["4","3e","2d1","2de","1o2","1o1e","1od1","1ode","c3","c2e","c1d1","c1de","co2","co1e","cod1","code"])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/NEOZDEg5PlN"],tags:[b,d],solution:[{stage:0,text:""},{stage:0,text:"function generate_generalized_abbreviation_start(word) {"},{stage:1,text:"  const result = [];"},{stage:2,text:"  generate_abbreviation_recursive(word, '', 0, 0, result);"},{stage:0,text:""},{stage:3,text:"  return result;"},{stage:0,text:"}"},{stage:0,text:""},{stage:4,text:"function generate_abbreviation_recursive(word, abWord, start, count, result) {"},{stage:5,text:"  if (start === word.length) {"},{stage:6,text:"    if (count !== 0) {"},{stage:7,text:"      abWord += count;"},{stage:6,text:"    }"},{stage:8,text:"    result.push(abWord);"},{stage:5,text:"  } else {"},{stage:9,text:"    generate_abbreviation_recursive(word, abWord, start + 1, count + 1, result);"},{stage:10,text:"    if (count !== 0) {"},{stage:11,text:"      abWord += count;"},{stage:10,text:"    }"},{stage:12,text:"    const newWord = abWord + word[start];"},{stage:13,text:"    generate_abbreviation_recursive(word, newWord, start + 1, 0, result);"},{stage:5,text:"  }"},{stage:4,text:"}"},{stage:0,text:""}]},173:{problemID:173,problemName:"Evaluate Expression",problemText:"Given an expression containing digits and operations (+, -, *), find all possible ways in which the expression can be evaluated by grouping the numbers and operators using parentheses.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"diff_ways_to_evaluate_expression_memo('1+2*3');",expected:JSON.stringify([7,9])},{id:1,name:"example 1",inherit:[],code:"",evaluate:"diff_ways_to_evaluate_expression_memo('2*3-4-5');",expected:JSON.stringify([8,-12,7,-7,-3])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/N0Q3PKRKMPz"],tags:[b,d],solution:[{stage:0,text:""},{stage:0,text:"function diff_ways_to_evaluate_expression_memo(input) {"},{stage:1,text:"  return diff_ways_to_evaluate_expression_rec({}, input);"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""},{stage:2,text:"function diff_ways_to_evaluate_expression_rec(map, input) {"},{stage:3,text:"  if (input in map) {"},{stage:4,text:"    return map[input];"},{stage:3,text:"  }"},{stage:0,text:""},{stage:5,text:"  const result = [];"},{stage:6,text:"  if (!input.includes('+') && !input.includes('-') && !input.includes('*')) {"},{stage:7,text:"    result.push(parseInt(input));"},{stage:6,text:"  } else {"},{stage:8,text:"    for (let i = 0; i < input.length; i++) {"},{stage:9,text:"      const char = input[i];"},{stage:10,text:"      if (isNaN(parseInt(char, 10))) {"},{stage:0,text:""},{stage:11,text:"        const leftParts = diff_ways_to_evaluate_expression_rec(map, input.substring(0, i));"},{stage:12,text:"        const rightParts = diff_ways_to_evaluate_expression_rec(map, input.substring(i + 1));"},{stage:0,text:""},{stage:13,text:"        for (let l = 0; l < leftParts.length; l++) {"},{stage:14,text:"          for (let r = 0; r < rightParts.length; r++) {"},{stage:15,text:"            let part1 = leftParts[l];"},{stage:16,text:"            let part2 = rightParts[r];"},{stage:17,text:"            if (char === '+') {"},{stage:18,text:"              result.push(part1 + part2);"},{stage:17,text:"            } else if (char === '-') {"},{stage:19,text:"              result.push(part1 - part2);"},{stage:17,text:"            } else if (char === '*') {"},{stage:20,text:"              result.push(part1 * part2);"},{stage:17,text:"            }"},{stage:14,text:"          }"},{stage:13,text:"        }"},{stage:10,text:"      }"},{stage:8,text:"    }"},{stage:6,text:"  }"},{stage:0,text:""},{stage:21,text:"  map[input] = result;"},{stage:22,text:"  return result;"},{stage:2,text:"}"},{stage:0,text:""}]},174:{problemID:174,problemName:"Structurally Unique Binary Search Trees",problemText:"Given a number \u2018n\u2019, write a function to return all structurally unique Binary Search Trees (BST) that can store values 1 to \u2018n\u2019?",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_unique_trees(2).length;",expected:2},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_unique_trees(3).length;",expected:5}],setupCode:"\n  class TreeNode {\n    constructor(val, left = null, right = null) {\n      this.val = val;\n      this.left = left;\n      this.right = right;\n    }\n  }\n  ",source:["https://www.educative.io/courses/grokking-the-coding-interview/xVQyDZBMpKE"],tags:[b,"Binary Search Tree",d],solution:[{stage:0,text:""},{stage:-1,text:"class TreeNode {"},{stage:-1,text:"  constructor(val, left = null, right = null) {"},{stage:-1,text:"    this.val = val;"},{stage:-1,text:"    this.left = left;"},{stage:-1,text:"    this.right = right;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function find_unique_trees(n) {"},{stage:1,text:"  if (n <= 0) {"},{stage:2,text:"    return [];"},{stage:1,text:"  }"},{stage:0,text:""},{stage:3,text:"  return findUnique_trees_recursive(1, n);"},{stage:0,text:"}"},{stage:0,text:""},{stage:4,text:"function findUnique_trees_recursive(start, end) {"},{stage:5,text:"  const result = [];"},{stage:0,text:""},{stage:6,text:"  if (start > end) {"},{stage:7,text:"    result.push(null);"},{stage:7,text:"    return result;"},{stage:6,text:"  }"},{stage:0,text:""},{stage:8,text:"  for (let i = start; i < end + 1; i++) {"},{stage:9,text:"    const leftSubtrees = findUnique_trees_recursive(start, i - 1);"},{stage:10,text:"    const rightSubtrees = findUnique_trees_recursive(i + 1, end);"},{stage:0,text:""},{stage:11,text:"    for (let p = 0; p < leftSubtrees.length; p++) {"},{stage:12,text:"      for (let q = 0; q < rightSubtrees.length; q++) {"},{stage:13,text:"        const root = new TreeNode(i, leftSubtrees[p], rightSubtrees[q]);"},{stage:14,text:"        result.push(root);"},{stage:12,text:"      }"},{stage:11,text:"    }"},{stage:8,text:"  }"},{stage:0,text:""},{stage:15,text:"  return result;"},{stage:4,text:"}"},{stage:0,text:""}]},175:{problemID:175,problemName:"Count of Structurally Unique Binary Search Trees",problemText:"Given a number \u2018n\u2019, write a function to return the count of structurally unique Binary Search Trees (BST) that can store values 1 to \u2018n\u2019.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"count_trees_memo(2);",expected:2},{id:2,name:"example 2",inherit:[],code:"",evaluate:"count_trees_memo(3);",expected:5}],setupCode:"\n  class TreeNode {\n    constructor(val) {\n      this.val = val;\n      this.left = null;\n      this.right = null;\n    }\n  }\n  ",source:["https://www.educative.io/courses/grokking-the-coding-interview/xVQyDZBMpKE"],tags:[b,d],solution:[{stage:0,text:""},{stage:-1,text:"class TreeNode {"},{stage:-1,text:"  constructor(val) {"},{stage:-1,text:"    this.val = val;"},{stage:-1,text:"    this.left = null;"},{stage:-1,text:"    this.right = null;"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function count_trees_memo(n) {"},{stage:1,text:"  return count_trees_rec({}, n);"},{stage:0,text:""},{stage:0,text:"}"},{stage:0,text:""},{stage:2,text:"function count_trees_rec(map, n) {"},{stage:3,text:"  if (n in map) {"},{stage:4,text:"    return map[n];"},{stage:3,text:"  }"},{stage:0,text:""},{stage:5,text:"  if (n <= 1) {"},{stage:6,text:"    return 1;"},{stage:5,text:"  }"},{stage:7,text:"  let count = 0;"},{stage:8,text:"  for (let i = 1; i < n + 1; i++) {"},{stage:9,text:"    let countOfLeftSubtrees = count_trees_rec(map, i - 1);"},{stage:10,text:"    let countOfRightSubtrees = count_trees_rec(map, n - i);"},{stage:11,text:"    count += countOfLeftSubtrees * countOfRightSubtrees;"},{stage:8,text:"  }"},{stage:0,text:""},{stage:12,text:"  map[n] = count;"},{stage:13,text:"  return count;"},{stage:2,text:"}"},{stage:0,text:""}]},176:{problemID:176,problemName:"Ceiling of a Number",problemText:"Given an array of numbers sorted in an ascending order, find the ceiling of a given number \u2018key\u2019. The ceiling of the \u2018key\u2019 will be the smallest element in the given array greater than or equal to the \u2018key\u2019.\n\n  Write a function to return the index of the ceiling of the \u2018key\u2019. If there isn\u2019t any ceiling return -1.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"search_ceiling_of_a_number([4, 6, 10], 6);",expected:1},{id:2,name:"example 2",inherit:[],code:"",evaluate:"search_ceiling_of_a_number([1, 3, 8, 10, 15], 12);",expected:4},{id:3,name:"example 3",inherit:[],code:"",evaluate:"search_ceiling_of_a_number([4, 6, 10], 17);",expected:-1},{id:4,name:"example 4",inherit:[],code:"",evaluate:"search_ceiling_of_a_number([4, 6, 10], -1);",expected:0}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/qA5wW7R8ox7"],tags:["Binary Search",d],solution:[{stage:0,text:""},{stage:0,text:"function search_ceiling_of_a_number(arr, key) {"},{stage:1,text:"  const n = arr.length;"},{stage:0,text:""},{stage:-2,text:"  // arr is sorted.  if key is already greater than the last item"},{stage:-2,text:"  // return early, as there is not any ceiling"},{stage:2,text:"  if (key > arr[n - 1]) {"},{stage:3,text:"    return -1;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:4,text:"  let start = 0;"},{stage:4,text:"  let end = n - 1;"},{stage:0,text:""},{stage:5,text:"  while (start <= end) {"},{stage:6,text:"    let mid = Math.floor(start + (end - start) / 2);"},{stage:7,text:"    if (key < arr[mid]) {"},{stage:8,text:"      end = mid - 1;"},{stage:7,text:"    } else if (key > arr[mid]) {"},{stage:9,text:"      start = mid + 1;"},{stage:7,text:"    } else {"},{stage:-10,text:"      // the quick escape only happens if key === arrayValue"},{stage:10,text:"      return mid;"},{stage:7,text:"    }"},{stage:5,text:"  }"},{stage:0,text:""},{stage:-11,text:"  // the start index will point to the smallest number greater than the key"},{stage:-11,text:"  // the end index iterates needlessly on the last iteration of the while loop"},{stage:-11,text:"  // rendering it incorrect to return"},{stage:11,text:"  return start;"},{stage:0,text:"}"},{stage:0,text:""}]},177:{problemID:177,problemName:"Next Letter",problemText:"Given an array of lowercase letters sorted in ascending order, find the smallest letter in the given array greater than a given \u2018key\u2019.\n\n  Assume the given array is a circular list, which means that the last letter is assumed to be connected with the first letter. This also means that the smallest letter in the given array is greater than the last letter of the array and is also the first letter of the array.\n  \n  Write a function to return the next letter of the given \u2018key\u2019.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"search_next_letter(['a', 'c', 'f', 'h'], 'f');",expected:"h"},{id:2,name:"example 2",inherit:[],code:"",evaluate:"search_next_letter(['a', 'c', 'f', 'h'], 'b');",expected:"c"},{id:3,name:"example 3",inherit:[],code:"",evaluate:"search_next_letter(['a', 'c', 'f', 'h'], 'm');",expected:"a"}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/g2w6QPBA2Nk"],tags:["Binary Search",d],solution:[{stage:0,text:""},{stage:0,text:"function search_next_letter(letters, key) {"},{stage:1,text:"  const n = letters.length;"},{stage:0,text:""},{stage:-2,text:"  // if they key is less than the first letter, or greater than the last letter"},{stage:-2,text:"  // then we already know that the first letter of the array "},{stage:-2,text:"  // is the smallest greater letter"},{stage:2,text:"  if (key < letters[0] || key > letters[n - 1]) {"},{stage:3,text:"    return letters[0];"},{stage:2,text:"  }"},{stage:0,text:""},{stage:4,text:"  let start = 0;"},{stage:4,text:"  let end = n - 1;"},{stage:5,text:"  while (start <= end) {"},{stage:6,text:"    let mid = Math.floor(start + (end - start) / 2);"},{stage:7,text:"    if (key < letters[mid]) {"},{stage:8,text:"      end = mid - 1;"},{stage:7,text:"    } else {"},{stage:-8,text:"      // there is no == case, we are looking for smallest letter greater than key"},{stage:8,text:"      start = mid + 1;"},{stage:7,text:"    }"},{stage:5,text:"  }"},{stage:0,text:""},{stage:-9,text:"  // due to the possibility that the start index is pointing to an index that is"},{stage:-9,text:"  // one above the last index of the array"},{stage:9,text:"  return letters[start % n];"},{stage:0,text:"}"},{stage:0,text:""}]},178:{problemID:178,problemName:"Number Range",problemText:"Given an array of numbers sorted in ascending order, find the range of a given number \u2018key\u2019. The range of the \u2018key\u2019 will be the first and last position of the \u2018key\u2019 in the array.\n\n  Write a function to return the range of the \u2018key\u2019. If the \u2018key\u2019 is not present return [-1, -1].",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_range([4, 6, 6, 6, 9], 6);",expected:JSON.stringify([1,3])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_range([1, 3, 8, 10, 15], 10);",expected:JSON.stringify([3,3])},{id:3,name:"example 3",inherit:[],code:"",evaluate:"find_range([1, 3, 8, 10, 15], 12);",expected:JSON.stringify([-1,-1])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/R1B78K9oBEz"],tags:["Binary Search",d],solution:[{stage:0,text:""},{stage:0,text:"function find_range(arr, key) {"},{stage:1,text:"  const result = [-1, -1];"},{stage:2,text:"  result[0] = binary_search(arr, key, false);"},{stage:3,text:"  if (result[0] !== -1) {"},{stage:4,text:"    result[1] = binary_search(arr, key, true);"},{stage:3,text:"  }"},{stage:0,text:""},{stage:5,text:"  return result;"},{stage:0,text:"}"},{stage:0,text:""},{stage:6,text:"function binary_search(arr, key, findMaxIndex) {"},{stage:7,text:"  let keyIndex = -1;"},{stage:7,text:"  let start = 0;"},{stage:8,text:"  let end = arr.length - 1;"},{stage:0,text:""},{stage:9,text:"  while (start <= end) {"},{stage:10,text:"    let mid = Math.floor(start + (end - start) / 2);"},{stage:11,text:"    if (key < arr[mid]) {"},{stage:12,text:"      end = mid - 1;"},{stage:11,text:"    } else if (key > arr[mid]) {"},{stage:13,text:"      start = mid + 1;"},{stage:11,text:"    } else {"},{stage:14,text:"      keyIndex = mid;"},{stage:15,text:"      if (findMaxIndex) {"},{stage:16,text:"        start = mid + 1;"},{stage:15,text:"      } else {"},{stage:17,text:"        end = mid - 1;"},{stage:15,text:"      }"},{stage:11,text:"    }"},{stage:9,text:"  }"},{stage:0,text:""},{stage:18,text:"  return keyIndex;"},{stage:6,text:"}"},{stage:0,text:""}]},179:{problemID:179,problemName:"Search in a Sorted Infinite Array",problemText:"Given an infinite sorted array (or an array with unknown size), find if a given number \u2018key\u2019 is present in the array. Write a function to return the index of the \u2018key\u2019 if it is present in the array, otherwise return -1.\n\n  Since it is not possible to define an array with infinite (unknown) size, you will be provided with an interface ArrayReader to read elements of the array. ArrayReader.get(index) will return the number at index; if the array\u2019s size is smaller than the index, it will return Integer.MAX_VALUE.",testCases:[{id:1,name:"example 1",inherit:[],code:"let reader = new ArrayReader([4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30]);",evaluate:"search_in_infinite_array(reader, 16);",expected:6},{id:2,name:"example 2",inherit:[1],code:"",evaluate:"search_in_infinite_array(reader, 11);",expected:-1},{id:3,name:"example 3",inherit:[],code:"let reader = new ArrayReader([1, 3, 8, 10, 15]);",evaluate:"search_in_infinite_array(reader, 15);",expected:4},{id:4,name:"example 4",inherit:[3],code:"",evaluate:"search_in_infinite_array(reader, 200);",expected:-1}],setupCode:"\n  class ArrayReader {\n    constructor(arr) {\n      this.arr = arr;\n    }\n  \n    get(index) {\n      if (index >= this.arr.length) {\n        return Infinity;\n      }\n      return this.arr[index];\n    }\n  }\n  ",source:["https://www.educative.io/courses/grokking-the-coding-interview/B1ZW38kXJB2"],tags:["Binary Search",d],solution:[{stage:0,text:""},{stage:-1,text:"class ArrayReader {"},{stage:-1,text:"  constructor(arr) {"},{stage:-1,text:"    this.arr = arr;"},{stage:-1,text:"  }"},{stage:-1,text:""},{stage:-1,text:"  get(index) {"},{stage:-1,text:"    if (index >= this.arr.length) {"},{stage:-1,text:"      return Infinity;"},{stage:-1,text:"    }"},{stage:-1,text:""},{stage:-1,text:"    return this.arr[index];"},{stage:-1,text:"  }"},{stage:-1,text:"}"},{stage:0,text:""},{stage:0,text:"function search_in_infinite_array(reader, key) {"},{stage:1,text:"  let start = 0;"},{stage:1,text:"  let end = 1;"},{stage:0,text:""},{stage:-2,text:"  // determine the bounds of the sorted array"},{stage:-2,text:"  // as soon as we find a value that is either Infinite"},{stage:-2,text:"  // or simply greater than key, we can start binary search"},{stage:2,text:"  while (reader.get(end) < key) {"},{stage:3,text:"    let newStart = end + 1;"},{stage:-3,text:"    // in an infinite array, avoiding overflow is important"},{stage:3,text:"    end += (end - start + 1) * 2;"},{stage:3,text:"    start = newStart;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:4,text:"  return binary_search(reader, key, start, end);"},{stage:0,text:"}"},{stage:0,text:""},{stage:5,text:"function binary_search(reader, key, start, end) {"},{stage:6,text:"  while (start <= end) {"},{stage:-7,text:"    // again, avoid overflow"},{stage:7,text:"    let mid = Math.floor(start + (end - start) / 2);"},{stage:8,text:"    if (key < reader.get(mid)) {"},{stage:9,text:"      end = mid - 1;"},{stage:8,text:"    } else if (key > reader.get(mid)) {"},{stage:10,text:"      start = mid + 1;"},{stage:8,text:"    } else {"},{stage:11,text:"      return mid;"},{stage:8,text:"    }"},{stage:6,text:"  }"},{stage:0,text:""},{stage:12,text:"  return -1;"},{stage:5,text:"}"},{stage:0,text:""}]},180:{problemID:180,problemName:"Minimum Difference Element",problemText:"Given an array of numbers sorted in ascending order, find the element in the array that has the minimum difference with the given \u2018key\u2019.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"search_min_diff_element([4, 6, 10], 7);",expected:6},{id:2,name:"example 2",inherit:[],code:"",evaluate:"search_min_diff_element([4, 6, 10], 4);",expected:4},{id:3,name:"example 3",inherit:[],code:"",evaluate:"search_min_diff_element([1, 3, 8, 10, 15], 12);",expected:10},{id:4,name:"example 4",inherit:[],code:"",evaluate:"search_min_diff_element([4, 6, 10], 17);",expected:10}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/mymvP915LY9"],tags:["Binary Search",d],solution:[{stage:0,text:""},{stage:0,text:"function search_min_diff_element(arr, key) {"},{stage:1,text:"  if (key < arr[0]) {"},{stage:2,text:"    return arr[0];"},{stage:1,text:"  }"},{stage:3,text:"  const n = arr.length;"},{stage:4,text:"  if (key > arr[n - 1]) {"},{stage:5,text:"    return arr[n - 1];"},{stage:4,text:"  }"},{stage:0,text:""},{stage:6,text:"  let start = 0;"},{stage:6,text:"  let end = n - 1;"},{stage:7,text:"  while (start <= end) {"},{stage:8,text:"    let mid = Math.floor(start + (end - start) / 2);"},{stage:9,text:"    if (key < arr[mid]) {"},{stage:10,text:"      end = mid - 1;"},{stage:9,text:"    } else if (key > arr[mid]) {"},{stage:11,text:"      start = mid + 1;"},{stage:9,text:"    } else {"},{stage:12,text:"      return arr[mid];"},{stage:9,text:"    }"},{stage:7,text:"  }"},{stage:0,text:""},{stage:13,text:"  if (arr[start] - key < key - arr[end]) {"},{stage:14,text:"    return arr[start];"},{stage:13,text:"  }"},{stage:0,text:""},{stage:15,text:"  return arr[end];"},{stage:0,text:"}"},{stage:0,text:""}]},181:{problemID:181,problemName:"Search Bitonic Array",problemText:"Given a Bitonic array, find if a given \u2018key\u2019 is present in it. An array is considered bitonic if it is monotonically increasing and then monotonically decreasing. Monotonically increasing or decreasing means that for any index i in the array arr[i] != arr[i+1].\n\n  Write a function to return the index of the \u2018key\u2019. If the \u2018key\u2019 is not present, return -1.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"search_bitonic_array([1, 3, 8, 4, 3], 4);",expected:3},{id:2,name:"example 2",inherit:[],code:"",evaluate:"search_bitonic_array([3, 8, 3, 1], 8);",expected:1},{id:3,name:"example 3",inherit:[],code:"",evaluate:"search_bitonic_array([1, 3, 8, 12], 12);",expected:3},{id:4,name:"example 4",inherit:[],code:"",evaluate:"search_bitonic_array([10, 9, 8], 10);",expected:0}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/7n3BlOvqW0r"],tags:["Binary Search",d],solution:[{stage:0,text:""},{stage:0,text:"function search_bitonic_array(arr, key) {"},{stage:1,text:"  const maxIndex = find_max(arr);"},{stage:2,text:"  const keyIndex = binary_search(arr, key, 0, maxIndex);"},{stage:3,text:"  if (keyIndex !== -1) {"},{stage:4,text:"    return keyIndex;"},{stage:3,text:"  }"},{stage:0,text:""},{stage:5,text:"  return binary_search(arr, key, maxIndex + 1, arr.length - 1);"},{stage:0,text:"}"},{stage:0,text:""},{stage:6,text:"function find_max(arr) {"},{stage:7,text:"  let start = 0;"},{stage:7,text:"  let end = arr.length - 1;"},{stage:0,text:""},{stage:8,text:"  while (start < end) {"},{stage:9,text:"    const mid = Math.floor(start + (end - start) / 2);"},{stage:10,text:"    if (arr[mid] > arr[mid + 1]) {"},{stage:11,text:"      end = mid;"},{stage:10,text:"    } else {"},{stage:12,text:"      start = mid + 1;"},{stage:10,text:"    }"},{stage:8,text:"  }"},{stage:0,text:""},{stage:13,text:"  return start;"},{stage:6,text:"}"},{stage:0,text:""},{stage:14,text:"function binary_search(arr, key, start, end) {"},{stage:15,text:"  while (start <= end) {"},{stage:16,text:"    const mid = Math.floor(start + (end - start) / 2);"},{stage:17,text:"    if (key === arr[mid]) {"},{stage:18,text:"      return mid;"},{stage:17,text:"    }"},{stage:0,text:""},{stage:19,text:"    if (arr[start] < arr[end]) {"},{stage:20,text:"      if (key < arr[mid]) {"},{stage:21,text:"        end = mid - 1;"},{stage:20,text:"      } else {"},{stage:21,text:"        start = mid + 1;"},{stage:20,text:"      }"},{stage:19,text:"    } else {"},{stage:22,text:"      if (key > arr[mid]) {"},{stage:23,text:"        end = mid - 1;"},{stage:22,text:"      } else {"},{stage:23,text:"        start = mid + 1;"},{stage:22,text:"      }"},{stage:19,text:"    }"},{stage:15,text:"  }"},{stage:0,text:""},{stage:24,text:"  return -1;"},{stage:14,text:"}"},{stage:0,text:""}]},182:{problemID:182,problemName:"Search in Rotated Array",problemText:"Given an array of numbers which is sorted in ascending order and also rotated by some arbitrary number, find if a given \u2018key\u2019 is present in it.\n\n  Write a function to return the index of the \u2018key\u2019 in the rotated array. If the \u2018key\u2019 is not present, return -1. You can assume that the given array does not have any duplicates.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"search_rotated_array([10, 15, 1, 3, 8], 15);",expected:1},{id:2,name:"example 2",inherit:[],code:"",evaluate:"search_rotated_array([4, 5, 7, 9, 10, -1, 2], 10);",expected:4}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/RMPVM2Y4PW0"],tags:["Binary Search",d],solution:[{stage:0,text:""},{stage:0,text:"function search_rotated_array(arr, key) {"},{stage:1,text:"  let start = 0;"},{stage:2,text:"  let end = arr.length - 1;"},{stage:0,text:""},{stage:3,text:"  while (start <= end) {"},{stage:4,text:"    let mid = Math.floor(start + (end - start) / 2);"},{stage:0,text:""},{stage:-5,text:"    // if we've found the key, we can return right away"},{stage:5,text:"    if (arr[mid] === key) {"},{stage:6,text:"      return mid;"},{stage:5,text:"    }"},{stage:0,text:""},{stage:-7,text:"    // the numbers from start to middle are sorted in ascending order"},{stage:7,text:"    if (arr[start] <= arr[mid]) {"},{stage:0,text:""},{stage:-8,text:"      // if the key is somewhere in the range of start to middle"},{stage:8,text:"      if (key >= arr[start] && key < arr[mid]) {"},{stage:9,text:"        end = mid - 1;"},{stage:8,text:"      } else {"},{stage:10,text:"        start = mid + 1;"},{stage:8,text:"      }"},{stage:7,text:"    } else {"},{stage:-7,text:"      // the numbers from middle to end are sorted in ascending order"},{stage:0,text:""},{stage:-11,text:"      // if the key is in the range of middle to end"},{stage:11,text:"      if (key > arr[mid] && key <= arr[end]) {"},{stage:12,text:"        start = mid + 1;"},{stage:11,text:"      } else {"},{stage:13,text:"        end = mid - 1;"},{stage:11,text:"      }"},{stage:7,text:"    }"},{stage:3,text:"  }"},{stage:0,text:""},{stage:14,text:"  return -1;"},{stage:0,text:"}"},{stage:0,text:""}]},183:{problemID:183,problemName:"Rotation Count",problemText:"Given an array of numbers which is sorted in ascending order and is rotated \u2018k\u2019 times around a pivot, find \u2018k\u2019.\n\n  You can also think about this problem as; in a rotated array, which index is the minimum element at?\n\n  You can assume that the array does not have any duplicates.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"count_rotations([10, 15, 1, 3, 8]);",expected:2},{id:2,name:"example 2",inherit:[],code:"",evaluate:"count_rotations([4, 5, 7, 9, 10, -1, 2]);",expected:5},{id:3,name:"example 3",inherit:[],code:"",evaluate:"count_rotations([1, 3, 8, 10]);",expected:0}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/R1v4P0R7VZw"],tags:["Binary Search",d],solution:[{stage:0,text:""},{stage:0,text:"function count_rotations(arr) {"},{stage:1,text:"  let start = 0;"},{stage:1,text:"  let end = arr.length - 1;"},{stage:0,text:""},{stage:2,text:"  while (start < end) {"},{stage:3,text:"    let mid = Math.floor(start + (end - start) / 2);"},{stage:0,text:""},{stage:-4,text:"    // check to see if mid or mid+1 is the minimum element"},{stage:-4,text:"    // the minimum element is the only element which is smaller than its previous element."},{stage:0,text:""},{stage:-4,text:"    // we check mid<end because if mid===end, there is no mid+1"},{stage:4,text:"    if (mid < end && arr[mid] > arr[mid + 1]) {"},{stage:5,text:"      return mid + 1;"},{stage:4,text:"    }"},{stage:0,text:""},{stage:-6,text:"    // we check mid>start because if mid===start, there is no mid-1"},{stage:6,text:"    if (mid > start && arr[mid - 1] > arr[mid]) {"},{stage:7,text:"      return mid;"},{stage:6,text:"    }"},{stage:0,text:""},{stage:-8,text:"    // typical binary search from this point on"},{stage:8,text:"    if (arr[start] < arr[mid]) {"},{stage:9,text:"      start = mid + 1;"},{stage:8,text:"    } else {"},{stage:10,text:"      end = mid - 1;"},{stage:8,text:"    }"},{stage:2,text:"  }"},{stage:0,text:""},{stage:11,text:"  return 0;"},{stage:0,text:"}"},{stage:0,text:""}]},184:{problemID:184,problemName:"Kth Smallest Number in M Sorted Lists",problemText:"Given \u2018M\u2019 sorted arrays, find the K\u2019th smallest number among all the arrays.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_Kth_smallest(\n        [\n          [2, 6, 8],\n          [3, 6, 7],\n          [1, 3, 4],\n        ],\n        5,\n      );",expected:4}],setupCode:"".concat(G),source:["https://www.educative.io/courses/grokking-the-coding-interview/myAqDMyRXn3"],tags:["K-Way-Merge",d],solution:[{stage:0,text:""},{stage:0,text:"function find_Kth_smallest(lists, k) {"},{stage:1,text:"  const minHeap = new Heap((a, b) => a[0] <= b[0]);"},{stage:0,text:""},{stage:2,text:"  for (let i = 0; i < lists.length; i++) {"},{stage:3,text:"    minHeap.add([lists[i][0], 0, lists[i]]);"},{stage:2,text:"  }"},{stage:0,text:""},{stage:4,text:"  let numberCount = 0;"},{stage:4,text:"  let number = 0;"},{stage:5,text:"  let i;"},{stage:5,text:"  let list;"},{stage:6,text:"  while (minHeap.length() > 0) {"},{stage:7,text:"    [number, i, list] = minHeap.poll();"},{stage:8,text:"    numberCount += 1;"},{stage:9,text:"    if (numberCount === k) {"},{stage:10,text:"      break;"},{stage:9,text:"    }"},{stage:0,text:""},{stage:11,text:"    if (list.length > i + 1) {"},{stage:12,text:"      minHeap.add([list[i + 1], i + 1, list]);"},{stage:11,text:"    }"},{stage:6,text:"  }"},{stage:0,text:""},{stage:13,text:"  return number;"},{stage:0,text:"}"},{stage:0,text:""}]},185:{problemID:185,problemName:"Kth Smallest Number in a Sorted Matrix",problemText:"Given an N * NN\u2217N matrix where each row and column is sorted in ascending order, find the Kth smallest element in the matrix.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_Kth_smallest(\n        [\n          [2, 6, 8],\n          [3, 7, 10],\n          [5, 8, 11],\n        ],\n        5,\n      );",expected:7}],setupCode:"".concat(G),source:["https://www.educative.io/courses/grokking-the-coding-interview/x1NJVYKNvqz"],tags:["K-Way-Merge",d],solution:[{stage:0,text:""},{stage:0,text:"function find_Kth_smallest(matrix, k) {"},{stage:1,text:"  const minHeap = new Heap((a, b) => a[0] <= b[0]);"},{stage:0,text:""},{stage:2,text:"  for (let i = 0; i < Math.min(k, matrix.length); i++) {"},{stage:3,text:"    minHeap.add([matrix[i][0], 0, matrix[i]]);"},{stage:2,text:"  }"},{stage:0,text:""},{stage:4,text:"  let numberCount = 0;"},{stage:4,text:"  let number = 0;"},{stage:5,text:"  let i;"},{stage:5,text:"  let row;"},{stage:0,text:""},{stage:6,text:"  while (minHeap.length() > 0) {"},{stage:7,text:"    [number, i, row] = minHeap.poll();"},{stage:8,text:"    numberCount += 1;"},{stage:9,text:"    if (numberCount === k) {"},{stage:10,text:"      break;"},{stage:9,text:"    }"},{stage:0,text:""},{stage:11,text:"    if (row.length > i + 1) {"},{stage:12,text:"      minHeap.add([row[i + 1], i + 1, row]);"},{stage:11,text:"    }"},{stage:6,text:"  }"},{stage:0,text:""},{stage:13,text:"  return number;"},{stage:0,text:"}"},{stage:0,text:""}]},186:{problemID:186,problemName:"Smallest Number Range",problemText:"Given \u2018M\u2019 sorted arrays, find the smallest range that includes at least one number from each of the \u2018M\u2019 lists.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_smallest_range([\n        [1, 5, 8],\n        [4, 12],\n        [7, 8, 10],\n      ]);",expected:JSON.stringify([4,7])}],setupCode:"".concat(G),source:["https://www.educative.io/courses/grokking-the-coding-interview/JPGWDNRx3w2"],tags:["K-Way-Merge",d],solution:[{stage:0,text:""},{stage:0,text:"function find_smallest_range(lists) {"},{stage:1,text:"  const minHeap = new Heap((a, b) => a[0] <= b[0]);"},{stage:2,text:"  let rangeStart = 0;"},{stage:2,text:"  let rangeEnd = Infinity;"},{stage:3,text:"  let currentMaxNumber = -Infinity;"},{stage:0,text:""},{stage:4,text:"  lists.forEach(list => {"},{stage:5,text:"    minHeap.add([list[0], 0, list]);"},{stage:6,text:"    currentMaxNumber = Math.max(currentMaxNumber, list[0]);"},{stage:4,text:"  });"},{stage:0,text:""},{stage:7,text:"  while (minHeap.length() === lists.length) {"},{stage:8,text:"    const [num, i, list] = minHeap.poll();"},{stage:9,text:"    if (rangeEnd - rangeStart > currentMaxNumber - num) {"},{stage:10,text:"      rangeStart = num;"},{stage:10,text:"      rangeEnd = currentMaxNumber;"},{stage:9,text:"    }"},{stage:11,text:"    if (list.length > i + 1) {"},{stage:12,text:"      minHeap.add([list[i + 1], i + 1, list]);"},{stage:13,text:"      currentMaxNumber = Math.max(currentMaxNumber, list[i + 1]);"},{stage:11,text:"    }"},{stage:7,text:"  }"},{stage:0,text:""},{stage:14,text:"  return [rangeStart, rangeEnd];"},{stage:0,text:"}"},{stage:0,text:""}]},187:{problemID:187,problemName:"K Pairs with Largest Sums",problemText:"Given two sorted arrays in descending order, find \u2018K\u2019 pairs with the largest sum where each pair consists of numbers from both the arrays.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_k_largest_pairs([9, 8, 2], [6, 3, 1], 3);",expected:JSON.stringify([[9,3],[8,6],[9,6]])}],setupCode:"".concat(G),source:["https://www.educative.io/courses/grokking-the-coding-interview/N767x7VoYmK"],tags:["K-Way-Merge",d],solution:[{stage:0,text:""},{stage:0,text:"function find_k_largest_pairs(nums1, nums2, k) {"},{stage:1,text:"  const minHeap = new Heap((a, b) => a[0] <= b[0]);"},{stage:2,text:"  for (let i = 0; i < Math.min(k, nums1.length); i++) {"},{stage:0,text:""},{stage:3,text:"    for (let j = 0; j < Math.min(k, nums2.length); j++) {"},{stage:4,text:"      if (minHeap.length() < k) {"},{stage:5,text:"        minHeap.add([nums1[i] + nums2[j], i, j]);"},{stage:4,text:"      } else {"},{stage:6,text:"        if (nums1[i] + nums2[j] < minHeap.peek()[0]) {"},{stage:7,text:"          break;"},{stage:6,text:"        } else {"},{stage:8,text:"          minHeap.poll();"},{stage:9,text:"          minHeap.add([nums1[i] + nums2[j], i, j]);"},{stage:6,text:"        }"},{stage:4,text:"      }"},{stage:3,text:"    }"},{stage:2,text:"  }"},{stage:0,text:""},{stage:10,text:"  const result = [];"},{stage:0,text:""},{stage:11,text:"  while (minHeap.length()) {"},{stage:12,text:"    const a = minHeap.poll();"},{stage:13,text:"    result.push([nums1[a[1]], nums2[a[2]]]);"},{stage:11,text:"  }"},{stage:0,text:""},{stage:14,text:"  return result;"},{stage:0,text:"}"},{stage:0,text:""}]},188:{problemID:188,problemName:"Tasks Scheduling",problemText:"There are \u2018N\u2019 tasks, labeled from \u20180\u2019 to \u2018N-1\u2019. Each task can have some prerequisite tasks which need to be completed before it can be scheduled. Given the number of tasks and a list of prerequisite pairs, find out if it is possible to schedule all the tasks.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"is_scheduling_possible(3, [\n        [0, 1],\n        [1, 2],\n      ]);",expected:!0},{id:2,name:"example 2",inherit:[],code:"",evaluate:"is_scheduling_possible(3, [\n        [0, 1],\n        [1, 2],\n        [2, 0],\n      ]);",expected:!1},{id:3,name:"example 3",inherit:[],code:"",evaluate:"is_scheduling_possible(6, [\n        [0, 4],\n        [1, 4],\n        [3, 2],\n        [1, 3],\n      ]);",expected:!0}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/gxJrM9goEMr"],tags:["Topological Sort",d],solution:[{stage:0,text:""},{stage:0,text:"function is_scheduling_possible(tasks, prerequisites) {"},{stage:1,text:"  const sortedOrder = [];"},{stage:2,text:"  if (tasks <= 0) {"},{stage:3,text:"    return false;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:4,text:"  const inDegree = Array(tasks).fill(0);"},{stage:0,text:""},{stage:5,text:"  const graph = Array(tasks)"},{stage:5,text:"    .fill(0)"},{stage:5,text:"    .map(() => Array());"},{stage:0,text:""},{stage:6,text:"  prerequisites.forEach(prerequisite => {"},{stage:7,text:"    let parent = prerequisite[0];"},{stage:7,text:"    let child = prerequisite[1];"},{stage:8,text:"    graph[parent].push(child);"},{stage:8,text:"    inDegree[child]++;"},{stage:6,text:"  });"},{stage:0,text:""},{stage:9,text:"  const sources = [];"},{stage:10,text:"  for (let i = 0; i < inDegree.length; i++) {"},{stage:11,text:"    if (inDegree[i] === 0) {"},{stage:12,text:"      sources.push(i);"},{stage:11,text:"    }"},{stage:10,text:"  }"},{stage:0,text:""},{stage:13,text:"  while (sources.length > 0) {"},{stage:14,text:"    const vertex = sources.shift();"},{stage:15,text:"    sortedOrder.push(vertex);"},{stage:16,text:"    graph[vertex].forEach(child => {"},{stage:17,text:"      inDegree[child] -= 1;"},{stage:18,text:"      if (inDegree[child] === 0) {"},{stage:19,text:"        sources.push(child);"},{stage:18,text:"      }"},{stage:16,text:"    });"},{stage:13,text:"  }"},{stage:0,text:""},{stage:20,text:"  return sortedOrder.length === tasks;"},{stage:0,text:"}"},{stage:0,text:""}]},189:{problemID:189,problemName:"Tasks Scheduling Order",problemText:"There are \u2018N\u2019 tasks, labeled from \u20180\u2019 to \u2018N-1\u2019. Each task can have some prerequisite tasks which need to be completed before it can be scheduled. Given the number of tasks and a list of prerequisite pairs, write a method to find the ordering of tasks we should pick to finish all tasks.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_order(3, [\n        [0, 1],\n        [1, 2],\n      ]);",expected:JSON.stringify([0,1,2])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_order(3, [\n        [0, 1],\n        [1, 2],\n        [2, 0],\n      ]);",expected:JSON.stringify([])},{id:3,name:"example 3",inherit:[],code:"",evaluate:"find_order(6, [\n        [0, 4],\n        [1, 4],\n        [3, 2],\n        [1, 3],\n      ]);",expected:JSON.stringify([0,1,5,4,3,2])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/BnnArPGKolJ"],tags:["Topological Sort",d],solution:[{stage:0,text:""},{stage:0,text:"function find_order(tasks, prerequisites) {"},{stage:1,text:"  const sortedOrder = [];"},{stage:2,text:"  if (tasks <= 0) {"},{stage:3,text:"    return sortedOrder;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:4,text:"  const inDegree = Array(tasks).fill(0);"},{stage:5,text:"  const graph = Array(tasks)"},{stage:5,text:"    .fill(0)"},{stage:5,text:"    .map(() => Array());"},{stage:0,text:""},{stage:6,text:"  prerequisites.forEach(prerequisite => {"},{stage:7,text:"    let parent = prerequisite[0];"},{stage:7,text:"    let  child = prerequisite[1];"},{stage:8,text:"    graph[parent].push(child);"},{stage:8,text:"    inDegree[child]++;"},{stage:6,text:"  });"},{stage:0,text:""},{stage:9,text:"  const sources = [];"},{stage:10,text:"  for (let i = 0; i < inDegree.length; i++) {"},{stage:11,text:"    if (inDegree[i] === 0) {"},{stage:12,text:"      sources.push(i);"},{stage:11,text:"    }"},{stage:10,text:"  }"},{stage:0,text:""},{stage:13,text:"  while (sources.length > 0) {"},{stage:14,text:"    const vertex = sources.shift();"},{stage:15,text:"    sortedOrder.push(vertex);"},{stage:16,text:"    graph[vertex].forEach(child => {"},{stage:17,text:"      inDegree[child] -= 1;"},{stage:18,text:"      if (inDegree[child] === 0) {"},{stage:19,text:"        sources.push(child);"},{stage:18,text:"      }"},{stage:16,text:"    });"},{stage:13,text:"  }"},{stage:0,text:""},{stage:20,text:"  if (sortedOrder.length !== tasks) {"},{stage:21,text:"    return [];"},{stage:20,text:"  }"},{stage:0,text:""},{stage:22,text:"  return sortedOrder;"},{stage:0,text:"}"},{stage:0,text:""}]},190:{problemID:190,problemName:"All Tasks Scheduling Orders",problemText:"There are \u2018N\u2019 tasks, labeled from \u20180\u2019 to \u2018N-1\u2019. Each task can have some prerequisite tasks which need to be completed before it can be scheduled. Given the number of tasks and a list of prerequisite pairs, write a method to print all possible ordering of tasks meeting all prerequisites.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"print_orders(3, [\n        [0, 1],\n        [1, 2],\n      ]);",expected:JSON.stringify([[0,1,2]])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"print_orders(4, [\n        [3, 2],\n        [3, 0],\n        [2, 0],\n        [2, 1],\n      ]);",expected:JSON.stringify([[3,2,0,1],[3,2,1,0]])},{id:3,name:"example 3",inherit:[],code:"",evaluate:"print_orders(6, [\n        [2, 5],\n        [0, 5],\n        [0, 4],\n        [1, 4],\n        [3, 2],\n        [1, 3],\n      ]);",expected:JSON.stringify([[0,1,4,3,2,5],[0,1,3,4,2,5],[0,1,3,2,4,5],[0,1,3,2,5,4],[1,0,3,4,2,5],[1,0,3,2,4,5],[1,0,3,2,5,4],[1,0,4,3,2,5],[1,3,0,2,4,5],[1,3,0,2,5,4],[1,3,0,4,2,5],[1,3,2,0,5,4],[1,3,2,0,4,5]])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/q2YmVjQMMr3"],tags:["Topological Sort",d],solution:[{stage:0,text:""},{stage:0,text:"function print_orders(tasks, prerequisites) {"},{stage:1,text:"  const sortedOrder = [];"},{stage:2,text:"  if (tasks <= 0) {"},{stage:3,text:"    return sortedOrder;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:4,text:"  const inDegree = Array(tasks).fill(0);"},{stage:0,text:""},{stage:5,text:"  const graph = Array(tasks)"},{stage:5,text:"    .fill(0)"},{stage:5,text:"    .map(() => Array());"},{stage:0,text:""},{stage:6,text:"  prerequisites.forEach(prerequisite => {"},{stage:7,text:"    const parent = prerequisite[0];"},{stage:7,text:"    let child = prerequisite[1];"},{stage:8,text:"    graph[parent].push(child);"},{stage:8,text:"    inDegree[child]++;"},{stage:6,text:"  });"},{stage:0,text:""},{stage:9,text:"  const sources = [];"},{stage:10,text:"  for (let i = 0; i < inDegree.length; i++) {"},{stage:11,text:"    if (inDegree[i] === 0) {"},{stage:12,text:"      sources.push(i);"},{stage:11,text:"    }"},{stage:10,text:"  }"},{stage:0,text:""},{stage:13,text:"  const sorts = [];"},{stage:14,text:"  print_all_topological_sorts(graph, inDegree, sources, sortedOrder, sorts);"},{stage:15,text:"  return sorts;"},{stage:0,text:"}"},{stage:0,text:""},{stage:16,text:"function print_all_topological_sorts(graph, inDegree, sources, sortedOrder, sorts) {"},{stage:17,text:"  if (sources.length > 0) {"},{stage:18,text:"    for (let i = 0; i < sources.length; i++) {"},{stage:19,text:"      const vertex = sources[i];"},{stage:20,text:"      sortedOrder.push(vertex);"},{stage:21,text:"      const sourcesForNextCall = sources.slice(0);"},{stage:22,text:"      sourcesForNextCall.splice(sourcesForNextCall.indexOf(vertex), 1);"},{stage:0,text:""},{stage:23,text:"      graph[vertex].forEach(child => {"},{stage:24,text:"        inDegree[child]--;"},{stage:25,text:"        if (inDegree[child] === 0) {"},{stage:26,text:"          sourcesForNextCall.push(child);"},{stage:25,text:"        }"},{stage:23,text:"      });"},{stage:0,text:""},{stage:27,text:"      print_all_topological_sorts(graph, inDegree, sourcesForNextCall, sortedOrder, sorts);"},{stage:0,text:""},{stage:28,text:"      sortedOrder.splice(sortedOrder.indexOf(vertex), 1);"},{stage:29,text:"      for (let p = 0; p < graph[vertex].length; p++) {"},{stage:30,text:"        inDegree[graph[vertex][p]] += 1;"},{stage:29,text:"      }"},{stage:18,text:"    }"},{stage:17,text:"  }"},{stage:0,text:""},{stage:31,text:"  if (sortedOrder.length === inDegree.length) {"},{stage:32,text:"    sorts.push(sortedOrder.slice(0));"},{stage:31,text:"  }"},{stage:16,text:"}"},{stage:0,text:""}]},191:{problemID:191,problemName:"Alien Dictionary",problemText:"There is a dictionary containing words from an alien language for which we don\u2019t know the ordering of the alphabets. Write a method to find the correct order of the alphabets in the alien language. It is given that the input is a valid dictionary and there exists an ordering among its alphabets.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_order(['ba', 'bc', 'ac', 'cab']);",expected:"bac"},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_order(['cab', 'aaa', 'aab']);",expected:"cab"},{id:3,name:"example 3",inherit:[],code:"",evaluate:"find_order(['ywx', 'wz', 'xww', 'xz', 'zyy', 'zwz']);",expected:"ywxz"}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/R8AJWOMxw2q"],tags:["Topological Sort",d],solution:[{stage:0,text:""},{stage:0,text:"function find_order(words) {"},{stage:1,text:"  if (words.length === 0) {"},{stage:2,text:"    return '';"},{stage:1,text:"  }"},{stage:0,text:""},{stage:3,text:"  const inDegree = {};"},{stage:3,text:"  const graph = {};"},{stage:0,text:""},{stage:4,text:"  words.forEach(word => {"},{stage:5,text:"    for (let i = 0; i < word.length; i++) {"},{stage:6,text:"      inDegree[word[i]] = 0;"},{stage:6,text:"      graph[word[i]] = [];"},{stage:5,text:"    }"},{stage:4,text:"  });"},{stage:0,text:""},{stage:7,text:"  for (let i = 0; i < words.length - 1; i++) {"},{stage:8,text:"    let w1 = words[i];"},{stage:8,text:"    let w2 = words[i + 1];"},{stage:9,text:"    for (let j = 0; j < Math.min(w1.length, w2.length); j++) {"},{stage:10,text:"      let parent = w1[j];"},{stage:10,text:"      let child = w2[j];"},{stage:11,text:"      if (parent !== child) {"},{stage:12,text:"        graph[parent].push(child);"},{stage:13,text:"        inDegree[child] += 1;"},{stage:13,text:"        break;"},{stage:11,text:"      }"},{stage:9,text:"    }"},{stage:7,text:"  }"},{stage:0,text:""},{stage:14,text:"  const sources = [];"},{stage:15,text:"  const chars = Object.keys(inDegree);"},{stage:16,text:"  chars.forEach(key => {"},{stage:17,text:"    if (inDegree[key] === 0) {"},{stage:18,text:"      sources.push(key);"},{stage:17,text:"    }"},{stage:16,text:"  });"},{stage:0,text:""},{stage:19,text:"  const sortedOrder = [];"},{stage:20,text:"  while (sources.length > 0) {"},{stage:21,text:"    let vertex = sources.shift();"},{stage:22,text:"    sortedOrder.push(vertex);"},{stage:23,text:"    graph[vertex].forEach(child => {"},{stage:24,text:"      inDegree[child] -= 1;"},{stage:25,text:"      if (inDegree[child] === 0) {"},{stage:26,text:"        sources.push(child);"},{stage:25,text:"      }"},{stage:23,text:"    });"},{stage:20,text:"  }"},{stage:0,text:""},{stage:27,text:"  if (sortedOrder.length !== chars.length) {"},{stage:28,text:"    return '';"},{stage:27,text:"  }"},{stage:0,text:""},{stage:29,text:"  return sortedOrder.join('');"},{stage:0,text:"}"},{stage:0,text:""}]},192:{problemID:192,problemName:"Reconstructing a Sequence",problemText:"Given a sequence originalSeq and an array of sequences, write a method to find if originalSeq can be uniquely reconstructed from the array of sequences.\n\n  Unique reconstruction means that we need to find if originalSeq is the only sequence such that all sequences in the array are subsequences of it.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"can_construct(\n        [1, 2, 3, 4],\n        [\n          [1, 2],\n          [2, 3],\n          [3, 4],\n        ],\n      );",expected:!0},{id:2,name:"example 2",inherit:[],code:"",evaluate:"can_construct(\n        [1, 2, 3, 4],\n        [\n          [1, 2],\n          [2, 3],\n          [2, 4],\n        ],\n      );",expected:!1},{id:3,name:"example 3",inherit:[],code:"",evaluate:"can_construct(\n        [3, 1, 4, 2, 5],\n        [\n          [3, 1, 5],\n          [1, 4, 2, 5],\n        ],\n      );",expected:!0}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/m7VAO5OrQr3"],tags:["Topological Sort",d],solution:[{stage:0,text:""},{stage:0,text:"function can_construct(originalSeq, sequences) {"},{stage:1,text:"  const sortedOrder = [];"},{stage:2,text:"  if (originalSeq.length <= 0) {"},{stage:3,text:"    return false;"},{stage:2,text:"  }"},{stage:0,text:""},{stage:4,text:"  const inDegree = {};"},{stage:4,text:"  const graph = {};"},{stage:0,text:""},{stage:5,text:"  sequences.forEach(sequence => {"},{stage:6,text:"    for (let i = 0; i < sequence.length; i++) {"},{stage:7,text:"      inDegree[sequence[i]] = 0;"},{stage:7,text:"      graph[sequence[i]] = [];"},{stage:6,text:"    }"},{stage:5,text:"  });"},{stage:0,text:""},{stage:8,text:"  sequences.forEach(sequence => {"},{stage:9,text:"    for (let i = 1; i < sequence.length; i++) {"},{stage:10,text:"      const parent = sequence[i - 1];"},{stage:10,text:"      let child = sequence[i];"},{stage:11,text:"      graph[parent].push(child);"},{stage:11,text:"      inDegree[child] += 1;"},{stage:9,text:"    }"},{stage:8,text:"  });"},{stage:0,text:""},{stage:12,text:"  const vertices = Object.keys(inDegree);"},{stage:13,text:"  if (vertices.length !== originalSeq.length) {"},{stage:14,text:"    return false;"},{stage:13,text:"  }"},{stage:0,text:""},{stage:15,text:"  const sources = [];"},{stage:16,text:"  vertices.forEach(key => {"},{stage:17,text:"    if (inDegree[key] === 0) {"},{stage:18,text:"      sources.push(key);"},{stage:17,text:"    }"},{stage:16,text:"  });"},{stage:0,text:""},{stage:19,text:"  while (sources.length > 0) {"},{stage:20,text:"    if (sources.length > 1) {"},{stage:21,text:"      return false;"},{stage:20,text:"    }"},{stage:22,text:"    if (originalSeq[sortedOrder.length] != sources[sources.length - 1]) {"},{stage:23,text:"      return false;"},{stage:22,text:"    }"},{stage:0,text:""},{stage:24,text:"    const vertex = sources.shift();"},{stage:25,text:"    sortedOrder.push(vertex);"},{stage:26,text:"    graph[vertex].forEach(child => {"},{stage:27,text:"      inDegree[child] -= 1;"},{stage:28,text:"      if (inDegree[child] === 0) {"},{stage:29,text:"        sources.push(child);"},{stage:28,text:"      }"},{stage:26,text:"    });"},{stage:19,text:"  }"},{stage:0,text:""},{stage:30,text:"  return sortedOrder.length === originalSeq.length;"},{stage:0,text:"}"},{stage:0,text:""}]},193:{problemID:193,problemName:"Minimum Height Trees",problemText:"We are given an undirected graph that has characteristics of a k-ary tree. In such a graph, we can choose any node as the root to make a k-ary tree. The root (or the tree) with the minimum height will be called Minimum Height Tree (MHT). There can be multiple MHTs for a graph. In this problem, we need to find all those roots which give us MHTs. Write a method to find all MHTs of the given graph and return a list of their roots.",testCases:[{id:1,name:"example 1",inherit:[],code:"",evaluate:"find_trees(5, [\n        [0, 1],\n        [1, 2],\n        [1, 3],\n        [2, 4],\n      ]);",expected:JSON.stringify([1,2])},{id:2,name:"example 2",inherit:[],code:"",evaluate:"find_trees(4, [\n        [0, 1],\n        [0, 2],\n        [2, 3],\n      ]);",expected:JSON.stringify([0,2])},{id:3,name:"example 3",inherit:[],code:"",evaluate:"find_trees(4, [\n        [1, 2],\n        [1, 3],\n      ]);",expected:JSON.stringify([1])}],setupCode:"",source:["https://www.educative.io/courses/grokking-the-coding-interview/7nDN8y7JKVA"],tags:["Topological Sort",d],solution:[{stage:0,text:""},{stage:0,text:"function find_trees(nodes, edges) {"},{stage:1,text:"  if (nodes <= 0) {"},{stage:2,text:"    return [];"},{stage:1,text:"  }"},{stage:0,text:""},{stage:3,text:"  if (nodes === 1) {"},{stage:4,text:"    return [0];"},{stage:3,text:"  }"},{stage:0,text:""},{stage:5,text:"  const inDegree = Array(nodes).fill(0);"},{stage:0,text:""},{stage:6,text:"  const graph = Array(nodes)"},{stage:6,text:"    .fill(0)"},{stage:6,text:"    .map(() => Array());"},{stage:0,text:""},{stage:7,text:"  edges.forEach(edge => {"},{stage:8,text:"    let n1 = edge[0];"},{stage:8,text:"    let n2 = edge[1];"},{stage:9,text:"    graph[n1].push(n2);"},{stage:9,text:"    graph[n2].push(n1);"},{stage:10,text:"    inDegree[n1] += 1;"},{stage:10,text:"    inDegree[n2] += 1;"},{stage:7,text:"  });"},{stage:0,text:""},{stage:11,text:"  const leaves = [];"},{stage:12,text:"  for (let i = 0; i < inDegree.length; i++) {"},{stage:13,text:"    if (inDegree[i] === 1) {"},{stage:14,text:"      leaves.push(i);"},{stage:13,text:"    }"},{stage:12,text:"  }"},{stage:0,text:""},{stage:15,text:"  let totalNodes = nodes;"},{stage:16,text:"  while (totalNodes > 2) {"},{stage:17,text:"    let leavesSize = leaves.length;"},{stage:17,text:"    totalNodes -= leavesSize;"},{stage:0,text:""},{stage:18,text:"    for (let i = 0; i < leavesSize; i++) {"},{stage:19,text:"      let vertex = leaves.shift();"},{stage:0,text:""},{stage:20,text:"      graph[vertex].forEach(child => {"},{stage:21,text:"        inDegree[child] -= 1;"},{stage:22,text:"        if (inDegree[child] === 1) {"},{stage:23,text:"          leaves.push(child);"},{stage:22,text:"        }"},{stage:20,text:"      });"},{stage:0,text:""},{stage:18,text:"    }"},{stage:16,text:"  }"},{stage:0,text:""},{stage:24,text:"  return leaves;"},{stage:0,text:"}"},{stage:0,text:""}]},194:{problemID:194,problemName:"Range Sum Query 2D - Immutable",problemText:"Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).\n\n  Implement the NumMatrix class:\n  \n  NumMatrix(int[][] matrix) initializes the object with the integer matrix matrix.\n  \n  int sumRegion(int row1, int col1, int row2, int col2) returns the sum of the elements of the matrix array inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).",testCases:[{id:1,name:"example 1",inherit:[],code:"const numMatrix = new NumMatrix([\n        [3, 0, 1, 4, 2],\n        [5, 6, 3, 2, 1],\n        [1, 2, 0, 1, 5],\n        [4, 1, 0, 1, 7],\n        [1, 0, 3, 0, 5],\n      ]);",evaluate:"numMatrix.sumRegion(2, 1, 4, 3);",expected:8},{id:2,name:"example 2",inherit:[1],code:"",evaluate:"numMatrix.sumRegion(1, 1, 2, 2);",expected:11},{id:3,name:"example 3",inherit:[1],code:"",evaluate:"numMatrix.sumRegion(1, 2, 2, 4);",expected:12}],setupCode:"",lcid:304,source:[],tags:[d,"Dynamic Programming","Facebook","Cruise"],solution:[{stage:0,text:""},{stage:0,text:"class NumMatrix {"},{stage:0,text:"  constructor(matrix) {"},{stage:1,text:"    this.matrix = matrix;"},{stage:1,text:"    this.cache = [];"},{stage:1,text:"    this.preCompute();"},{stage:0,text:"  }"},{stage:0,text:""},{stage:2,text:"  preCompute() {"},{stage:3,text:"    for (let row = 0; row < this.matrix.length; row++) {"},{stage:4,text:"      this.cache[row] = [];"},{stage:0,text:""},{stage:5,text:"      for (let col = 0; col < this.matrix[0].length; col++) {"},{stage:6,text:"        let prevCol = col > 0 ? this.cache[row][col - 1] : 0;"},{stage:7,text:"        let prevRow = row > 0 ? this.cache[row - 1][col] : 0;"},{stage:8,text:"        let prevCache = row > 0 && col > 0 ? this.cache[row - 1][col - 1] : 0;"},{stage:9,text:"        let sum = this.matrix[row][col] + prevCol + prevRow - prevCache;"},{stage:10,text:"        this.cache[row].push(sum);"},{stage:5,text:"      }"},{stage:3,text:"    }"},{stage:2,text:"  }"},{stage:0,text:""},{stage:11,text:"  sumRegion(row1, col1, row2, col2) {"},{stage:12,text:"    let totalArea = this.cache[row2][col2];"},{stage:13,text:"    let topArea = row1 > 0 ? this.cache[row1 - 1][col2] : 0;"},{stage:14,text:"    let sideArea = col1 > 0 ? this.cache[row2][col1 - 1] : 0;"},{stage:15,text:"    let cornerArea = row1 > 0 && col1 > 0 ? this.cache[row1 - 1][col1 - 1] : 0;"},{stage:0,text:""},{stage:16,text:"    return totalArea - topArea - sideArea + cornerArea;"},{stage:11,text:"  }"},{stage:0,text:"}"},{stage:0,text:""}]},195:{problemID:195,problemName:"Minesweeper",problemText:"You are given a 2D char matrix representing the game board. 'M' represents an unrevealed mine, 'E' represents an unrevealed empty square, 'B' represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit ('1' to '8') represents how many mines are adjacent to this revealed square, and finally 'X' represents a revealed mine.\n  \n  Now given the next click position (row and column indices) among all the unrevealed squares ('M' or 'E'), return the board after revealing this position according to the following rules:\n  \n  If a mine ('M') is revealed, then the game is over - change it to 'X'.\n\n  If an empty square ('E') with no adjacent mines is revealed, then change it to revealed blank ('B') and all of its adjacent unrevealed squares should be revealed recursively.\n\n  If an empty square ('E') with at least one adjacent mine is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines.\n\n  Return the board when no more squares will be revealed.",testCases:[{id:1,name:"example 1",inherit:[],code:"const board = [\n        ['E', 'E', 'E', 'E', 'E'],\n        ['E', 'E', 'M', 'E', 'E'],\n        ['E', 'E', 'E', 'E', 'E'],\n        ['E', 'E', 'E', 'E', 'E'],\n      ];\n      \n      const click = [3, 0];",evaluate:"updateBoard(board, click);",expected:JSON.stringify([["B","1","E","1","B"],["B","1","M","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]])},{id:2,name:"example 2",inherit:[],code:"const board2 = [\n        ['B', '1', 'E', '1', 'B'],\n        ['B', '1', 'M', '1', 'B'],\n        ['B', '1', '1', '1', 'B'],\n        ['B', 'B', 'B', 'B', 'B'],\n      ];\n      \n      const click2 = [1, 2];",evaluate:"updateBoard(board2, click2);",expected:JSON.stringify([["B","1","E","1","B"],["B","1","X","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]])}],setupCode:"",lcid:529,source:[],tags:["Cruise",d,f],solution:[{stage:0,text:""},{stage:13,text:"const NEXT_COORD_OFFSETS = ["},{stage:14,text:"  [1, -1],"},{stage:14,text:"  [1, 0],"},{stage:14,text:"  [1, 1],"},{stage:14,text:"  [0, 1],"},{stage:14,text:"  [0, -1],"},{stage:14,text:"  [-1, -1],"},{stage:14,text:"  [-1, 0],"},{stage:14,text:"  [-1, 1],"},{stage:13,text:"];"},{stage:0,text:""},{stage:0,text:"function updateBoard(board, click) {"},{stage:1,text:"  const [x, y] = click;"},{stage:0,text:""},{stage:2,text:"  if (board[x][y] === 'M') {"},{stage:3,text:"    board[x][y] = 'X';"},{stage:2,text:"  } else if (board[x][y] === 'E') {"},{stage:4,text:"    propagateClick(board, click);"},{stage:2,text:"  }"},{stage:0,text:""},{stage:5,text:"  return board;"},{stage:0,text:"}"},{stage:0,text:""},{stage:6,text:"function propagateClick(board, coords) {"},{stage:7,text:"  const [x, y] = coords;"},{stage:0,text:""},{stage:8,text:"  if (!board[x] || board[x][y] !== 'E') return;"},{stage:0,text:""},{stage:9,text:"  const sum = NEXT_COORD_OFFSETS.reduce((acc, [xOffset, yOffset]) => {"},{stage:10,text:"    if ((Math.abs(xOffset) === 1 && board[x + xOffset]) || !xOffset) {"},{stage:11,text:"      return board[x + xOffset][y + yOffset] === 'M' ? acc + 1 : acc;"},{stage:10,text:"    }"},{stage:0,text:""},{stage:12,text:"    return acc;"},{stage:9,text:"  }, 0);"},{stage:0,text:""},{stage:15,text:"  if (sum === 0) {"},{stage:16,text:"    board[x][y] = 'B';"},{stage:0,text:""},{stage:17,text:"    NEXT_COORD_OFFSETS.forEach(([xOffset, yOffset]) => {"},{stage:18,text:"      if ((Math.abs(xOffset) === 1 && board[x + xOffset]) || !xOffset) {"},{stage:19,text:"        propagateClick(board, [x + xOffset, y + yOffset]);"},{stage:18,text:"      }"},{stage:17,text:"    });"},{stage:15,text:"  } else {"},{stage:20,text:"    board[x][y] = sum.toString();"},{stage:15,text:"  }"},{stage:6,text:"}"},{stage:0,text:""}]}};Object.keys(Rt).forEach((function(e){var t=Rt[e],a=0;t.solution.forEach((function(e){e.stage>0&&a++})),Rt[e].effort=a,a>30?Rt[e].tags.push("Expert"):a>22?Rt[e].tags.push("Advanced"):a>14?Rt[e].tags.push("Intermediate"):Rt[e].tags.push("Beginner")}));var Ht=Rt,Pt=[];Object.keys(Rt).forEach((function(e){Rt[e].tags.forEach((function(e){Pt.push(e)}))}));var Bt=Array.from(new Set(Pt)).sort(),At=a(60),Jt=a.n(At),Gt=a(84),Ft=a(90),Wt=a.n(Ft),Kt=a(114),Vt=a(95),zt=a(9),Yt=a(45),Ut=Object(Yt.c)({name:"game",initialState:{value:"",value2:"",results:[],revealButtonPressed:!1,isBusyTesting:!1,activeIndex:0,totalSeconds:0,isRunning:!1,open:!1,noteCode:"",tableSort:"id",sessionHistory:[]},reducers:{setValue:function(e,t){t.type;var a=t.payload;e.value=a},setValue2:function(e,t){t.type;var a=t.payload;e.value2=a},setResults:function(e,t){t.type;var a=t.payload;e.results=a},setRevealButtonPressed:function(e,t){t.type;var a=t.payload;e.revealButtonPressed=a},setIsBusyTesting:function(e,t){t.type;var a=t.payload;e.setIsBusyTesting=a},setActiveIndex:function(e,t){t.type;var a=t.payload;e.activeIndex=a},setTotalSeconds:function(e,t){t.type;var a=t.payload;e.totalSeconds=a},setOpen:function(e,t){t.type;var a=t.payload;e.open=a},setNoteCode:function(e,t){t.type;var a=t.payload;e.noteCode=a},updateTableSort:function(e,t){t.type;var a=t.payload;e.tableSort=a},setSessionHistory:function(e,t){t.type;var a=t.payload;e.sessionHistory=a},incrementTotalSeconds:function(e,t){t.type,t.payload;e.totalSeconds=e.totalSeconds+1},setIsRunning:function(e,t){t.type;var a=t.payload;e.isRunning=a},startRunningTests:function(e,t){t.type,t.payload;e.results=[],e.activeIndex=1,e.isBusyTesting=!0},concludeRunningTests:function(e,t){t.type;var a=t.payload,n=a.r,s=a.entry;e.results=n,e.isBusyTesting=!1,n.every((function(e){return e.ok}))&&!e.revealButtonPressed&&(e.isRunning=!1,e.sessionHistory.push(s),e.revealButtonPressed=!0)},clickNextToResults:function(e,t){t.type,t.payload;e.totalSeconds=0,e.isRunning=!1,e.revealButtonPressed=!1,e.activeIndex=0,e.value="",e.results=[]},clickSkipToResults:function(e,t){t.type;var a=t.payload;e.revealButtonPressed||e.sessionHistory.push({id:a,seconds:null}),e.totalSeconds=0,e.isRunning=!1,e.revealButtonPressed=!1,e.activeIndex=0,e.value="",e.results=[]},clickNext:function(e,t){t.type,t.payload;e.totalSeconds=0,e.isRunning=!0,e.revealButtonPressed=!1,e.activeIndex=0,e.value="",e.results=[]},clickSkip:function(e,t){t.type;var a=t.payload;e.revealButtonPressed||e.sessionHistory.push({id:a,seconds:null}),e.totalSeconds=0,e.isRunning=!0,e.revealButtonPressed=!1,e.activeIndex=0,e.value="",e.results=[]},revealAnswer:function(e,t){t.type;var a=t.payload,n=a.id,s=a.data;e.revealButtonPressed=!0,e.isRunning=!1,e.sessionHistory.push({id:n,seconds:null}),e.value2=s.solution.map((function(e){return e.text})).join("\n")}}}),Qt=Ut.actions,Xt=Qt.setValue,Zt=Qt.setValue2,$t=(Qt.setResults,Qt.setRevealButtonPressed),ea=(Qt.setIsBusyTesting,Qt.setActiveIndex),ta=(Qt.setTotalSeconds,Qt.setOpen),aa=Qt.setNoteCode,na=Qt.updateTableSort,sa=Qt.setSessionHistory,ra=Qt.incrementTotalSeconds,ia=Qt.setIsRunning,oa=Qt.startRunningTests,la=Qt.concludeRunningTests,ga=Qt.clickNextToResults,xa=Qt.clickSkipToResults,da=Qt.clickNext,ca=Qt.clickSkip,ua=Qt.revealAnswer,ha=Ut.reducer,pa=a(130),ma=a(131);function fa(){return new Worker(a.p+"static/js/worker.cdb86241.worker.js")}function va(e){try{var t=localStorage.getItem("personalBests"),a=JSON.parse(t);if(!a)throw new Error("Need to populate initial data.");var n=a[e.id];(!n||e.seconds<n)&&(a[e.id]=e.seconds,localStorage.setItem("personalBests",JSON.stringify(a)))}catch(r){var s={};s[e.id]=e.seconds,localStorage.setItem("personalBests",JSON.stringify(s))}}function wa(){try{var e=localStorage.getItem("personalBests"),t=JSON.parse(e);if(!t)throw new Error("Need to populate initial data.");return t}catch(n){var a={};return localStorage.setItem("personalBests",JSON.stringify(a)),a}}var ba=a(8);function ya(e,t,a,n,s){var r,i=";",o=Object(ba.a)(t);try{var l=function(){var t=r.value,a=e.find((function(e){return e.id===t}));a?i+=a.code:console.error("Could not find testCase id: ".concat(t))};for(o.s();!(r=o.n()).done;)l()}catch(g){o.e(g)}finally{o.f()}return{test:i+a+n,text:"/* Test Code */\n\n\n".concat(i).concat(a,"\n\n\n/* Evaluation Code */\n\n\n").concat(n,"\n\n\n/* Implicit Code Below */\n\n\n").concat(s)}}function ka(e){if(!e)return"00:00:00";var t=function(e){var t=0,a=0;e>3600&&(t=Math.floor(e/3600),e%=3600);e>60&&(a=Math.floor(e/60),e%=60);return{hours:t,minutes:a,seconds:e}}(e),a=t.hours,n=t.minutes,s=t.seconds;return"".concat(String(a).padStart(2,"0"),":").concat(String(n).padStart(2,"0"),":").concat(String(s).padStart(2,"0"))}function Na(e,t,a,n){var s=wa()[t.problemID],r="green";return s&&e>s&&(r="blue"),(e>30*Math.max.apply(Math,Object(l.a)(t.solution.map((function(e){return e.stage}))))+60||a)&&(r="red"),n&&(r="green"),r}var Ia=Object(Yt.b)("",function(){var e=Object(Gt.a)(Jt.a.mark((function e(t,a){var n,s,r,i;return Jt.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return n=a.getState(),s=n.game.value,r=Ht[t],a.dispatch(oa()),i=r.testCases.map(function(){var e=Object(Gt.a)(Jt.a.mark((function e(t){var a,n,i,o,l,g,x,d,c;return Jt.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return a=new fa,n=ma.b(a),i="",o=n.evaluate(s+r.setupCode+ya(r.testCases,t.inherit,t.code,t.evaluate,"").test).catch((function(e){i=e.message})),l=new Promise((function(e,t){setTimeout(t,2e3,new Error("Timeout"))})).catch((function(e){i=e.message})),e.next=7,Promise.race([o,l]);case 7:return g=e.sent,n[ma.a](),a.terminate(),x="",x="object"===typeof g&&null!=g?JSON.stringify(g):g,d=t.expected===x&&!i,c="string"!==typeof x?JSON.stringify(x):x,e.abrupt("return",Object(pa.a)(Object(pa.a)({},t),{},{actual:c,error:i,ok:d}));case 15:case"end":return e.stop()}}),e)})));return function(t){return e.apply(this,arguments)}}()),e.next=7,Promise.all(i).then((function(e){var s={id:t,seconds:n.game.totalSeconds};a.dispatch(la({r:e,entry:s})),va(s)}));case 7:case"end":return e.stop()}}),e)})));return function(t,a){return e.apply(this,arguments)}}()),Ca=a(20);var _a=function(){var e=Object(zt.b)(),t=Object(zt.c)((function(e){return e.game.value})),a=s.useRef(),n=s.useRef({}),r=Object(Ca.g)().id;return n.current.id=r,s.createElement("div",{style:{padding:"1vh 1vw",width:"48.5vw",backgroundColor:"ivory",borderRadius:"5px"}},s.createElement(Wt.a,{ref:a,placeholder:"Enter text here...",mode:"javascript",theme:"dawn",name:"editor1",onChange:function(t){e(Xt(t)),a.current.editor.resize()},value:t,width:"47vw",height:"59vh",showGutter:!0,highlightActiveLine:!0,wrapEnabled:!0,setOptions:{enableBasicAutocompletion:!0,enableLiveAutocompletion:!0,showLineNumbers:!0,tabSize:2},commands:[{name:"prettier",bindKey:{win:"Ctrl-S",mac:"Cmd-S"},exec:function(t){try{var a=Kt.a.format(t.session.getValue(),{parser:"babel",plugins:[Vt.a]});e(Xt(a))}catch(n){console.log("There was an error in compilation.")}}},{name:"run tests",bindKey:{win:"Ctrl-M",mac:"Cmd-M"},exec:function(){var t=Object(Gt.a)(Jt.a.mark((function t(){return Jt.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.prev=0,t.next=3,e(Ia(n.current.id));case 3:t.next=8;break;case 5:t.prev=5,t.t0=t.catch(0),console.log("Encountered an error when attempting to run tests.");case 8:case"end":return t.stop()}}),t,null,[[0,5]])})));return function(){return t.apply(this,arguments)}}()}]}))};var Sa=function(){var e=Object(zt.c)((function(e){return e.game.value2})),t=s.useRef();return s.createElement("div",{style:{padding:"1vh 1vw",width:"48.5vw",backgroundColor:"ivory",borderRadius:"5px"}},s.createElement(Wt.a,{ref:t,placeholder:"No suggestions...",mode:"javascript",theme:"github",width:"47vw",height:"59vh",name:"editor2",readOnly:!0,showGutter:!0,onChange:function(){t.current.editor.resize()},value:e,highlightActiveLine:!1,wrapEnabled:!0,setOptions:{showLineNumbers:!0,tabSize:2}}))},La=a(646),Ta=a(645),Ea=a(81),Oa=a(644),qa=a(647),Da=a(134),Ma=a.n(Da),ja=a(152),Ra=a.n(ja);a(199);Ma.a.registerLanguage("javascript",Ra.a);var Ha=function(){var e=Object(zt.b)(),t=Object(zt.c)((function(e){return e.game.open})),a=Object(zt.c)((function(e){return e.game.noteCode}));return s.createElement(Oa.a,{onClose:function(){return e(ta(!1))},onOpen:function(){return e(ta(!0))},open:t},s.createElement(Oa.a.Header,null,"Test Code"),s.createElement(Oa.a.Content,null,s.createElement("div",{style:{whiteSpace:"pre",border:"1px dotted cornflowerblue",backgroundColor:"lavender",borderRadius:"5px",padding:"1em",fontFamily:"monospace"},dangerouslySetInnerHTML:{__html:Ma.a.highlight("javascript",a).value}})),s.createElement(Oa.a.Actions,null,s.createElement(qa.a,{style:{width:"138px"},onClick:function(){return e(ta(!1))}},"Close")))};var Pa=function(){var e=Object(zt.b)(),t=Object(zt.c)((function(e){return e.game.results})),a=Object(zt.c)((function(e){return e.game.tableSort})),n=Object(Ca.g)().id,r=Object(l.a)(t).sort((function(e,t){if("id"===a)return e.id-t.id;if("fail"===a)return(e.ok?e.id+1e4:e.id)-(t.ok?t.id+1e4:t.id);if("success"===a)return(e.ok?e.id:e.id+1e4)-(t.ok?t.id:t.id+1e4);throw new Error("Invalid sort choice: ".concat(a))}));if(!r.length)return null;var i=Ht[n];return s.createElement("div",null,s.createElement(Ha,null),s.createElement(Ta.a,{celled:!0,compact:"very",className:"run-results"},s.createElement(Ta.a.Header,null,s.createElement(Ta.a.Row,null,s.createElement(Ta.a.HeaderCell,{style:{textAlign:"center"}},"ID"),s.createElement(Ta.a.HeaderCell,{style:{textAlign:"center"}},"Code"),s.createElement(Ta.a.HeaderCell,null,"Description"),s.createElement(Ta.a.HeaderCell,null,"Expected"),s.createElement(Ta.a.HeaderCell,null,"Actual"),s.createElement(Ta.a.HeaderCell,null,"Error"),s.createElement(Ta.a.HeaderCell,{onClick:function(){if("id"===a)e(na("fail"));else if("fail"===a)e(na("success"));else{if("success"!==a)throw new Error("Invalid sort choice: ".concat(a));e(na("id"))}},style:{textAlign:"center",cursor:"pointer"}},"Status"))),s.createElement(Ta.a.Body,null,r.map((function(t){return s.createElement(Ta.a.Row,{key:t.id,style:{backgroundColor:t.ok?"rgba(0, 255, 0, 0.3)":"rgba(255, 0, 0, 0.3)"}},s.createElement(Ta.a.Cell,{style:{textAlign:"center"}},t.id),s.createElement(Ta.a.Cell,{style:{textAlign:"center"}},s.createElement(Ea.a,{className:"hover-note",name:"sticky note outline",role:"button",onClick:function(){var a=ya(i.testCases,t.inherit,t.code,t.evaluate,i.setupCode).text,n=Kt.a.format(a,{parser:"babel",plugins:[Vt.a]});e(aa(n)),e(ta(!0))}})),s.createElement(Ta.a.Cell,null,t.name),s.createElement(Ta.a.Cell,null,"string"!==typeof t.expected?JSON.stringify(t.expected):t.expected),s.createElement(Ta.a.Cell,null,t.actual),s.createElement(Ta.a.Cell,null,t.error),s.createElement(Ta.a.Cell,{style:{textAlign:"center"}},t.ok?s.createElement(Ea.a,{color:"green",name:"checkmark"}):s.createElement(Ea.a,{color:"red",name:"checkmark"})))})))))},Ba=a(35),Aa=a.n(Ba),Ja=function(e){var t=e.noteSource;return t.length?s.createElement("div",{style:{marginTop:"10px",color:"grey"}},s.createElement("div",{style:{margin:"5px 0 1px 0"}},s.createElement("sub",null,"Resources")),t.map((function(e,t){return s.createElement("sub",{key:t},t+1,"."," ",s.createElement("a",{href:e,target:"_blank",rel:"noopener noreferrer"},e),s.createElement("br",null))}))):null},Ga=new Aa.a.Converter;var Fa=function(){var e=Object(zt.b)(),t=Object(zt.c)((function(e){return e.game.isBusyTesting})),a=Object(zt.c)((function(e){return e.game.activeIndex})),n=Object(zt.c)((function(e){return e.game.results})),r=Object(Ca.g)().id,i=Ht[r];if(!i)return[];var o=i.tags.find((function(e){return k.includes(e)})),l=n.length;return s.createElement(La.a,{fluid:!0,raised:!0,style:{height:"calc(32vh - 40px)"}},s.createElement("p",{style:{padding:"10px 0 0 10px"}},s.createElement("span",{className:0===a?"pane-base chosen-pane":"pane-base",onClick:function(){return e(ea(0))}},"Problem")," ","|"," ",s.createElement("span",{className:1===a?"pane-base chosen-pane":"pane-base",onClick:function(){return e(ea(1))}},"Test Results"),s.createElement("span",{style:{float:"right"}}," ",s.createElement("span",{style:{fontVariant:"small-caps"}},i.tags.filter((function(e){return!k.includes(e)&&!N.includes(e)})).join(", ")),s.createElement("span",{style:{backgroundColor:"azure",color:"black",display:"inline-block",border:"1px solid darkslategrey",borderRadius:"50%",width:"1.5em",height:"1.5em",lineHeight:"1.25em",verticalAlign:"center",boxShadow:"1px 1px 2px lightslategrey",cursor:"default",marginRight:"1em",marginLeft:"1em",textAlign:"center"},title:o},o.slice(0,1)))),s.createElement(La.a.Content,{style:{height:"calc(32vh - 70px)",overflowY:"scroll"}},0===a?s.createElement("div",null,s.createElement("div",{className:"titleStyle",dangerouslySetInnerHTML:{__html:"<h3>".concat(Ga.makeHtml("".concat(r,".&nbsp;&nbsp;&nbsp;").concat(i.problemName)),"</h3>")}}),s.createElement("div",{dangerouslySetInnerHTML:{__html:Ga.makeHtml(i.problemText)}}),s.createElement(Ja,{noteSource:i.source||[]}),s.createElement("br",null)):null,1===a?t?s.createElement("p",null,"Testing in Progress..."):l?s.createElement(Pa,{id:r}):s.createElement("p",null,"Tests have not been run yet for this problem."):null))};var Wa=function(){var e=Object(zt.b)(),t=Object(zt.c)((function(e){return e.game.value})),a=Object(zt.c)((function(e){return e.game.value2})),n=Object(zt.c)((function(e){return e.game.revealButtonPressed})),r=Object(zt.c)((function(e){return e.game.totalSeconds})),i=Object(Ca.g)().id,o=Ht[i];return s.useEffect((function(){if(o){if(!t){var s=[];o.solution.forEach((function(e){0===e.stage&&s.push(e.text)})),e(Xt(s.join("\n")))}var i=Math.max.apply(Math,Object(l.a)(o.solution.map((function(e){return e.stage}))));!n&&r>30*i+60&&(e($t(!0)),e(ia(!1)));for(var g=0,x=0;x<=i;x++){var d=0;x===i&&(d=30),r>=30+d+30*x&&(g=x)}n&&(g=1/0);var c=o.solution.map((function(e){return e.stage<=g?e.text:"  //"})).join("\n");JSON.stringify(a)!==JSON.stringify(c)&&e(Zt(c))}}),[o,n,r,t,a,e]),o?s.createElement(s.Fragment,null,s.createElement("div",{style:{padding:"1vh 1vw"}},s.createElement("div",{style:{height:"calc(35vh - 40px)",padding:"1vh 0 1vh 0vw"}},s.createElement(Fa,null)),s.createElement("div",{className:"editor-area columns"},s.createElement("div",{className:"editor-area column"},s.createElement(_a,null)),s.createElement("div",{className:"column"},s.createElement(Sa,null))))):s.createElement("p",null,"Problem Not Found")},Ka=Bt.map((function(e){return{name:e,isSelected:!1}})),Va=Object(Yt.c)({name:"filter",initialState:{selections:[],results:[],showModal:!1,activeProblemText:"",activeProblemId:"",tags:Ka},reducers:{setSelections:function(e,t){t.type;var a=t.payload;e.selections=a},shiftSelection:function(e,t){t.type,t.payload;e.selections=e.selections.slice(1)},setResults:function(e,t){t.type;var a=t.payload;e.results=a},setShowModal:function(e,t){t.type;var a=t.payload;e.showModal=a},setActiveProblemText:function(e,t){t.type;var a=t.payload;e.activeProblemText=a},setActiveProblemId:function(e,t){t.type;var a=t.payload;e.activeProblemId=a},setTags:function(e,t){t.type;var a=t.payload;e.tags=a},pressReset:function(e,t){t.type,t.payload;e.tags=Ka}}}),za=Va.actions,Ya=za.setSelections,Ua=za.setResults,Qa=za.setShowModal,Xa=za.setActiveProblemText,Za=za.setActiveProblemId,$a=za.setTags,en=za.pressReset,tn=za.shiftSelection,an=Va.reducer,nn=new Aa.a.Converter;var sn=function(){var e=Object(zt.b)(),t=Object(zt.c)((function(e){return e.game.sessionHistory})),a=wa();return s.createElement("div",{style:{paddingBottom:"30px"}},s.createElement("h2",{style:{margin:"0 auto",padding:"30px 0",textAlign:"center"}},"Session Statistics"),s.createElement(Ta.a,{style:{margin:"auto",width:"80vw",maxWidth:"1200px",letterSpacing:"1px"}},s.createElement(Ta.a.Header,null,s.createElement(Ta.a.Row,null,s.createElement(Ta.a.HeaderCell,null,"ID"),s.createElement(Ta.a.HeaderCell,null,"Name"),s.createElement(Ta.a.HeaderCell,{style:{textAlign:"center"}},"Result"),s.createElement(Ta.a.HeaderCell,{style:{textAlign:"center"}},"Best"))),s.createElement(Ta.a.Body,null,t.map((function(t,n){var r=ka(t.seconds),i=ka(a[t.id]);return s.createElement(Ta.a.Row,{key:n,style:{backgroundColor:r===i?"rgba(0,255,0,0.2)":"rgba(255,0,0,0.2)"}},s.createElement(Ta.a.Cell,null,t.id),s.createElement(Ta.a.Cell,null,s.createElement("div",{style:{display:"inline"},className:"hover-link",onClick:function(){return a=Ht[t.id].problemText,n=t.id,e(Xa(a)),e(Za(n)),void e(Qa(!0));var a,n},dangerouslySetInnerHTML:{__html:nn.makeHtml(Ht[t.id].problemName)}})),s.createElement(Ta.a.Cell,{style:{textAlign:"center"}},r),s.createElement(Ta.a.Cell,{style:{textAlign:"center"}},i))})))),t.length?s.createElement("div",{style:{width:"100%",padding:"40px 0"}},s.createElement(qa.a,{style:{width:"138px",display:"block",margin:"auto"},onClick:function(){e(sa([]))}},"Clear Stats")):s.createElement("p",{style:{padding:"10px",margin:"auto",width:"80vw"}},"The session history is empty."))},rn=a(15),on=new Aa.a.Converter;var ln=function(){var e=Object(zt.b)(),t=s.useState(0),a=Object(rn.a)(t,2),n=a[0],r=a[1],i=wa();return console.log({personalBests:i}),s.createElement("div",{style:{paddingBottom:"30px"}},s.createElement("h2",{style:{margin:"0 auto",padding:"30px 0",textAlign:"center"}},"Historic Statistics"),s.createElement(Ta.a,{style:{margin:"auto",width:"80vw",maxWidth:"1200px",letterSpacing:"1px"}},s.createElement(Ta.a.Header,null,s.createElement(Ta.a.Row,null,s.createElement(Ta.a.HeaderCell,null,"ID"),s.createElement(Ta.a.HeaderCell,null,"Name"),s.createElement(Ta.a.HeaderCell,{style:{textAlign:"center"}},"Best"))),s.createElement(Ta.a.Body,null,Object.keys(Ht).map((function(t,a){var n=ka(i[t]);return"00:00:00"===n?null:s.createElement(Ta.a.Row,{key:a,style:{backgroundColor:"lavender"}},s.createElement(Ta.a.Cell,null,t),s.createElement(Ta.a.Cell,null,s.createElement("div",{style:{display:"inline"},className:"hover-link",onClick:function(){return a=Ht[t].problemText,n=t,e(Xa(a)),e(Za(n)),void e(Qa(!0));var a,n},dangerouslySetInnerHTML:{__html:on.makeHtml(Ht[t].problemName)}})),s.createElement(Ta.a.Cell,{style:{textAlign:"center"}},n))})))),Object.keys(i).length?s.createElement("div",{style:{width:"100%",padding:"40px 0"}},s.createElement(qa.a,{style:{width:"138px",display:"block",margin:"auto"},onClick:function(){!function(){var e={};localStorage.setItem("personalBests",JSON.stringify(e))}(),r(n+1)}},"Clear Stats")):s.createElement("p",{style:{padding:"10px",margin:"auto",width:"80vw"}},"The history is empty."))},gn=a(643),xn=a(642);var dn=function(e){var t,a=e.page,n=Object(zt.b)(),r=Object(zt.c)((function(e){return e.game.isBusyTesting})),i=Object(zt.c)((function(e){return e.game.revealButtonPressed})),o=Object(zt.c)((function(e){return e.game.results})),l=Object(zt.c)((function(e){return e.game.totalSeconds})),g=Object(zt.c)((function(e){return e.filter.selections})),x=Object(Ca.f)(),d=Object(Ca.g)().id,c=Ht[d],u=0,h=Object(ba.a)(o);try{for(h.s();!(t=h.n()).done;){t.value.ok&&u++}}catch(v){h.e(v)}finally{h.f()}var p=(c&&c.testCases&&c.testCases.length)===u,m=Boolean(g&&g.length>0),f=o.length>0&&o.every((function(e){return e.ok}));return s.createElement(gn.a,null,"/"!==a?s.createElement(gn.a.Item,null,s.createElement(qa.a.Group,null,s.createElement(xn.a,{content:"Home",trigger:s.createElement(qa.a,{icon:!0,onClick:function(){x.push("/")}},s.createElement(Ea.a,{name:"home"}))}))):null,s.createElement(gn.a.Item,null,s.createElement("span",{style:{fontWeight:"bolder",fontSize:"20px",fontVariant:"small-caps"}},"Puzzler")),"/"===a?s.createElement(gn.a.Item,null,s.createElement(qa.a.Group,null,s.createElement(xn.a,{content:"Reset Filters",trigger:s.createElement(qa.a,{icon:!0,onClick:function(){n(en())}},s.createElement(Ea.a,{name:"undo"}))}))):null,"/:id"===a?s.createElement(s.Fragment,null,s.createElement(gn.a.Item,null,s.createElement(qa.a.Group,null,s.createElement(xn.a,{content:"Run Tests (ctrl-m)",trigger:s.createElement(qa.a,{icon:!0,onClick:function(){r||i||n(Ia(d))},disabled:r||i},s.createElement(Ea.a,{name:"rocket",className:r?"animate-icon":""}))}),s.createElement(xn.a,{content:"Proceed to Next Problem",trigger:s.createElement(qa.a,{icon:!0,onClick:function(){if(p)if(m){var e=g[0];n(da(d)),n(tn()),x.push("/".concat(e))}else n(ga(d)),x.push("/sessionStats")},disabled:!p},s.createElement(Ea.a,{name:"step forward"}))}))),s.createElement(gn.a.Item,null,s.createElement("span",{style:{color:Na(l,c,i,f)}},ka(l)),function(e,t){return t?s.createElement("span",{style:{color:"green",fontWeight:"bold"}},"- PASSED!"):e?s.createElement("span",{style:{color:"red"}},"- Stopped"):null}(i,f)),m?null:s.createElement(gn.a.Item,null,s.createElement("span",{style:{fontWeight:"bold",color:"orange"}},"Last Problem")),s.createElement(gn.a.Item,null,s.createElement(qa.a.Group,null,s.createElement(xn.a,{content:"Reveal Solution",trigger:s.createElement(qa.a,{icon:!0,onClick:function(){i||f||n(ua({id:d,data:c}))},disabled:i||f},s.createElement(Ea.a,{name:"eye"}))}))),s.createElement(gn.a.Item,null,s.createElement(qa.a.Group,null,s.createElement(xn.a,{content:"Skip this Problem",trigger:s.createElement(qa.a,{icon:!0,onClick:function(){if(!f)if(m){var e=g[0];n(ca(d)),n(tn()),x.push("/".concat(e))}else n(xa(d)),x.push("/sessionStats")},disabled:f},s.createElement(Ea.a,{name:"fast forward"}))})))):null,s.createElement(gn.a.Item,{position:"right"},"/sessionStats"!==a?s.createElement(xn.a,{content:"See Session Stats",trigger:s.createElement(qa.a,{icon:!0,style:{marginRight:"10px"},onClick:function(){d&&n(xa(d)),x.push("/sessionStats")}},s.createElement(Ea.a,{name:"file alternate outline"}))}):null,"/historicStats"!==a?s.createElement(xn.a,{content:"See Historic Stats",trigger:s.createElement(qa.a,{icon:!0,onClick:function(){d&&n(xa(d)),x.push("/historicStats")}},s.createElement(Ea.a,{name:"history"}))}):null))},cn=a(641),un=new Aa.a.Converter;var hn=function(){var e=Object(zt.b)(),t=Object(zt.c)((function(e){return e.filter.selections})),a=Object(zt.c)((function(e){return e.filter.results})),n=function(a){e(Ya([].concat(Object(l.a)(t),[a])))},r=a.filter((function(e){return!t.includes(e)}));return s.createElement(La.a,{style:{width:"100%",height:"100%"}},s.createElement(La.a.Content,{header:"Filter Results"}),s.createElement(cn.a,{style:{padding:"0",margin:"0"}}),s.createElement("div",{style:{overflowY:"scroll"}},s.createElement("div",{style:{padding:"1em",height:"63px"}},s.createElement("div",{style:{display:"inline",height:"36px",lineHeight:"36px",float:"left"}},"Found ",r.length," results."),s.createElement(qa.a,{onClick:function(){return function(){var e=r[Math.floor(Math.random()*r.length)];n(e)}()},disabled:Boolean(!r.length),icon:!0,labelPosition:"right",style:{display:"inline",float:"right"}},"Add Random",s.createElement(Ea.a,{name:"right arrow"}))),s.createElement("div",{style:{padding:"0 1em 1em 1em",clear:"both"}},s.createElement(Ta.a,{celled:!0,compact:"very"},s.createElement(Ta.a.Header,null,s.createElement(Ta.a.Row,null,s.createElement(Ta.a.HeaderCell,null,"Name"),s.createElement(Ta.a.HeaderCell,{style:{textAlign:"center"}},"Difficulty"),s.createElement(Ta.a.HeaderCell,{style:{textAlign:"center"}},"Effort"),s.createElement(Ta.a.HeaderCell,{style:{textAlign:"center"}},"Tags"),s.createElement(Ta.a.HeaderCell,{style:{textAlign:"center"}},"Action"))),s.createElement(Ta.a.Body,null,r.length?r.map((function(a){var r=Ht[a],i=r.tags.find((function(e){return k.includes(e)})),o=t.includes(r.problemID);return s.createElement(Ta.a.Row,{key:r.problemID,className:o?"existing-selection":""},s.createElement(Ta.a.Cell,null,s.createElement("div",{style:{display:"inline"},className:"hover-link",onClick:function(){return t=r.problemText,a=r.problemID,e(Xa(t)),e(Za(a)),void e(Qa(!0));var t,a},dangerouslySetInnerHTML:{__html:un.makeHtml("**".concat(r.problemID,"**:  ")+r.problemName)}})),s.createElement(Ta.a.Cell,{style:{textAlign:"center"}},s.createElement("span",{style:{backgroundColor:"azure",color:"black",display:"inline-block",border:"1px solid darkslategrey",borderRadius:"50%",width:"1.5em",height:"1.5em",lineHeight:"1.25em",verticalAlign:"center",boxShadow:"1px 1px 2px lightslategrey",cursor:"default"},title:i},i.slice(0,1))),s.createElement(Ta.a.Cell,{style:{textAlign:"center"}},r.effort),s.createElement(Ta.a.Cell,{style:{textAlign:"center"}},s.createElement("span",{style:{fontVariant:"small-caps",fontSize:"0.8em",fontWeight:"bold"}},Object(l.a)(r.tags).sort().filter((function(e){return!k.includes(e)&&!N.includes(e)})).map((function(e){return y[e]})).join(", "))),s.createElement(Ta.a.Cell,{style:{textAlign:"center"}},o?s.createElement(qa.a,{icon:!0,onClick:function(){return a=r.problemID,void e(Ya(t.filter((function(e){return e!==a}))));var a}},s.createElement(Ea.a,{className:"hover-circle-off",name:"minus"})):s.createElement(qa.a,{icon:!0,onClick:function(){return n(r.problemID)}},s.createElement(Ea.a,{className:"hover-circle-on",name:"add"}))))})):s.createElement(Ta.a.Row,{key:0},s.createElement(Ta.a.Cell,{colSpan:"4"},"No Results")))))))},pn=new Aa.a.Converter;var mn=function(){var e=Object(Ca.f)(),t=Object(Ca.g)().id,a=Object(zt.b)(),n=Object(zt.c)((function(e){return e.filter.selections}));return s.createElement(La.a,{style:{width:"100%",height:"100%"}},s.createElement(La.a.Content,{header:"Selections"}),s.createElement(cn.a,{style:{padding:"0",margin:"0"}}),s.createElement("div",{style:{overflowY:"scroll"}},s.createElement("div",{style:{padding:"1em",height:"63px"}},s.createElement(qa.a,{disabled:Boolean(!n.length),style:{float:"left"},onClick:function(){a(Ya([]))}},"Clear All"),s.createElement(qa.a,{style:{float:"right"},onClick:function(){var s=n[0];a(da(t)),a(tn()),e.push("/".concat(s))},disabled:Boolean(!n.length),primary:!0},"START")),s.createElement(cn.a,{style:{padding:"0",margin:"0"}}),s.createElement("div",{style:{padding:"1em 1em 0 1em"}},n.length," Problem(s) Selected."),s.createElement("div",{style:{padding:"1em"}},s.createElement(Ta.a,{celled:!0,compact:"very"},s.createElement(Ta.a.Header,null,s.createElement(Ta.a.Row,null,s.createElement(Ta.a.HeaderCell,null,"Name"),s.createElement(Ta.a.HeaderCell,{style:{textAlign:"center"}},"Difficulty"),s.createElement(Ta.a.HeaderCell,{style:{textAlign:"center"}},"Effort"),s.createElement(Ta.a.HeaderCell,{style:{textAlign:"center"}},"Tags"),s.createElement(Ta.a.HeaderCell,{style:{textAlign:"center"}},"Action"))),s.createElement(Ta.a.Body,null,n.length?n.map((function(e){var t=Ht[e],r=t.tags.find((function(e){return k.includes(e)}));return s.createElement(Ta.a.Row,{key:t.problemID},s.createElement(Ta.a.Cell,null,s.createElement("div",{style:{display:"inline"},className:"hover-link",onClick:function(){return e=t.problemText,n=t.problemID,a(Xa(e)),a(Za(n)),void a(Qa(!0));var e,n},dangerouslySetInnerHTML:{__html:pn.makeHtml("**".concat(t.problemID,"**:  ")+t.problemName)}})),s.createElement(Ta.a.Cell,{style:{textAlign:"center"}},s.createElement("span",{style:{backgroundColor:"azure",color:"black",display:"inline-block",border:"1px solid darkslategrey",borderRadius:"50%",width:"1.5em",height:"1.5em",lineHeight:"1.25em",verticalAlign:"center",boxShadow:"1px 1px 2px lightslategrey",cursor:"default"},title:r},r.slice(0,1))),s.createElement(Ta.a.Cell,{style:{textAlign:"center"}},t.effort),s.createElement(Ta.a.Cell,{style:{textAlign:"center"}},s.createElement("span",{style:{fontVariant:"small-caps",fontSize:"0.75em",fontWeight:"bold"}},Object(l.a)(t.tags).sort().filter((function(e){return!k.includes(e)&&!N.includes(e)})).map((function(e){return y[e]})).join(", "))),s.createElement(Ta.a.Cell,{style:{textAlign:"center"}},s.createElement(qa.a,{icon:!0,onClick:function(){return e=t.problemID,void a(Ya(n.filter((function(t){return t!==e}))));var e}},s.createElement(Ea.a,{className:"hover-circle-off",name:"minus"}))))})):s.createElement(Ta.a.Row,{key:0},s.createElement(Ta.a.Cell,{colSpan:"4"},"No Selections")))))))},fn=a(115);var vn=function(){var e=Object(zt.b)(),t=Object(zt.c)((function(e){return e.filter.tags})),a=function(e){return t.find((function(t){return t.name===e})).isSelected},n=t.every((function(e){return!0===e.isSelected})),r=t.every((function(e){return!1===e.isSelected})),i=function(a){e($a(t.map((function(e){return e.name===a?{name:e.name,isSelected:!e.isSelected}:e}))))};return s.createElement(La.a,{style:{width:"100%",height:"100%"}},s.createElement(La.a.Content,{header:"Filters"}),s.createElement(cn.a,{style:{padding:"0",margin:"0"}}),s.createElement("div",{style:{overflowY:"scroll"}},s.createElement("div",{style:{padding:"1em",height:"63px"}},s.createElement(xn.a,{content:"Clear All",trigger:s.createElement(qa.a,{style:{float:"left"},disabled:r,onClick:function(){e($a(t.map((function(e){return{name:e.name,isSelected:!1}}))))}},"Clear All")}),s.createElement(xn.a,{content:"Select All",trigger:s.createElement(qa.a,{style:{float:"right"},disabled:n,onClick:function(){e($a(t.map((function(e){return{name:e.name,isSelected:!0}}))))}},"Select All")})),s.createElement(cn.a,{style:{padding:"0",margin:"0"}}),s.createElement(La.a.Content,{style:{width:"100%",height:"100%",padding:"1em 2em .5em 2em"}},s.createElement("div",{style:{display:"block",width:"100%"}},k.map((function(e){return s.createElement(fn.a,{key:e,as:"a",size:"tiny",style:{margin:"4px 10px"},className:a(e)?"ui tag label teal":"ui tag label",onClick:function(){return i(e)}},e)})),s.createElement("hr",null),N.map((function(e){return s.createElement(fn.a,{key:e,as:"a",size:"tiny",style:{margin:"4px 10px"},className:a(e)?"ui tag label teal":"ui tag label",onClick:function(){return i(e)}},e)})),s.createElement("hr",null),t.filter((function(e){return![].concat(Object(l.a)(k),Object(l.a)(N)).includes(e.name)})).map((function(e){return s.createElement(fn.a,{key:e.name,as:"a",size:"tiny",style:{margin:"4px 10px"},className:a(e.name)?"ui tag label teal":"ui tag label",onClick:function(){return i(e.name)}},e.name)})),s.createElement("hr",null)))))};var wn=function(){var e=Object(zt.b)(),t=Object(zt.c)((function(e){return e.filter.tags})),a=s.useCallback((function(){var a,n=t.filter((function(e){return e.isSelected})).map((function(e){return e.name})),s=[],r=[],i=[],o=Object(ba.a)(n);try{for(o.s();!(a=o.n()).done;){var l=a.value;k.includes(l)&&s.push(l),N.includes(l)&&r.push(l),I.includes(l)&&i.push(l)}}catch(x){o.e(x)}finally{o.f()}var g=Object.keys(Ht).map((function(e){return Number(e)})).filter((function(e){var t=Ht[String(e)];if(s.length){var a,n=[],o=Object(ba.a)(t.tags);try{for(o.s();!(a=o.n()).done;){var l=a.value;k.includes(l)&&n.push(l)}}catch(x){o.e(x)}finally{o.f()}if(!s.some((function(e){return n.includes(e)})))return!1}if(r.length){var g,d=[],c=Object(ba.a)(t.tags);try{for(c.s();!(g=c.n()).done;){var u=g.value;N.includes(u)&&d.push(u)}}catch(x){c.e(x)}finally{c.f()}if(!r.some((function(e){return d.includes(e)})))return!1}if(i.length){var h,p=[],m=Object(ba.a)(t.tags);try{for(m.s();!(h=m.n()).done;){var f=h.value;I.includes(f)&&p.push(f)}}catch(x){m.e(x)}finally{m.f()}if(!i.some((function(e){return p.includes(e)})))return!1}return!0}));e(Ua(g))}),[t,e]);return s.useEffect((function(){a()}),[a]),s.createElement("div",{style:{width:"100%",height:"100%",overflowY:"hidden",overflowX:"hidden"}},s.createElement(La.a.Content,null,s.createElement("div",{style:{position:"absolute",top:"0",left:"0",height:"calc(47vh - 40px)",width:"55vw"}},s.createElement(vn,null))))};function bn(){return s.createElement(s.Fragment,null,s.createElement("div",{style:{position:"absolute",top:"calc(40px + 3vh)",left:"2vw",height:"calc(48vh - 40px)",width:"55vw"}},s.createElement(wn,null)),s.createElement("div",{style:{position:"absolute",top:"calc(40px + 3vh)",left:"58vw",height:"calc(94vh - 40px)",width:"40vw"}},s.createElement(mn,null)),s.createElement("div",{style:{position:"absolute",top:"52vh",left:"2vw",height:"45vh",width:"55vw"}},s.createElement(hn,null)))}var yn=new Aa.a.Converter;var kn=function(){var e=Object(zt.b)(),t=Object(zt.c)((function(e){return e.filter.showModal})),a=Object(zt.c)((function(e){return e.filter.activeProblemText})),n=Object(zt.c)((function(e){return e.filter.activeProblemId}));return s.createElement(Oa.a,{onClose:function(){return e(Qa(!1))},onOpen:function(){return e(Qa(!0))},open:t},s.createElement(Oa.a.Header,null,"Problem Text"),s.createElement(Oa.a.Content,null,s.createElement("div",{dangerouslySetInnerHTML:{__html:yn.makeHtml(a)}}),s.createElement(Ja,{noteSource:Ht[n]&&Ht[n].source||[]})),s.createElement(Oa.a.Actions,null,s.createElement(qa.a,{style:{width:"138px"},onClick:function(){return e(Qa(!1))}},"Close")))},Nn=null;var In=function(){var e=Object(zt.b)(),t=Object(zt.c)((function(e){return e.game.isRunning}));return s.useEffect((function(){t?Nn=window.setInterval((function(){e(ra())}),1e3):Nn&&window.clearInterval(Nn)}),[t,e]),s.createElement(s.Fragment,null,s.createElement(kn,null),s.createElement(Ca.c,null,s.createElement(Ca.a,{exact:!0,path:"/"},s.createElement(dn,{page:"/"}),s.createElement(bn,null)),s.createElement(Ca.a,{exact:!0,path:"/sessionStats"},s.createElement(dn,{page:"/sessionStats"}),s.createElement(sn,null)),s.createElement(Ca.a,{exact:!0,path:"/historicStats"},s.createElement(dn,{page:"/historicStats"}),s.createElement(ln,null)),s.createElement(Ca.a,{exact:!0,path:"/:id"},s.createElement(dn,{page:"/:id"}),s.createElement(Wa,null))))},Cn=(a(82),a(202),a(203),a(204),a(205),a(206),a(621),a(622),a(43)),_n=a(155),Sn=a.n(_n),Ln=a(156),Tn=a(49),En=a(24),On=Object(En.c)({game:ha,filter:an}),qn={key:"root",version:1,storage:Sn.a},Dn=Object(Tn.g)(qn,On),Mn=Object(Yt.a)({reducer:Dn,middleware:Object(Yt.d)({serializableCheck:{ignoredActions:[Tn.a,Tn.f,Tn.b,Tn.c,Tn.d,Tn.e]}})}),jn=Object(Tn.h)(Mn);o.a.render(r.a.createElement(zt.a,{store:Mn},r.a.createElement(Ln.a,{loading:null,persistor:jn},r.a.createElement(Cn.a,null,r.a.createElement(In,null)))),document.getElementById("root"))}},[[166,1,2]]]);
//# sourceMappingURL=main.d96231e7.chunk.js.map