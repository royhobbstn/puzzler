import { CACHE, ALGORITHM, INTERMEDIATE } from '../constants.js';

const solution = [
  { stage: 0, text: '' },
  { stage: 0, text: 'class Node {' },
  { stage: 0, text: '  constructor(key, data) {' },
  { stage: 0, text: '    this.data = data;' },
  { stage: 0, text: '    this.key = key;' },
  { stage: 0, text: '    this.prev = null;' },
  { stage: 0, text: '    this.next = null;' },
  { stage: 0, text: '  }' },
  { stage: 0, text: '}' },
  { stage: 0, text: '' },
  { stage: 0, text: 'class DoublyLinkedList {' },
  { stage: 0, text: '  constructor() {' },
  { stage: 0, text: "    this.head = new Node('head', 0);" },
  { stage: 0, text: "    this.tail = new Node('tail', 0);" },
  { stage: 0, text: '    this.head.next = this.tail;' },
  { stage: 0, text: '    this.tail.prev = this.head;' },
  { stage: 0, text: '  }' },
  { stage: 0, text: '' },
  { stage: 3, text: '  detach(node) {' },
  { stage: 4, text: '    const prev = node.prev;' },
  { stage: 4, text: '    const next = node.next;' },
  { stage: 4, text: '    prev.next = next;' },
  { stage: 4, text: '    next.prev = prev;' },
  { stage: 3, text: '  }' },
  { stage: 0, text: '' },
  { stage: 6, text: '  addToFront(node) {' },
  { stage: 7, text: '    const head = this.head;' },
  { stage: 7, text: '    const hnext = head.next;' },
  { stage: 8, text: '    head.next = node;' },
  { stage: 8, text: '    node.next = hnext;' },
  { stage: 8, text: '    node.prev = head;' },
  { stage: 8, text: '    hnext.prev = node;' },
  { stage: 6, text: '  }' },
  { stage: 0, text: '' },
  { stage: 12, text: '  removeLast() {' },
  { stage: 13, text: '    const del = this.tail.prev;' },
  { stage: 13, text: '    const prev = del.prev;' },
  { stage: 13, text: '    prev.next = this.tail;' },
  { stage: 13, text: '    this.tail.prev = prev;' },
  { stage: 12, text: '  }' },
  { stage: 0, text: '}' },
  { stage: 0, text: '' },
  { stage: 0, text: 'class LRUCache {' },
  { stage: 0, text: '  constructor(capacity) {' },
  { stage: 0, text: '    if (!capacity) {' },
  { stage: 0, text: "      throw new Error('Declare LRUCache with an integer capacity > 0.');" },
  { stage: 0, text: '    }' },
  { stage: 0, text: '    this.capacity = capacity;' },
  { stage: 0, text: '    this.count = 0;' },
  { stage: 0, text: '    this.hash = {};' },
  { stage: 0, text: '    this.ll = new DoublyLinkedList();' },
  { stage: 0, text: '  }' },
  { stage: 0, text: '' },
  { stage: 0, text: '  get(key) {' },
  { stage: 1, text: '    const node = this.hash[key];' },
  { stage: 1, text: '    if (node === undefined) {' },
  { stage: 1, text: '      return -1;' },
  { stage: 1, text: '    }' },
  { stage: 2, text: '    this.ll.detach(node);' },
  { stage: 5, text: '    this.ll.addToFront(node);' },
  { stage: 5, text: '    return node.data;' },
  { stage: 0, text: '  }' },
  { stage: 0, text: '' },
  { stage: 0, text: '  put(key, value) {' },
  { stage: 9, text: '    let node = this.hash[key];' },
  { stage: 9, text: '    if (!node) {' },
  { stage: 10, text: '      this.count++;' },
  { stage: 10, text: '      if (this.count > this.capacity) {' },
  { stage: 11, text: '        this.ll.removeLast();' },
  { stage: 11, text: '        this.count--;' },
  { stage: 10, text: '      }' },
  { stage: 14, text: '      node = new Node(key, value);' },
  { stage: 14, text: '      this.hash[key] = node;' },
  { stage: 9, text: '    } else {' },
  { stage: 15, text: '      node.data = value;' },
  { stage: 15, text: '      this.ll.detach(node);' },
  { stage: 9, text: '    }' },
  { stage: 16, text: '    this.ll.addToFront(node);' },
  { stage: 0, text: '  }' },
  { stage: 0, text: '}' },
  { stage: 0, text: '' },
];

export const data = {
  problemID: 66,
  problemName: 'Implement an *LRUCache* class.',
  problemText: `Implement **get** and **put** methods for an *LRUCache* class which uses an internal *DoublyLinkList* class to store the data.  
   - The **get** method will return a value for a given \`key\`, or will return \`-1\` if that \`key\` is not found in the cache.
   - The **put** method will either modify or add a node to the top of the cache, and evict a node from the bottom of the cache if the cache exceeds capacity.
  `,
  testCases: [
    {
      id: 1,
      name: 'compiles',
      inherit: [],
      code: `const cache = new LRUCache(3);`,
      evaluate: `Boolean(cache);`,
      expected: true,
    },
    {
      id: 2,
      name: 'evicts propertly',
      inherit: [1],
      code: `cache.put('a', 1);cache.put('b', 2);cache.put('c', 3);cache.put('d', 4);`,
      evaluate: `cache.list();`,
      expected: JSON.stringify([
        { key: 'd', data: 4 },
        { key: 'c', data: 3 },
        { key: 'b', data: 2 },
      ]),
    },
    {
      id: 3,
      name: 'get returns correct item',
      inherit: [1, 2],
      code: ``,
      evaluate: `cache.get('c');`,
      expected: 3,
    },
    {
      id: 4,
      name: 'get moves item to top of list',
      inherit: [1, 2],
      code: `cache.get('c');`,
      evaluate: `cache.list()`,
      expected: JSON.stringify([
        { key: 'c', data: 3 },
        { key: 'd', data: 4 },
        { key: 'b', data: 2 },
      ]),
    },
    {
      id: 5,
      name: 'get returns -1 when not in cache',
      inherit: [1],
      code: `cache.put('a', 1);`,
      evaluate: `cache.get('c');`,
      expected: -1,
    },
  ],
  setupCode: `
  LRUCache.prototype.list = function () {
    let arr = [];
    let node = this.ll.head.next;
    while (node && node.next) {
      arr.push({ key: node.key, data: node.data });
      node = node.next;
    }
    return arr;
  };
  `,
  source: ['https://leetcode.com/problems/lru-cache'],
  tags: [INTERMEDIATE, CACHE, ALGORITHM],
  solution,
};
