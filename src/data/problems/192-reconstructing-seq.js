import { ALGORITHM, TOPOLOGICAL_SORT } from '../constants.js';

const solution = [
  { stage: 0, text: '' },
  { stage: 0, text: 'function can_construct(originalSeq, sequences) {' },
  { stage: 1, text: '  const sortedOrder = [];' },
  { stage: 2, text: '  if (originalSeq.length <= 0) {' },
  { stage: 3, text: '    return false;' },
  { stage: 2, text: '  }' },
  { stage: 0, text: '' },
  { stage: 4, text: '  const inDegree = {};' },
  { stage: 4, text: '  const graph = {};' },
  { stage: 0, text: '' },
  { stage: 5, text: '  sequences.forEach(sequence => {' },
  { stage: 6, text: '    for (let i = 0; i < sequence.length; i++) {' },
  { stage: 7, text: '      inDegree[sequence[i]] = 0;' },
  { stage: 7, text: '      graph[sequence[i]] = [];' },
  { stage: 6, text: '    }' },
  { stage: 5, text: '  });' },
  { stage: 0, text: '' },
  { stage: 8, text: '  sequences.forEach(sequence => {' },
  { stage: 9, text: '    for (let i = 1; i < sequence.length; i++) {' },
  { stage: 10, text: '      const parent = sequence[i - 1];' },
  { stage: 10, text: '      let child = sequence[i];' },
  { stage: 11, text: '      graph[parent].push(child);' },
  { stage: 11, text: '      inDegree[child] += 1;' },
  { stage: 9, text: '    }' },
  { stage: 8, text: '  });' },
  { stage: 0, text: '' },
  { stage: 12, text: '  const vertices = Object.keys(inDegree);' },
  { stage: 13, text: '  if (vertices.length !== originalSeq.length) {' },
  { stage: 14, text: '    return false;' },
  { stage: 13, text: '  }' },
  { stage: 0, text: '' },
  { stage: 15, text: '  const sources = [];' },
  { stage: 16, text: '  vertices.forEach(key => {' },
  { stage: 17, text: '    if (inDegree[key] === 0) {' },
  { stage: 18, text: '      sources.push(key);' },
  { stage: 17, text: '    }' },
  { stage: 16, text: '  });' },
  { stage: 0, text: '' },
  { stage: 19, text: '  while (sources.length > 0) {' },
  { stage: 20, text: '    if (sources.length > 1) {' },
  { stage: 21, text: '      return false;' },
  { stage: 20, text: '    }' },
  { stage: 22, text: '    if (originalSeq[sortedOrder.length] != sources[sources.length - 1]) {' },
  { stage: 23, text: '      return false;' },
  { stage: 22, text: '    }' },
  { stage: 0, text: '' },
  { stage: 24, text: '    const vertex = sources.shift();' },
  { stage: 25, text: '    sortedOrder.push(vertex);' },
  { stage: 26, text: '    graph[vertex].forEach(child => {' },
  { stage: 27, text: '      inDegree[child] -= 1;' },
  { stage: 28, text: '      if (inDegree[child] === 0) {' },
  { stage: 29, text: '        sources.push(child);' },
  { stage: 28, text: '      }' },
  { stage: 26, text: '    });' },
  { stage: 19, text: '  }' },
  { stage: 0, text: '' },
  { stage: 30, text: '  return sortedOrder.length === originalSeq.length;' },
  { stage: 0, text: '}' },
  { stage: 0, text: '' },
];

export const data = {
  problemID: 192,
  problemName: `Reconstructing a Sequence`,
  problemText: `Given a sequence originalSeq and an array of sequences, write a method to find if originalSeq can be uniquely reconstructed from the array of sequences.

  Unique reconstruction means that we need to find if originalSeq is the only sequence such that all sequences in the array are subsequences of it.`,
  testCases: [
    {
      id: 1,
      name: 'example 1',
      inherit: [],
      code: ``,
      evaluate: `can_construct(
        [1, 2, 3, 4],
        [
          [1, 2],
          [2, 3],
          [3, 4],
        ],
      );`,
      expected: true,
    },
    {
      id: 2,
      name: 'example 2',
      inherit: [],
      code: ``,
      evaluate: `can_construct(
        [1, 2, 3, 4],
        [
          [1, 2],
          [2, 3],
          [2, 4],
        ],
      );`,
      expected: false,
    },
    {
      id: 3,
      name: 'example 3',
      inherit: [],
      code: ``,
      evaluate: `can_construct(
        [3, 1, 4, 2, 5],
        [
          [3, 1, 5],
          [1, 4, 2, 5],
        ],
      );`,
      expected: true,
    },
  ],
  setupCode: ``,
  source: [],
  tags: [TOPOLOGICAL_SORT, ALGORITHM],
  solution,
};
