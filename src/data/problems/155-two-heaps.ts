import { ALGORITHM, HEAP } from '../constants';
import { HEAP_GENERIC } from '../code-imports/import-index.js';

const solution = [
  { stage: 0, text: '' },
  { stage: -1, text: '' },
  { stage: -1, text: '// Heap Class Provided' },
  { stage: -1, text: '' },
  { stage: -1, text: '// add(item: number) :void' },
  { stage: -1, text: '// peek() :number' },
  { stage: -1, text: '// poll() :number' },
  { stage: -1, text: '// remove(item: number) :void' },
  { stage: -1, text: '// length() :number' },
  { stage: 0, text: '' },
  { stage: 0, text: 'class SlidingWindowMedian {' },
  { stage: 0, text: '  constructor() {' },
  { stage: 0, text: '    this.maxHeap = new Heap((a, b) => a >= b);' },
  { stage: 0, text: '    this.minHeap = new Heap((a, b) => a <= b);' },
  { stage: 0, text: '  }' },
  { stage: 0, text: '' },
  { stage: 0, text: '  find_sliding_window_median(nums, k) {' },
  { stage: 1, text: '    const result = Array(nums.length - k + 1).fill(0.0);' },
  { stage: 2, text: '    for (let i = 0; i < nums.length; i++) {' },
  { stage: 3, text: '      if (this.maxHeap.length() === 0 || nums[i] <= this.maxHeap.peek()) {' },
  { stage: 4, text: '        this.maxHeap.add(nums[i]);' },
  { stage: 3, text: '      } else {' },
  { stage: 5, text: '        this.minHeap.add(nums[i]);' },
  { stage: 3, text: '      }' },
  { stage: 0, text: '' },
  { stage: 6, text: '      this.rebalance_heaps();' },
  { stage: 0, text: '' },
  { stage: 11, text: '      if (i - k + 1 >= 0) {' },
  { stage: 12, text: '        if (this.maxHeap.length() === this.minHeap.length()) {' },
  {
    stage: 13,
    text: '          result[i - k + 1] = this.maxHeap.peek() / 2.0 + this.minHeap.peek() / 2.0;',
  },
  { stage: 12, text: '        } else {' },
  { stage: 14, text: '          result[i - k + 1] = this.maxHeap.peek();' },
  { stage: 12, text: '        }' },
  { stage: 0, text: '' },
  { stage: 15, text: '        const elementToBeRemoved = nums[i - k + 1];' },
  { stage: 16, text: '        if (elementToBeRemoved <= this.maxHeap.peek()) {' },
  { stage: 17, text: '          this.maxHeap.remove(elementToBeRemoved, (a, b) => a === b);' },
  { stage: 16, text: '        } else {' },
  { stage: 18, text: '          this.minHeap.remove(elementToBeRemoved, (a, b) => a === b);' },
  { stage: 16, text: '        }' },
  { stage: 0, text: '' },
  { stage: 19, text: '        this.rebalance_heaps();' },
  { stage: 11, text: '      }' },
  { stage: 2, text: '    }' },
  { stage: 0, text: '' },
  { stage: 20, text: '    return result;' },
  { stage: 0, text: '  }' },
  { stage: 0, text: '' },
  { stage: 7, text: '  rebalance_heaps() {' },
  { stage: 8, text: '    if (this.maxHeap.length() > this.minHeap.length() + 1) {' },
  { stage: 9, text: '      this.minHeap.add(this.maxHeap.poll());' },
  { stage: 8, text: '    } else if (this.maxHeap.length() < this.minHeap.length()) {' },
  { stage: 10, text: '      this.maxHeap.add(this.minHeap.poll());' },
  { stage: 8, text: '    }' },
  { stage: 7, text: '  }' },
  { stage: 0, text: '' },
  { stage: 0, text: '}' },
  { stage: 0, text: '' },
];

export const data = {
  problemID: 155,
  problemName: `Sliding Window Median`,
  problemText: `Given an array of numbers and a number ‘k’, find the median of all the ‘k’ sized sub-arrays (or windows) of the array.`,
  testCases: [
    {
      id: 1,
      name: 'example 1',
      inherit: [],
      code: `let slidingWindowMedian = new SlidingWindowMedian();`,
      evaluate: `slidingWindowMedian.find_sliding_window_median([1, 2, -1, 3, 5], 2);`,
      expected: JSON.stringify([1.5, 0.5, 1, 4]),
    },
    {
      id: 2,
      name: 'example 2',
      inherit: [],
      code: `let slidingWindowMedian = new SlidingWindowMedian();`,
      evaluate: `slidingWindowMedian.find_sliding_window_median([1, 2, -1, 3, 5], 3);`,
      expected: JSON.stringify([1, 2, 3]),
    },
  ],
  setupCode: `${HEAP_GENERIC}`,
  source: ['https://www.educative.io/courses/grokking-the-coding-interview/3Y9jm7XRrXO'],
  tags: [HEAP, ALGORITHM],
  solution,
};
